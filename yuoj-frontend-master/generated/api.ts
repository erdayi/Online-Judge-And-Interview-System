/* tslint:disable */
/* eslint-disable */
/**
 * 接口文档
 * yuoj-backend
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface BaseResponseListQuestionCommentVO {
    'code'?: number;
    'data'?: Array<QuestionCommentVO>;
    'message'?: string;
}
export interface BaseResponseLoginUserVO {
    'code'?: number;
    'data'?: LoginUserVO;
    'message'?: string;
}
export interface BaseResponseMapstringint {
    'code'?: number;
    'data'?: { [key: string]: number; };
    'message'?: string;
}
export interface BaseResponseMockInterview {
    'code'?: number;
    'data'?: MockInterview;
    'message'?: string;
}
export interface BaseResponsePageMockInterview {
    'code'?: number;
    'data'?: PageMockInterview;
    'message'?: string;
}
export interface BaseResponsePagePostVO {
    'code'?: number;
    'data'?: PagePostVO;
    'message'?: string;
}
export interface BaseResponsePageQuestion {
    'code'?: number;
    'data'?: PageQuestion;
    'message'?: string;
}
export interface BaseResponsePageQuestionSubmitVO {
    'code'?: number;
    'data'?: PageQuestionSubmitVO;
    'message'?: string;
}
export interface BaseResponsePageQuestionVO {
    'code'?: number;
    'data'?: PageQuestionVO;
    'message'?: string;
}
export interface BaseResponsePageUser {
    'code'?: number;
    'data'?: PageUser;
    'message'?: string;
}
export interface BaseResponsePageUserVO {
    'code'?: number;
    'data'?: PageUserVO;
    'message'?: string;
}
export interface BaseResponsePostVO {
    'code'?: number;
    'data'?: PostVO;
    'message'?: string;
}
export interface BaseResponseQuestion {
    'code'?: number;
    'data'?: Question;
    'message'?: string;
}
export interface BaseResponseQuestionVO {
    'code'?: number;
    'data'?: QuestionVO;
    'message'?: string;
}
export interface BaseResponseUser {
    'code'?: number;
    'data'?: User;
    'message'?: string;
}
export interface BaseResponseUserVO {
    'code'?: number;
    'data'?: UserVO;
    'message'?: string;
}
export interface BaseResponseboolean {
    'code'?: number;
    'data'?: boolean;
    'message'?: string;
}
export interface BaseResponseint {
    'code'?: number;
    'data'?: number;
    'message'?: string;
}
export interface BaseResponselong {
    'code'?: number;
    'data'?: number;
    'message'?: string;
}
export interface BaseResponsestring {
    'code'?: number;
    'data'?: string;
    'message'?: string;
}
export interface DeleteRequest {
    'id'?: number;
}
export interface JudgeCase {
    'input'?: string;
    'output'?: string;
}
export interface JudgeConfig {
    'memoryLimit'?: number;
    'stackLimit'?: number;
    'timeLimit'?: number;
}
export interface JudgeInfo {
    'memory'?: number;
    'message'?: string;
    'time'?: number;
}
export interface LoginUserVO {
    'createTime'?: string;
    'id'?: number;
    'updateTime'?: string;
    'userAvatar'?: string;
    'userName'?: string;
    'userProfile'?: string;
    'userRole'?: string;
}
export interface MockInterview {
    'createTime'?: string;
    'difficulty'?: string;
    'id'?: number;
    'isDelete'?: number;
    'jobPosition'?: string;
    'messages'?: string;
    'status'?: number;
    'updateTime'?: string;
    'userId'?: number;
    'workExperience'?: string;
}
export interface MockInterviewAddRequest {
    'difficulty'?: string;
    'jobPosition'?: string;
    'workExperience'?: string;
}
export interface MockInterviewEventRequest {
    'event'?: string;
    'id'?: number;
    'message'?: string;
}
export interface MockInterviewQueryRequest {
    'current'?: number;
    'difficulty'?: string;
    'id'?: number;
    'jobPosition'?: string;
    'pageSize'?: number;
    'sortField'?: string;
    'sortOrder'?: string;
    'status'?: number;
    'userId'?: number;
    'workExperience'?: string;
}
export interface OrderItem {
    'asc'?: boolean;
    'column'?: string;
}
export interface PageMockInterview {
    'countId'?: string;
    'current'?: number;
    'maxLimit'?: number;
    'optimizeCountSql'?: boolean;
    'orders'?: Array<OrderItem>;
    'pages'?: number;
    'records'?: Array<MockInterview>;
    'searchCount'?: boolean;
    'size'?: number;
    'total'?: number;
}
export interface PagePostVO {
    'countId'?: string;
    'current'?: number;
    'maxLimit'?: number;
    'optimizeCountSql'?: boolean;
    'orders'?: Array<OrderItem>;
    'pages'?: number;
    'records'?: Array<PostVO>;
    'searchCount'?: boolean;
    'size'?: number;
    'total'?: number;
}
export interface PageQuestion {
    'countId'?: string;
    'current'?: number;
    'maxLimit'?: number;
    'optimizeCountSql'?: boolean;
    'orders'?: Array<OrderItem>;
    'pages'?: number;
    'records'?: Array<Question>;
    'searchCount'?: boolean;
    'size'?: number;
    'total'?: number;
}
export interface PageQuestionSubmitVO {
    'countId'?: string;
    'current'?: number;
    'maxLimit'?: number;
    'optimizeCountSql'?: boolean;
    'orders'?: Array<OrderItem>;
    'pages'?: number;
    'records'?: Array<QuestionSubmitVO>;
    'searchCount'?: boolean;
    'size'?: number;
    'total'?: number;
}
export interface PageQuestionVO {
    'countId'?: string;
    'current'?: number;
    'maxLimit'?: number;
    'optimizeCountSql'?: boolean;
    'orders'?: Array<OrderItem>;
    'pages'?: number;
    'records'?: Array<QuestionVO>;
    'searchCount'?: boolean;
    'size'?: number;
    'total'?: number;
}
export interface PageUser {
    'countId'?: string;
    'current'?: number;
    'maxLimit'?: number;
    'optimizeCountSql'?: boolean;
    'orders'?: Array<OrderItem>;
    'pages'?: number;
    'records'?: Array<User>;
    'searchCount'?: boolean;
    'size'?: number;
    'total'?: number;
}
export interface PageUserVO {
    'countId'?: string;
    'current'?: number;
    'maxLimit'?: number;
    'optimizeCountSql'?: boolean;
    'orders'?: Array<OrderItem>;
    'pages'?: number;
    'records'?: Array<UserVO>;
    'searchCount'?: boolean;
    'size'?: number;
    'total'?: number;
}
export interface PostAddRequest {
    'content'?: string;
    'tags'?: Array<string>;
    'title'?: string;
}
export interface PostEditRequest {
    'content'?: string;
    'id'?: number;
    'tags'?: Array<string>;
    'title'?: string;
}
export interface PostFavourAddRequest {
    'postId'?: number;
}
export interface PostFavourQueryRequest {
    'current'?: number;
    'pageSize'?: number;
    'postQueryRequest'?: PostQueryRequest;
    'sortField'?: string;
    'sortOrder'?: string;
    'userId'?: number;
}
export interface PostQueryRequest {
    'content'?: string;
    'current'?: number;
    'favourUserId'?: number;
    'id'?: number;
    'notId'?: number;
    'orTags'?: Array<string>;
    'pageSize'?: number;
    'searchText'?: string;
    'sortField'?: string;
    'sortOrder'?: string;
    'tags'?: Array<string>;
    'title'?: string;
    'userId'?: number;
}
export interface PostThumbAddRequest {
    'postId'?: number;
}
export interface PostUpdateRequest {
    'content'?: string;
    'id'?: number;
    'tags'?: Array<string>;
    'title'?: string;
}
export interface PostVO {
    'content'?: string;
    'createTime'?: string;
    'favourNum'?: number;
    'hasFavour'?: boolean;
    'hasThumb'?: boolean;
    'id'?: number;
    'tagList'?: Array<string>;
    'thumbNum'?: number;
    'title'?: string;
    'updateTime'?: string;
    'user'?: UserVO;
    'userId'?: number;
}
export interface Question {
    'acceptedNum'?: number;
    'answer'?: string;
    'content'?: string;
    'createTime'?: string;
    'favourNum'?: number;
    'id'?: number;
    'isDelete'?: number;
    'judgeCase'?: string;
    'judgeConfig'?: string;
    'submitNum'?: number;
    'tags'?: string;
    'thumbNum'?: number;
    'title'?: string;
    'updateTime'?: string;
    'userId'?: number;
}
export interface QuestionAIGenerateRequest {
    'number'?: number;
    'questionType'?: string;
}
export interface QuestionAddRequest {
    'answer'?: string;
    'content'?: string;
    'judgeCase'?: Array<JudgeCase>;
    'judgeConfig'?: JudgeConfig;
    'tags'?: Array<string>;
    'title'?: string;
}
export interface QuestionCommentAddRequest {
    'content'?: string;
    'parentId'?: number;
    'questionId'?: number;
    'replyUserId'?: number;
}
export interface QuestionCommentVO {
    'children'?: Array<QuestionCommentVO>;
    'content'?: string;
    'createTime'?: string;
    'hasThumb'?: boolean;
    'id'?: number;
    'parentId'?: number;
    'questionId'?: number;
    'replyUser'?: UserVO;
    'replyUserId'?: number;
    'thumbNum'?: number;
    'updateTime'?: string;
    'user'?: UserVO;
    'userId'?: number;
}
export interface QuestionEditRequest {
    'answer'?: string;
    'content'?: string;
    'id'?: number;
    'judgeCase'?: Array<JudgeCase>;
    'judgeConfig'?: JudgeConfig;
    'tags'?: Array<string>;
    'title'?: string;
}
export interface QuestionFavourAddRequest {
    'questionId'?: number;
}
export interface QuestionQueryRequest {
    'answer'?: string;
    'content'?: string;
    'current'?: number;
    'id'?: number;
    'pageSize'?: number;
    'sortField'?: string;
    'sortOrder'?: string;
    'tags'?: Array<string>;
    'title'?: string;
    'userId'?: number;
}
export interface QuestionSubmitAddRequest {
    'code'?: string;
    'language'?: string;
    'questionId'?: number;
}
export interface QuestionSubmitQueryRequest {
    'current'?: number;
    'language'?: string;
    'pageSize'?: number;
    'questionId'?: number;
    'sortField'?: string;
    'sortOrder'?: string;
    'status'?: number;
    'userId'?: number;
}
export interface QuestionSubmitVO {
    'code'?: string;
    'createTime'?: string;
    'id'?: number;
    'judgeInfo'?: JudgeInfo;
    'language'?: string;
    'questionId'?: number;
    'questionVO'?: QuestionVO;
    'status'?: number;
    'updateTime'?: string;
    'userId'?: number;
    'userVO'?: UserVO;
}
export interface QuestionUpdateRequest {
    'answer'?: string;
    'content'?: string;
    'id'?: number;
    'judgeCase'?: Array<JudgeCase>;
    'judgeConfig'?: JudgeConfig;
    'tags'?: Array<string>;
    'title'?: string;
}
export interface QuestionVO {
    'acceptedNum'?: number;
    'answer'?: string;
    'content'?: string;
    'createTime'?: string;
    'favourNum'?: number;
    'favourTime'?: string;
    'hasFavour'?: boolean;
    'id'?: number;
    'judgeConfig'?: JudgeConfig;
    'submitNum'?: number;
    'tags'?: Array<string>;
    'thumbNum'?: number;
    'title'?: string;
    'updateTime'?: string;
    'userId'?: number;
    'userVO'?: UserVO;
}
export interface User {
    'createTime'?: string;
    'id'?: number;
    'isDelete'?: number;
    'mpOpenId'?: string;
    'unionId'?: string;
    'updateTime'?: string;
    'userAccount'?: string;
    'userAvatar'?: string;
    'userName'?: string;
    'userPassword'?: string;
    'userProfile'?: string;
    'userRole'?: string;
}
export interface UserAddRequest {
    'userAccount'?: string;
    'userAvatar'?: string;
    'userName'?: string;
    'userRole'?: string;
}
export interface UserLoginRequest {
    'userAccount'?: string;
    'userPassword'?: string;
}
export interface UserQueryRequest {
    'current'?: number;
    'id'?: number;
    'mpOpenId'?: string;
    'pageSize'?: number;
    'sortField'?: string;
    'sortOrder'?: string;
    'unionId'?: string;
    'userName'?: string;
    'userProfile'?: string;
    'userRole'?: string;
}
export interface UserRegisterRequest {
    'checkPassword'?: string;
    'userAccount'?: string;
    'userName'?: string;
    'userPassword'?: string;
    'userProfile'?: string;
}
export interface UserUpdateMyRequest {
    'userAvatar'?: string;
    'userName'?: string;
    'userProfile'?: string;
}
export interface UserUpdateRequest {
    'id'?: number;
    'userAvatar'?: string;
    'userName'?: string;
    'userProfile'?: string;
    'userRole'?: string;
}
export interface UserVO {
    'createTime'?: string;
    'id'?: number;
    'userAvatar'?: string;
    'userName'?: string;
    'userProfile'?: string;
    'userRole'?: string;
}

/**
 * DailyCheckInControllerApi - axios parameter creator
 */
export const DailyCheckInControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary checkIn
         * @param {number} questionId questionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkInUsingPOST: async (questionId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'questionId' is not null or undefined
            assertParamExists('checkInUsingPOST', 'questionId', questionId)
            const localVarPath = `/api/daily_check_in/check_in`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (questionId !== undefined) {
                localVarQueryParameter['questionId'] = questionId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getCheckInRecord
         * @param {number} [month] month
         * @param {number} [year] year
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCheckInRecordUsingGET: async (month?: number, year?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/daily_check_in/record`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (month !== undefined) {
                localVarQueryParameter['month'] = month;
            }

            if (year !== undefined) {
                localVarQueryParameter['year'] = year;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getMakeupCardCount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMakeupCardCountUsingGET: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/daily_check_in/makeup_card_count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getTodayQuestion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTodayQuestionUsingGET: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/daily_check_in/today_question`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary makeupCheckIn
         * @param {string} checkInDate checkInDate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        makeupCheckInUsingPOST: async (checkInDate: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'checkInDate' is not null or undefined
            assertParamExists('makeupCheckInUsingPOST', 'checkInDate', checkInDate)
            const localVarPath = `/api/daily_check_in/makeup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (checkInDate !== undefined) {
                localVarQueryParameter['checkInDate'] = (checkInDate as any instanceof Date) ?
                    (checkInDate as any).toISOString() :
                    checkInDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DailyCheckInControllerApi - functional programming interface
 */
export const DailyCheckInControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DailyCheckInControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary checkIn
         * @param {number} questionId questionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkInUsingPOST(questionId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseboolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkInUsingPOST(questionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DailyCheckInControllerApi.checkInUsingPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary getCheckInRecord
         * @param {number} [month] month
         * @param {number} [year] year
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCheckInRecordUsingGET(month?: number, year?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseMapstringint>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCheckInRecordUsingGET(month, year, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DailyCheckInControllerApi.getCheckInRecordUsingGET']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary getMakeupCardCount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMakeupCardCountUsingGET(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseint>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMakeupCardCountUsingGET(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DailyCheckInControllerApi.getMakeupCardCountUsingGET']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary getTodayQuestion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTodayQuestionUsingGET(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponselong>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTodayQuestionUsingGET(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DailyCheckInControllerApi.getTodayQuestionUsingGET']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary makeupCheckIn
         * @param {string} checkInDate checkInDate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async makeupCheckInUsingPOST(checkInDate: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseboolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.makeupCheckInUsingPOST(checkInDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DailyCheckInControllerApi.makeupCheckInUsingPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DailyCheckInControllerApi - factory interface
 */
export const DailyCheckInControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DailyCheckInControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary checkIn
         * @param {number} questionId questionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkInUsingPOST(questionId: number, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponseboolean> {
            return localVarFp.checkInUsingPOST(questionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getCheckInRecord
         * @param {number} [month] month
         * @param {number} [year] year
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCheckInRecordUsingGET(month?: number, year?: number, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponseMapstringint> {
            return localVarFp.getCheckInRecordUsingGET(month, year, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getMakeupCardCount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMakeupCardCountUsingGET(options?: RawAxiosRequestConfig): AxiosPromise<BaseResponseint> {
            return localVarFp.getMakeupCardCountUsingGET(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getTodayQuestion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTodayQuestionUsingGET(options?: RawAxiosRequestConfig): AxiosPromise<BaseResponselong> {
            return localVarFp.getTodayQuestionUsingGET(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary makeupCheckIn
         * @param {string} checkInDate checkInDate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        makeupCheckInUsingPOST(checkInDate: string, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponseboolean> {
            return localVarFp.makeupCheckInUsingPOST(checkInDate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DailyCheckInControllerApi - object-oriented interface
 */
export class DailyCheckInControllerApi extends BaseAPI {
    /**
     * 
     * @summary checkIn
     * @param {number} questionId questionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public checkInUsingPOST(questionId: number, options?: RawAxiosRequestConfig) {
        return DailyCheckInControllerApiFp(this.configuration).checkInUsingPOST(questionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getCheckInRecord
     * @param {number} [month] month
     * @param {number} [year] year
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCheckInRecordUsingGET(month?: number, year?: number, options?: RawAxiosRequestConfig) {
        return DailyCheckInControllerApiFp(this.configuration).getCheckInRecordUsingGET(month, year, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getMakeupCardCount
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getMakeupCardCountUsingGET(options?: RawAxiosRequestConfig) {
        return DailyCheckInControllerApiFp(this.configuration).getMakeupCardCountUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getTodayQuestion
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getTodayQuestionUsingGET(options?: RawAxiosRequestConfig) {
        return DailyCheckInControllerApiFp(this.configuration).getTodayQuestionUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary makeupCheckIn
     * @param {string} checkInDate checkInDate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public makeupCheckInUsingPOST(checkInDate: string, options?: RawAxiosRequestConfig) {
        return DailyCheckInControllerApiFp(this.configuration).makeupCheckInUsingPOST(checkInDate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FileControllerApi - axios parameter creator
 */
export const FileControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary uploadFile
         * @param {string} [biz] 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFileUsingPOST: async (biz?: string, file?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/file/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            if (biz !== undefined) {
                localVarQueryParameter['biz'] = biz;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FileControllerApi - functional programming interface
 */
export const FileControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FileControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary uploadFile
         * @param {string} [biz] 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFileUsingPOST(biz?: string, file?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponsestring>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFileUsingPOST(biz, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FileControllerApi.uploadFileUsingPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FileControllerApi - factory interface
 */
export const FileControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FileControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary uploadFile
         * @param {string} [biz] 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFileUsingPOST(biz?: string, file?: File, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponsestring> {
            return localVarFp.uploadFileUsingPOST(biz, file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FileControllerApi - object-oriented interface
 */
export class FileControllerApi extends BaseAPI {
    /**
     * 
     * @summary uploadFile
     * @param {string} [biz] 
     * @param {File} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public uploadFileUsingPOST(biz?: string, file?: File, options?: RawAxiosRequestConfig) {
        return FileControllerApiFp(this.configuration).uploadFileUsingPOST(biz, file, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MockInterviewControllerApi - axios parameter creator
 */
export const MockInterviewControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary addMockInterview
         * @param {MockInterviewAddRequest} mockInterviewAddRequest mockInterviewAddRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMockInterviewUsingPOST: async (mockInterviewAddRequest: MockInterviewAddRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mockInterviewAddRequest' is not null or undefined
            assertParamExists('addMockInterviewUsingPOST', 'mockInterviewAddRequest', mockInterviewAddRequest)
            const localVarPath = `/api/mockInterview/add`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mockInterviewAddRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deleteMockInterview
         * @param {DeleteRequest} deleteRequest deleteRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMockInterviewUsingPOST: async (deleteRequest: DeleteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deleteRequest' is not null or undefined
            assertParamExists('deleteMockInterviewUsingPOST', 'deleteRequest', deleteRequest)
            const localVarPath = `/api/mockInterview/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getMockInterviewById
         * @param {number} [id] id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMockInterviewByIdUsingGET: async (id?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/mockInterview/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary handleMockInterviewEvent
         * @param {MockInterviewEventRequest} mockInterviewEventRequest mockInterviewEventRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleMockInterviewEventUsingPOST: async (mockInterviewEventRequest: MockInterviewEventRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mockInterviewEventRequest' is not null or undefined
            assertParamExists('handleMockInterviewEventUsingPOST', 'mockInterviewEventRequest', mockInterviewEventRequest)
            const localVarPath = `/api/mockInterview/handleEvent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mockInterviewEventRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary listMockInterviewByPage
         * @param {MockInterviewQueryRequest} mockInterviewQueryRequest mockInterviewQueryRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMockInterviewByPageUsingPOST: async (mockInterviewQueryRequest: MockInterviewQueryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mockInterviewQueryRequest' is not null or undefined
            assertParamExists('listMockInterviewByPageUsingPOST', 'mockInterviewQueryRequest', mockInterviewQueryRequest)
            const localVarPath = `/api/mockInterview/list/page`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mockInterviewQueryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary listMyMockInterviewVOByPage
         * @param {MockInterviewQueryRequest} mockInterviewQueryRequest mockInterviewQueryRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMyMockInterviewVOByPageUsingPOST: async (mockInterviewQueryRequest: MockInterviewQueryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mockInterviewQueryRequest' is not null or undefined
            assertParamExists('listMyMockInterviewVOByPageUsingPOST', 'mockInterviewQueryRequest', mockInterviewQueryRequest)
            const localVarPath = `/api/mockInterview/my/list/page/vo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mockInterviewQueryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MockInterviewControllerApi - functional programming interface
 */
export const MockInterviewControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MockInterviewControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary addMockInterview
         * @param {MockInterviewAddRequest} mockInterviewAddRequest mockInterviewAddRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addMockInterviewUsingPOST(mockInterviewAddRequest: MockInterviewAddRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponselong>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addMockInterviewUsingPOST(mockInterviewAddRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MockInterviewControllerApi.addMockInterviewUsingPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary deleteMockInterview
         * @param {DeleteRequest} deleteRequest deleteRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMockInterviewUsingPOST(deleteRequest: DeleteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseboolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMockInterviewUsingPOST(deleteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MockInterviewControllerApi.deleteMockInterviewUsingPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary getMockInterviewById
         * @param {number} [id] id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMockInterviewByIdUsingGET(id?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseMockInterview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMockInterviewByIdUsingGET(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MockInterviewControllerApi.getMockInterviewByIdUsingGET']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary handleMockInterviewEvent
         * @param {MockInterviewEventRequest} mockInterviewEventRequest mockInterviewEventRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleMockInterviewEventUsingPOST(mockInterviewEventRequest: MockInterviewEventRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponsestring>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handleMockInterviewEventUsingPOST(mockInterviewEventRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MockInterviewControllerApi.handleMockInterviewEventUsingPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary listMockInterviewByPage
         * @param {MockInterviewQueryRequest} mockInterviewQueryRequest mockInterviewQueryRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMockInterviewByPageUsingPOST(mockInterviewQueryRequest: MockInterviewQueryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponsePageMockInterview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMockInterviewByPageUsingPOST(mockInterviewQueryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MockInterviewControllerApi.listMockInterviewByPageUsingPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary listMyMockInterviewVOByPage
         * @param {MockInterviewQueryRequest} mockInterviewQueryRequest mockInterviewQueryRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMyMockInterviewVOByPageUsingPOST(mockInterviewQueryRequest: MockInterviewQueryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponsePageMockInterview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMyMockInterviewVOByPageUsingPOST(mockInterviewQueryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MockInterviewControllerApi.listMyMockInterviewVOByPageUsingPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MockInterviewControllerApi - factory interface
 */
export const MockInterviewControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MockInterviewControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary addMockInterview
         * @param {MockInterviewAddRequest} mockInterviewAddRequest mockInterviewAddRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMockInterviewUsingPOST(mockInterviewAddRequest: MockInterviewAddRequest, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponselong> {
            return localVarFp.addMockInterviewUsingPOST(mockInterviewAddRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary deleteMockInterview
         * @param {DeleteRequest} deleteRequest deleteRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMockInterviewUsingPOST(deleteRequest: DeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponseboolean> {
            return localVarFp.deleteMockInterviewUsingPOST(deleteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getMockInterviewById
         * @param {number} [id] id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMockInterviewByIdUsingGET(id?: number, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponseMockInterview> {
            return localVarFp.getMockInterviewByIdUsingGET(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary handleMockInterviewEvent
         * @param {MockInterviewEventRequest} mockInterviewEventRequest mockInterviewEventRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleMockInterviewEventUsingPOST(mockInterviewEventRequest: MockInterviewEventRequest, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponsestring> {
            return localVarFp.handleMockInterviewEventUsingPOST(mockInterviewEventRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary listMockInterviewByPage
         * @param {MockInterviewQueryRequest} mockInterviewQueryRequest mockInterviewQueryRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMockInterviewByPageUsingPOST(mockInterviewQueryRequest: MockInterviewQueryRequest, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponsePageMockInterview> {
            return localVarFp.listMockInterviewByPageUsingPOST(mockInterviewQueryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary listMyMockInterviewVOByPage
         * @param {MockInterviewQueryRequest} mockInterviewQueryRequest mockInterviewQueryRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMyMockInterviewVOByPageUsingPOST(mockInterviewQueryRequest: MockInterviewQueryRequest, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponsePageMockInterview> {
            return localVarFp.listMyMockInterviewVOByPageUsingPOST(mockInterviewQueryRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MockInterviewControllerApi - object-oriented interface
 */
export class MockInterviewControllerApi extends BaseAPI {
    /**
     * 
     * @summary addMockInterview
     * @param {MockInterviewAddRequest} mockInterviewAddRequest mockInterviewAddRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public addMockInterviewUsingPOST(mockInterviewAddRequest: MockInterviewAddRequest, options?: RawAxiosRequestConfig) {
        return MockInterviewControllerApiFp(this.configuration).addMockInterviewUsingPOST(mockInterviewAddRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary deleteMockInterview
     * @param {DeleteRequest} deleteRequest deleteRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteMockInterviewUsingPOST(deleteRequest: DeleteRequest, options?: RawAxiosRequestConfig) {
        return MockInterviewControllerApiFp(this.configuration).deleteMockInterviewUsingPOST(deleteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getMockInterviewById
     * @param {number} [id] id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getMockInterviewByIdUsingGET(id?: number, options?: RawAxiosRequestConfig) {
        return MockInterviewControllerApiFp(this.configuration).getMockInterviewByIdUsingGET(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary handleMockInterviewEvent
     * @param {MockInterviewEventRequest} mockInterviewEventRequest mockInterviewEventRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public handleMockInterviewEventUsingPOST(mockInterviewEventRequest: MockInterviewEventRequest, options?: RawAxiosRequestConfig) {
        return MockInterviewControllerApiFp(this.configuration).handleMockInterviewEventUsingPOST(mockInterviewEventRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary listMockInterviewByPage
     * @param {MockInterviewQueryRequest} mockInterviewQueryRequest mockInterviewQueryRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listMockInterviewByPageUsingPOST(mockInterviewQueryRequest: MockInterviewQueryRequest, options?: RawAxiosRequestConfig) {
        return MockInterviewControllerApiFp(this.configuration).listMockInterviewByPageUsingPOST(mockInterviewQueryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary listMyMockInterviewVOByPage
     * @param {MockInterviewQueryRequest} mockInterviewQueryRequest mockInterviewQueryRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listMyMockInterviewVOByPageUsingPOST(mockInterviewQueryRequest: MockInterviewQueryRequest, options?: RawAxiosRequestConfig) {
        return MockInterviewControllerApiFp(this.configuration).listMyMockInterviewVOByPageUsingPOST(mockInterviewQueryRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PostControllerApi - axios parameter creator
 */
export const PostControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary addPost
         * @param {PostAddRequest} postAddRequest postAddRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPostUsingPOST: async (postAddRequest: PostAddRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postAddRequest' is not null or undefined
            assertParamExists('addPostUsingPOST', 'postAddRequest', postAddRequest)
            const localVarPath = `/api/post/add`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postAddRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deletePost
         * @param {DeleteRequest} deleteRequest deleteRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePostUsingPOST: async (deleteRequest: DeleteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deleteRequest' is not null or undefined
            assertParamExists('deletePostUsingPOST', 'deleteRequest', deleteRequest)
            const localVarPath = `/api/post/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary editPost
         * @param {PostEditRequest} postEditRequest postEditRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editPostUsingPOST: async (postEditRequest: PostEditRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postEditRequest' is not null or undefined
            assertParamExists('editPostUsingPOST', 'postEditRequest', postEditRequest)
            const localVarPath = `/api/post/edit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postEditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getPostVOById
         * @param {number} [id] id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPostVOByIdUsingGET: async (id?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/post/get/vo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary listMyPostVOByPage
         * @param {PostQueryRequest} postQueryRequest postQueryRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMyPostVOByPageUsingPOST: async (postQueryRequest: PostQueryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postQueryRequest' is not null or undefined
            assertParamExists('listMyPostVOByPageUsingPOST', 'postQueryRequest', postQueryRequest)
            const localVarPath = `/api/post/my/list/page/vo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postQueryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary listPostVOByPage
         * @param {PostQueryRequest} postQueryRequest postQueryRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPostVOByPageUsingPOST: async (postQueryRequest: PostQueryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postQueryRequest' is not null or undefined
            assertParamExists('listPostVOByPageUsingPOST', 'postQueryRequest', postQueryRequest)
            const localVarPath = `/api/post/list/page/vo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postQueryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary searchPostVOByPage
         * @param {PostQueryRequest} postQueryRequest postQueryRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPostVOByPageUsingPOST: async (postQueryRequest: PostQueryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postQueryRequest' is not null or undefined
            assertParamExists('searchPostVOByPageUsingPOST', 'postQueryRequest', postQueryRequest)
            const localVarPath = `/api/post/search/page/vo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postQueryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updatePost
         * @param {PostUpdateRequest} postUpdateRequest postUpdateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePostUsingPOST: async (postUpdateRequest: PostUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postUpdateRequest' is not null or undefined
            assertParamExists('updatePostUsingPOST', 'postUpdateRequest', postUpdateRequest)
            const localVarPath = `/api/post/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PostControllerApi - functional programming interface
 */
export const PostControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PostControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary addPost
         * @param {PostAddRequest} postAddRequest postAddRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addPostUsingPOST(postAddRequest: PostAddRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponselong>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addPostUsingPOST(postAddRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PostControllerApi.addPostUsingPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary deletePost
         * @param {DeleteRequest} deleteRequest deleteRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePostUsingPOST(deleteRequest: DeleteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseboolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePostUsingPOST(deleteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PostControllerApi.deletePostUsingPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary editPost
         * @param {PostEditRequest} postEditRequest postEditRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editPostUsingPOST(postEditRequest: PostEditRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseboolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editPostUsingPOST(postEditRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PostControllerApi.editPostUsingPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary getPostVOById
         * @param {number} [id] id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPostVOByIdUsingGET(id?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponsePostVO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPostVOByIdUsingGET(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PostControllerApi.getPostVOByIdUsingGET']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary listMyPostVOByPage
         * @param {PostQueryRequest} postQueryRequest postQueryRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMyPostVOByPageUsingPOST(postQueryRequest: PostQueryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponsePagePostVO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMyPostVOByPageUsingPOST(postQueryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PostControllerApi.listMyPostVOByPageUsingPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary listPostVOByPage
         * @param {PostQueryRequest} postQueryRequest postQueryRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPostVOByPageUsingPOST(postQueryRequest: PostQueryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponsePagePostVO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPostVOByPageUsingPOST(postQueryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PostControllerApi.listPostVOByPageUsingPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary searchPostVOByPage
         * @param {PostQueryRequest} postQueryRequest postQueryRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchPostVOByPageUsingPOST(postQueryRequest: PostQueryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponsePagePostVO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchPostVOByPageUsingPOST(postQueryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PostControllerApi.searchPostVOByPageUsingPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary updatePost
         * @param {PostUpdateRequest} postUpdateRequest postUpdateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePostUsingPOST(postUpdateRequest: PostUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseboolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePostUsingPOST(postUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PostControllerApi.updatePostUsingPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PostControllerApi - factory interface
 */
export const PostControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PostControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary addPost
         * @param {PostAddRequest} postAddRequest postAddRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPostUsingPOST(postAddRequest: PostAddRequest, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponselong> {
            return localVarFp.addPostUsingPOST(postAddRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary deletePost
         * @param {DeleteRequest} deleteRequest deleteRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePostUsingPOST(deleteRequest: DeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponseboolean> {
            return localVarFp.deletePostUsingPOST(deleteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary editPost
         * @param {PostEditRequest} postEditRequest postEditRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editPostUsingPOST(postEditRequest: PostEditRequest, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponseboolean> {
            return localVarFp.editPostUsingPOST(postEditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getPostVOById
         * @param {number} [id] id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPostVOByIdUsingGET(id?: number, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponsePostVO> {
            return localVarFp.getPostVOByIdUsingGET(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary listMyPostVOByPage
         * @param {PostQueryRequest} postQueryRequest postQueryRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMyPostVOByPageUsingPOST(postQueryRequest: PostQueryRequest, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponsePagePostVO> {
            return localVarFp.listMyPostVOByPageUsingPOST(postQueryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary listPostVOByPage
         * @param {PostQueryRequest} postQueryRequest postQueryRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPostVOByPageUsingPOST(postQueryRequest: PostQueryRequest, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponsePagePostVO> {
            return localVarFp.listPostVOByPageUsingPOST(postQueryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary searchPostVOByPage
         * @param {PostQueryRequest} postQueryRequest postQueryRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPostVOByPageUsingPOST(postQueryRequest: PostQueryRequest, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponsePagePostVO> {
            return localVarFp.searchPostVOByPageUsingPOST(postQueryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary updatePost
         * @param {PostUpdateRequest} postUpdateRequest postUpdateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePostUsingPOST(postUpdateRequest: PostUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponseboolean> {
            return localVarFp.updatePostUsingPOST(postUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PostControllerApi - object-oriented interface
 */
export class PostControllerApi extends BaseAPI {
    /**
     * 
     * @summary addPost
     * @param {PostAddRequest} postAddRequest postAddRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public addPostUsingPOST(postAddRequest: PostAddRequest, options?: RawAxiosRequestConfig) {
        return PostControllerApiFp(this.configuration).addPostUsingPOST(postAddRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary deletePost
     * @param {DeleteRequest} deleteRequest deleteRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deletePostUsingPOST(deleteRequest: DeleteRequest, options?: RawAxiosRequestConfig) {
        return PostControllerApiFp(this.configuration).deletePostUsingPOST(deleteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary editPost
     * @param {PostEditRequest} postEditRequest postEditRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public editPostUsingPOST(postEditRequest: PostEditRequest, options?: RawAxiosRequestConfig) {
        return PostControllerApiFp(this.configuration).editPostUsingPOST(postEditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getPostVOById
     * @param {number} [id] id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPostVOByIdUsingGET(id?: number, options?: RawAxiosRequestConfig) {
        return PostControllerApiFp(this.configuration).getPostVOByIdUsingGET(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary listMyPostVOByPage
     * @param {PostQueryRequest} postQueryRequest postQueryRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listMyPostVOByPageUsingPOST(postQueryRequest: PostQueryRequest, options?: RawAxiosRequestConfig) {
        return PostControllerApiFp(this.configuration).listMyPostVOByPageUsingPOST(postQueryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary listPostVOByPage
     * @param {PostQueryRequest} postQueryRequest postQueryRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listPostVOByPageUsingPOST(postQueryRequest: PostQueryRequest, options?: RawAxiosRequestConfig) {
        return PostControllerApiFp(this.configuration).listPostVOByPageUsingPOST(postQueryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary searchPostVOByPage
     * @param {PostQueryRequest} postQueryRequest postQueryRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public searchPostVOByPageUsingPOST(postQueryRequest: PostQueryRequest, options?: RawAxiosRequestConfig) {
        return PostControllerApiFp(this.configuration).searchPostVOByPageUsingPOST(postQueryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary updatePost
     * @param {PostUpdateRequest} postUpdateRequest postUpdateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updatePostUsingPOST(postUpdateRequest: PostUpdateRequest, options?: RawAxiosRequestConfig) {
        return PostControllerApiFp(this.configuration).updatePostUsingPOST(postUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PostFavourControllerApi - axios parameter creator
 */
export const PostFavourControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary doPostFavour
         * @param {PostFavourAddRequest} postFavourAddRequest postFavourAddRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doPostFavourUsingPOST: async (postFavourAddRequest: PostFavourAddRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postFavourAddRequest' is not null or undefined
            assertParamExists('doPostFavourUsingPOST', 'postFavourAddRequest', postFavourAddRequest)
            const localVarPath = `/api/post_favour/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postFavourAddRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary listFavourPostByPage
         * @param {PostFavourQueryRequest} postFavourQueryRequest postFavourQueryRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFavourPostByPageUsingPOST: async (postFavourQueryRequest: PostFavourQueryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postFavourQueryRequest' is not null or undefined
            assertParamExists('listFavourPostByPageUsingPOST', 'postFavourQueryRequest', postFavourQueryRequest)
            const localVarPath = `/api/post_favour/list/page`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postFavourQueryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary listMyFavourPostByPage
         * @param {PostQueryRequest} postQueryRequest postQueryRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMyFavourPostByPageUsingPOST: async (postQueryRequest: PostQueryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postQueryRequest' is not null or undefined
            assertParamExists('listMyFavourPostByPageUsingPOST', 'postQueryRequest', postQueryRequest)
            const localVarPath = `/api/post_favour/my/list/page`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postQueryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PostFavourControllerApi - functional programming interface
 */
export const PostFavourControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PostFavourControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary doPostFavour
         * @param {PostFavourAddRequest} postFavourAddRequest postFavourAddRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async doPostFavourUsingPOST(postFavourAddRequest: PostFavourAddRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseint>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.doPostFavourUsingPOST(postFavourAddRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PostFavourControllerApi.doPostFavourUsingPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary listFavourPostByPage
         * @param {PostFavourQueryRequest} postFavourQueryRequest postFavourQueryRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFavourPostByPageUsingPOST(postFavourQueryRequest: PostFavourQueryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponsePagePostVO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFavourPostByPageUsingPOST(postFavourQueryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PostFavourControllerApi.listFavourPostByPageUsingPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary listMyFavourPostByPage
         * @param {PostQueryRequest} postQueryRequest postQueryRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMyFavourPostByPageUsingPOST(postQueryRequest: PostQueryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponsePagePostVO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMyFavourPostByPageUsingPOST(postQueryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PostFavourControllerApi.listMyFavourPostByPageUsingPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PostFavourControllerApi - factory interface
 */
export const PostFavourControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PostFavourControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary doPostFavour
         * @param {PostFavourAddRequest} postFavourAddRequest postFavourAddRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doPostFavourUsingPOST(postFavourAddRequest: PostFavourAddRequest, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponseint> {
            return localVarFp.doPostFavourUsingPOST(postFavourAddRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary listFavourPostByPage
         * @param {PostFavourQueryRequest} postFavourQueryRequest postFavourQueryRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFavourPostByPageUsingPOST(postFavourQueryRequest: PostFavourQueryRequest, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponsePagePostVO> {
            return localVarFp.listFavourPostByPageUsingPOST(postFavourQueryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary listMyFavourPostByPage
         * @param {PostQueryRequest} postQueryRequest postQueryRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMyFavourPostByPageUsingPOST(postQueryRequest: PostQueryRequest, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponsePagePostVO> {
            return localVarFp.listMyFavourPostByPageUsingPOST(postQueryRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PostFavourControllerApi - object-oriented interface
 */
export class PostFavourControllerApi extends BaseAPI {
    /**
     * 
     * @summary doPostFavour
     * @param {PostFavourAddRequest} postFavourAddRequest postFavourAddRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public doPostFavourUsingPOST(postFavourAddRequest: PostFavourAddRequest, options?: RawAxiosRequestConfig) {
        return PostFavourControllerApiFp(this.configuration).doPostFavourUsingPOST(postFavourAddRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary listFavourPostByPage
     * @param {PostFavourQueryRequest} postFavourQueryRequest postFavourQueryRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listFavourPostByPageUsingPOST(postFavourQueryRequest: PostFavourQueryRequest, options?: RawAxiosRequestConfig) {
        return PostFavourControllerApiFp(this.configuration).listFavourPostByPageUsingPOST(postFavourQueryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary listMyFavourPostByPage
     * @param {PostQueryRequest} postQueryRequest postQueryRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listMyFavourPostByPageUsingPOST(postQueryRequest: PostQueryRequest, options?: RawAxiosRequestConfig) {
        return PostFavourControllerApiFp(this.configuration).listMyFavourPostByPageUsingPOST(postQueryRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PostThumbControllerApi - axios parameter creator
 */
export const PostThumbControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary doThumb
         * @param {PostThumbAddRequest} postThumbAddRequest postThumbAddRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doThumbUsingPOST: async (postThumbAddRequest: PostThumbAddRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postThumbAddRequest' is not null or undefined
            assertParamExists('doThumbUsingPOST', 'postThumbAddRequest', postThumbAddRequest)
            const localVarPath = `/api/post_thumb/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postThumbAddRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PostThumbControllerApi - functional programming interface
 */
export const PostThumbControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PostThumbControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary doThumb
         * @param {PostThumbAddRequest} postThumbAddRequest postThumbAddRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async doThumbUsingPOST(postThumbAddRequest: PostThumbAddRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseint>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.doThumbUsingPOST(postThumbAddRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PostThumbControllerApi.doThumbUsingPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PostThumbControllerApi - factory interface
 */
export const PostThumbControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PostThumbControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary doThumb
         * @param {PostThumbAddRequest} postThumbAddRequest postThumbAddRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doThumbUsingPOST(postThumbAddRequest: PostThumbAddRequest, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponseint> {
            return localVarFp.doThumbUsingPOST(postThumbAddRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PostThumbControllerApi - object-oriented interface
 */
export class PostThumbControllerApi extends BaseAPI {
    /**
     * 
     * @summary doThumb
     * @param {PostThumbAddRequest} postThumbAddRequest postThumbAddRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public doThumbUsingPOST(postThumbAddRequest: PostThumbAddRequest, options?: RawAxiosRequestConfig) {
        return PostThumbControllerApiFp(this.configuration).doThumbUsingPOST(postThumbAddRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * QuestionCommentControllerApi - axios parameter creator
 */
export const QuestionCommentControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary addComment
         * @param {QuestionCommentAddRequest} questionCommentAddRequest questionCommentAddRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCommentUsingPOST: async (questionCommentAddRequest: QuestionCommentAddRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'questionCommentAddRequest' is not null or undefined
            assertParamExists('addCommentUsingPOST', 'questionCommentAddRequest', questionCommentAddRequest)
            const localVarPath = `/api/question_comment/add`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(questionCommentAddRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deleteComment
         * @param {DeleteRequest} deleteRequest deleteRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCommentUsingPOST: async (deleteRequest: DeleteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deleteRequest' is not null or undefined
            assertParamExists('deleteCommentUsingPOST', 'deleteRequest', deleteRequest)
            const localVarPath = `/api/question_comment/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary doThumb
         * @param {number} commentId commentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doThumbUsingPOST1: async (commentId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'commentId' is not null or undefined
            assertParamExists('doThumbUsingPOST1', 'commentId', commentId)
            const localVarPath = `/api/question_comment/thumb`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (commentId !== undefined) {
                localVarQueryParameter['commentId'] = commentId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getCommentList
         * @param {number} questionId questionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommentListUsingGET: async (questionId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'questionId' is not null or undefined
            assertParamExists('getCommentListUsingGET', 'questionId', questionId)
            const localVarPath = `/api/question_comment/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (questionId !== undefined) {
                localVarQueryParameter['questionId'] = questionId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QuestionCommentControllerApi - functional programming interface
 */
export const QuestionCommentControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QuestionCommentControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary addComment
         * @param {QuestionCommentAddRequest} questionCommentAddRequest questionCommentAddRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addCommentUsingPOST(questionCommentAddRequest: QuestionCommentAddRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponselong>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addCommentUsingPOST(questionCommentAddRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QuestionCommentControllerApi.addCommentUsingPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary deleteComment
         * @param {DeleteRequest} deleteRequest deleteRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCommentUsingPOST(deleteRequest: DeleteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseboolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCommentUsingPOST(deleteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QuestionCommentControllerApi.deleteCommentUsingPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary doThumb
         * @param {number} commentId commentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async doThumbUsingPOST1(commentId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseint>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.doThumbUsingPOST1(commentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QuestionCommentControllerApi.doThumbUsingPOST1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary getCommentList
         * @param {number} questionId questionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCommentListUsingGET(questionId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseListQuestionCommentVO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCommentListUsingGET(questionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QuestionCommentControllerApi.getCommentListUsingGET']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * QuestionCommentControllerApi - factory interface
 */
export const QuestionCommentControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QuestionCommentControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary addComment
         * @param {QuestionCommentAddRequest} questionCommentAddRequest questionCommentAddRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCommentUsingPOST(questionCommentAddRequest: QuestionCommentAddRequest, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponselong> {
            return localVarFp.addCommentUsingPOST(questionCommentAddRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary deleteComment
         * @param {DeleteRequest} deleteRequest deleteRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCommentUsingPOST(deleteRequest: DeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponseboolean> {
            return localVarFp.deleteCommentUsingPOST(deleteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary doThumb
         * @param {number} commentId commentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doThumbUsingPOST1(commentId: number, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponseint> {
            return localVarFp.doThumbUsingPOST1(commentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getCommentList
         * @param {number} questionId questionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommentListUsingGET(questionId: number, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponseListQuestionCommentVO> {
            return localVarFp.getCommentListUsingGET(questionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QuestionCommentControllerApi - object-oriented interface
 */
export class QuestionCommentControllerApi extends BaseAPI {
    /**
     * 
     * @summary addComment
     * @param {QuestionCommentAddRequest} questionCommentAddRequest questionCommentAddRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public addCommentUsingPOST(questionCommentAddRequest: QuestionCommentAddRequest, options?: RawAxiosRequestConfig) {
        return QuestionCommentControllerApiFp(this.configuration).addCommentUsingPOST(questionCommentAddRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary deleteComment
     * @param {DeleteRequest} deleteRequest deleteRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteCommentUsingPOST(deleteRequest: DeleteRequest, options?: RawAxiosRequestConfig) {
        return QuestionCommentControllerApiFp(this.configuration).deleteCommentUsingPOST(deleteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary doThumb
     * @param {number} commentId commentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public doThumbUsingPOST1(commentId: number, options?: RawAxiosRequestConfig) {
        return QuestionCommentControllerApiFp(this.configuration).doThumbUsingPOST1(commentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getCommentList
     * @param {number} questionId questionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCommentListUsingGET(questionId: number, options?: RawAxiosRequestConfig) {
        return QuestionCommentControllerApiFp(this.configuration).getCommentListUsingGET(questionId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * QuestionControllerApi - axios parameter creator
 */
export const QuestionControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary addQuestion
         * @param {QuestionAddRequest} questionAddRequest questionAddRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addQuestionUsingPOST: async (questionAddRequest: QuestionAddRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'questionAddRequest' is not null or undefined
            assertParamExists('addQuestionUsingPOST', 'questionAddRequest', questionAddRequest)
            const localVarPath = `/api/question/add`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(questionAddRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary aiGenerateQuestion
         * @param {QuestionAIGenerateRequest} questionAIGenerateRequest questionAIGenerateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiGenerateQuestionUsingPOST: async (questionAIGenerateRequest: QuestionAIGenerateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'questionAIGenerateRequest' is not null or undefined
            assertParamExists('aiGenerateQuestionUsingPOST', 'questionAIGenerateRequest', questionAIGenerateRequest)
            const localVarPath = `/api/question/ai/generate/question`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(questionAIGenerateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deleteQuestion
         * @param {DeleteRequest} deleteRequest deleteRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQuestionUsingPOST: async (deleteRequest: DeleteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deleteRequest' is not null or undefined
            assertParamExists('deleteQuestionUsingPOST', 'deleteRequest', deleteRequest)
            const localVarPath = `/api/question/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary doQuestionSubmit
         * @param {QuestionSubmitAddRequest} questionSubmitAddRequest questionSubmitAddRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doQuestionSubmitUsingPOST: async (questionSubmitAddRequest: QuestionSubmitAddRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'questionSubmitAddRequest' is not null or undefined
            assertParamExists('doQuestionSubmitUsingPOST', 'questionSubmitAddRequest', questionSubmitAddRequest)
            const localVarPath = `/api/question/question_submit/do`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(questionSubmitAddRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary editQuestion
         * @param {QuestionEditRequest} questionEditRequest questionEditRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editQuestionUsingPOST: async (questionEditRequest: QuestionEditRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'questionEditRequest' is not null or undefined
            assertParamExists('editQuestionUsingPOST', 'questionEditRequest', questionEditRequest)
            const localVarPath = `/api/question/edit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(questionEditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getQuestionById
         * @param {number} [id] id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuestionByIdUsingGET: async (id?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/question/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getQuestionVOById
         * @param {number} [id] id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuestionVOByIdUsingGET: async (id?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/question/get/vo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary listMyQuestionVOByPage
         * @param {QuestionQueryRequest} questionQueryRequest questionQueryRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMyQuestionVOByPageUsingPOST: async (questionQueryRequest: QuestionQueryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'questionQueryRequest' is not null or undefined
            assertParamExists('listMyQuestionVOByPageUsingPOST', 'questionQueryRequest', questionQueryRequest)
            const localVarPath = `/api/question/my/list/page/vo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(questionQueryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary listQuestionByPage
         * @param {QuestionQueryRequest} questionQueryRequest questionQueryRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQuestionByPageUsingPOST: async (questionQueryRequest: QuestionQueryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'questionQueryRequest' is not null or undefined
            assertParamExists('listQuestionByPageUsingPOST', 'questionQueryRequest', questionQueryRequest)
            const localVarPath = `/api/question/list/page`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(questionQueryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary listQuestionSubmitByPage
         * @param {QuestionSubmitQueryRequest} questionSubmitQueryRequest questionSubmitQueryRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQuestionSubmitByPageUsingPOST: async (questionSubmitQueryRequest: QuestionSubmitQueryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'questionSubmitQueryRequest' is not null or undefined
            assertParamExists('listQuestionSubmitByPageUsingPOST', 'questionSubmitQueryRequest', questionSubmitQueryRequest)
            const localVarPath = `/api/question/question_submit/list/page`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(questionSubmitQueryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary listQuestionVOByPage
         * @param {QuestionQueryRequest} questionQueryRequest questionQueryRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQuestionVOByPageUsingPOST: async (questionQueryRequest: QuestionQueryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'questionQueryRequest' is not null or undefined
            assertParamExists('listQuestionVOByPageUsingPOST', 'questionQueryRequest', questionQueryRequest)
            const localVarPath = `/api/question/list/page/vo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(questionQueryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updateQuestion
         * @param {QuestionUpdateRequest} questionUpdateRequest questionUpdateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateQuestionUsingPOST: async (questionUpdateRequest: QuestionUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'questionUpdateRequest' is not null or undefined
            assertParamExists('updateQuestionUsingPOST', 'questionUpdateRequest', questionUpdateRequest)
            const localVarPath = `/api/question/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(questionUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QuestionControllerApi - functional programming interface
 */
export const QuestionControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QuestionControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary addQuestion
         * @param {QuestionAddRequest} questionAddRequest questionAddRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addQuestionUsingPOST(questionAddRequest: QuestionAddRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponselong>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addQuestionUsingPOST(questionAddRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QuestionControllerApi.addQuestionUsingPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary aiGenerateQuestion
         * @param {QuestionAIGenerateRequest} questionAIGenerateRequest questionAIGenerateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aiGenerateQuestionUsingPOST(questionAIGenerateRequest: QuestionAIGenerateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseboolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aiGenerateQuestionUsingPOST(questionAIGenerateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QuestionControllerApi.aiGenerateQuestionUsingPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary deleteQuestion
         * @param {DeleteRequest} deleteRequest deleteRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteQuestionUsingPOST(deleteRequest: DeleteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseboolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteQuestionUsingPOST(deleteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QuestionControllerApi.deleteQuestionUsingPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary doQuestionSubmit
         * @param {QuestionSubmitAddRequest} questionSubmitAddRequest questionSubmitAddRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async doQuestionSubmitUsingPOST(questionSubmitAddRequest: QuestionSubmitAddRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponselong>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.doQuestionSubmitUsingPOST(questionSubmitAddRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QuestionControllerApi.doQuestionSubmitUsingPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary editQuestion
         * @param {QuestionEditRequest} questionEditRequest questionEditRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editQuestionUsingPOST(questionEditRequest: QuestionEditRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseboolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editQuestionUsingPOST(questionEditRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QuestionControllerApi.editQuestionUsingPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary getQuestionById
         * @param {number} [id] id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQuestionByIdUsingGET(id?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseQuestion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getQuestionByIdUsingGET(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QuestionControllerApi.getQuestionByIdUsingGET']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary getQuestionVOById
         * @param {number} [id] id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQuestionVOByIdUsingGET(id?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseQuestionVO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getQuestionVOByIdUsingGET(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QuestionControllerApi.getQuestionVOByIdUsingGET']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary listMyQuestionVOByPage
         * @param {QuestionQueryRequest} questionQueryRequest questionQueryRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMyQuestionVOByPageUsingPOST(questionQueryRequest: QuestionQueryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponsePageQuestionVO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMyQuestionVOByPageUsingPOST(questionQueryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QuestionControllerApi.listMyQuestionVOByPageUsingPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary listQuestionByPage
         * @param {QuestionQueryRequest} questionQueryRequest questionQueryRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listQuestionByPageUsingPOST(questionQueryRequest: QuestionQueryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponsePageQuestion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listQuestionByPageUsingPOST(questionQueryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QuestionControllerApi.listQuestionByPageUsingPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary listQuestionSubmitByPage
         * @param {QuestionSubmitQueryRequest} questionSubmitQueryRequest questionSubmitQueryRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listQuestionSubmitByPageUsingPOST(questionSubmitQueryRequest: QuestionSubmitQueryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponsePageQuestionSubmitVO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listQuestionSubmitByPageUsingPOST(questionSubmitQueryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QuestionControllerApi.listQuestionSubmitByPageUsingPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary listQuestionVOByPage
         * @param {QuestionQueryRequest} questionQueryRequest questionQueryRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listQuestionVOByPageUsingPOST(questionQueryRequest: QuestionQueryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponsePageQuestionVO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listQuestionVOByPageUsingPOST(questionQueryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QuestionControllerApi.listQuestionVOByPageUsingPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary updateQuestion
         * @param {QuestionUpdateRequest} questionUpdateRequest questionUpdateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateQuestionUsingPOST(questionUpdateRequest: QuestionUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseboolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateQuestionUsingPOST(questionUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QuestionControllerApi.updateQuestionUsingPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * QuestionControllerApi - factory interface
 */
export const QuestionControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QuestionControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary addQuestion
         * @param {QuestionAddRequest} questionAddRequest questionAddRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addQuestionUsingPOST(questionAddRequest: QuestionAddRequest, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponselong> {
            return localVarFp.addQuestionUsingPOST(questionAddRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary aiGenerateQuestion
         * @param {QuestionAIGenerateRequest} questionAIGenerateRequest questionAIGenerateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiGenerateQuestionUsingPOST(questionAIGenerateRequest: QuestionAIGenerateRequest, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponseboolean> {
            return localVarFp.aiGenerateQuestionUsingPOST(questionAIGenerateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary deleteQuestion
         * @param {DeleteRequest} deleteRequest deleteRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQuestionUsingPOST(deleteRequest: DeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponseboolean> {
            return localVarFp.deleteQuestionUsingPOST(deleteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary doQuestionSubmit
         * @param {QuestionSubmitAddRequest} questionSubmitAddRequest questionSubmitAddRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doQuestionSubmitUsingPOST(questionSubmitAddRequest: QuestionSubmitAddRequest, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponselong> {
            return localVarFp.doQuestionSubmitUsingPOST(questionSubmitAddRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary editQuestion
         * @param {QuestionEditRequest} questionEditRequest questionEditRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editQuestionUsingPOST(questionEditRequest: QuestionEditRequest, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponseboolean> {
            return localVarFp.editQuestionUsingPOST(questionEditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getQuestionById
         * @param {number} [id] id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuestionByIdUsingGET(id?: number, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponseQuestion> {
            return localVarFp.getQuestionByIdUsingGET(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getQuestionVOById
         * @param {number} [id] id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuestionVOByIdUsingGET(id?: number, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponseQuestionVO> {
            return localVarFp.getQuestionVOByIdUsingGET(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary listMyQuestionVOByPage
         * @param {QuestionQueryRequest} questionQueryRequest questionQueryRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMyQuestionVOByPageUsingPOST(questionQueryRequest: QuestionQueryRequest, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponsePageQuestionVO> {
            return localVarFp.listMyQuestionVOByPageUsingPOST(questionQueryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary listQuestionByPage
         * @param {QuestionQueryRequest} questionQueryRequest questionQueryRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQuestionByPageUsingPOST(questionQueryRequest: QuestionQueryRequest, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponsePageQuestion> {
            return localVarFp.listQuestionByPageUsingPOST(questionQueryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary listQuestionSubmitByPage
         * @param {QuestionSubmitQueryRequest} questionSubmitQueryRequest questionSubmitQueryRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQuestionSubmitByPageUsingPOST(questionSubmitQueryRequest: QuestionSubmitQueryRequest, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponsePageQuestionSubmitVO> {
            return localVarFp.listQuestionSubmitByPageUsingPOST(questionSubmitQueryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary listQuestionVOByPage
         * @param {QuestionQueryRequest} questionQueryRequest questionQueryRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQuestionVOByPageUsingPOST(questionQueryRequest: QuestionQueryRequest, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponsePageQuestionVO> {
            return localVarFp.listQuestionVOByPageUsingPOST(questionQueryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary updateQuestion
         * @param {QuestionUpdateRequest} questionUpdateRequest questionUpdateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateQuestionUsingPOST(questionUpdateRequest: QuestionUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponseboolean> {
            return localVarFp.updateQuestionUsingPOST(questionUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QuestionControllerApi - object-oriented interface
 */
export class QuestionControllerApi extends BaseAPI {
    /**
     * 
     * @summary addQuestion
     * @param {QuestionAddRequest} questionAddRequest questionAddRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public addQuestionUsingPOST(questionAddRequest: QuestionAddRequest, options?: RawAxiosRequestConfig) {
        return QuestionControllerApiFp(this.configuration).addQuestionUsingPOST(questionAddRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary aiGenerateQuestion
     * @param {QuestionAIGenerateRequest} questionAIGenerateRequest questionAIGenerateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public aiGenerateQuestionUsingPOST(questionAIGenerateRequest: QuestionAIGenerateRequest, options?: RawAxiosRequestConfig) {
        return QuestionControllerApiFp(this.configuration).aiGenerateQuestionUsingPOST(questionAIGenerateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary deleteQuestion
     * @param {DeleteRequest} deleteRequest deleteRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteQuestionUsingPOST(deleteRequest: DeleteRequest, options?: RawAxiosRequestConfig) {
        return QuestionControllerApiFp(this.configuration).deleteQuestionUsingPOST(deleteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary doQuestionSubmit
     * @param {QuestionSubmitAddRequest} questionSubmitAddRequest questionSubmitAddRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public doQuestionSubmitUsingPOST(questionSubmitAddRequest: QuestionSubmitAddRequest, options?: RawAxiosRequestConfig) {
        return QuestionControllerApiFp(this.configuration).doQuestionSubmitUsingPOST(questionSubmitAddRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary editQuestion
     * @param {QuestionEditRequest} questionEditRequest questionEditRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public editQuestionUsingPOST(questionEditRequest: QuestionEditRequest, options?: RawAxiosRequestConfig) {
        return QuestionControllerApiFp(this.configuration).editQuestionUsingPOST(questionEditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getQuestionById
     * @param {number} [id] id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getQuestionByIdUsingGET(id?: number, options?: RawAxiosRequestConfig) {
        return QuestionControllerApiFp(this.configuration).getQuestionByIdUsingGET(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getQuestionVOById
     * @param {number} [id] id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getQuestionVOByIdUsingGET(id?: number, options?: RawAxiosRequestConfig) {
        return QuestionControllerApiFp(this.configuration).getQuestionVOByIdUsingGET(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary listMyQuestionVOByPage
     * @param {QuestionQueryRequest} questionQueryRequest questionQueryRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listMyQuestionVOByPageUsingPOST(questionQueryRequest: QuestionQueryRequest, options?: RawAxiosRequestConfig) {
        return QuestionControllerApiFp(this.configuration).listMyQuestionVOByPageUsingPOST(questionQueryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary listQuestionByPage
     * @param {QuestionQueryRequest} questionQueryRequest questionQueryRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listQuestionByPageUsingPOST(questionQueryRequest: QuestionQueryRequest, options?: RawAxiosRequestConfig) {
        return QuestionControllerApiFp(this.configuration).listQuestionByPageUsingPOST(questionQueryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary listQuestionSubmitByPage
     * @param {QuestionSubmitQueryRequest} questionSubmitQueryRequest questionSubmitQueryRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listQuestionSubmitByPageUsingPOST(questionSubmitQueryRequest: QuestionSubmitQueryRequest, options?: RawAxiosRequestConfig) {
        return QuestionControllerApiFp(this.configuration).listQuestionSubmitByPageUsingPOST(questionSubmitQueryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary listQuestionVOByPage
     * @param {QuestionQueryRequest} questionQueryRequest questionQueryRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listQuestionVOByPageUsingPOST(questionQueryRequest: QuestionQueryRequest, options?: RawAxiosRequestConfig) {
        return QuestionControllerApiFp(this.configuration).listQuestionVOByPageUsingPOST(questionQueryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary updateQuestion
     * @param {QuestionUpdateRequest} questionUpdateRequest questionUpdateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateQuestionUsingPOST(questionUpdateRequest: QuestionUpdateRequest, options?: RawAxiosRequestConfig) {
        return QuestionControllerApiFp(this.configuration).updateQuestionUsingPOST(questionUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * QuestionFavourControllerApi - axios parameter creator
 */
export const QuestionFavourControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary doQuestionFavour
         * @param {QuestionFavourAddRequest} questionFavourAddRequest questionFavourAddRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doQuestionFavourUsingPOST: async (questionFavourAddRequest: QuestionFavourAddRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'questionFavourAddRequest' is not null or undefined
            assertParamExists('doQuestionFavourUsingPOST', 'questionFavourAddRequest', questionFavourAddRequest)
            const localVarPath = `/api/question_favour/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(questionFavourAddRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary listMyFavourQuestionByPage
         * @param {QuestionQueryRequest} questionQueryRequest questionQueryRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMyFavourQuestionByPageUsingPOST: async (questionQueryRequest: QuestionQueryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'questionQueryRequest' is not null or undefined
            assertParamExists('listMyFavourQuestionByPageUsingPOST', 'questionQueryRequest', questionQueryRequest)
            const localVarPath = `/api/question_favour/my/list/page`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(questionQueryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QuestionFavourControllerApi - functional programming interface
 */
export const QuestionFavourControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QuestionFavourControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary doQuestionFavour
         * @param {QuestionFavourAddRequest} questionFavourAddRequest questionFavourAddRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async doQuestionFavourUsingPOST(questionFavourAddRequest: QuestionFavourAddRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseint>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.doQuestionFavourUsingPOST(questionFavourAddRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QuestionFavourControllerApi.doQuestionFavourUsingPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary listMyFavourQuestionByPage
         * @param {QuestionQueryRequest} questionQueryRequest questionQueryRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMyFavourQuestionByPageUsingPOST(questionQueryRequest: QuestionQueryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponsePageQuestionVO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMyFavourQuestionByPageUsingPOST(questionQueryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QuestionFavourControllerApi.listMyFavourQuestionByPageUsingPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * QuestionFavourControllerApi - factory interface
 */
export const QuestionFavourControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QuestionFavourControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary doQuestionFavour
         * @param {QuestionFavourAddRequest} questionFavourAddRequest questionFavourAddRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doQuestionFavourUsingPOST(questionFavourAddRequest: QuestionFavourAddRequest, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponseint> {
            return localVarFp.doQuestionFavourUsingPOST(questionFavourAddRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary listMyFavourQuestionByPage
         * @param {QuestionQueryRequest} questionQueryRequest questionQueryRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMyFavourQuestionByPageUsingPOST(questionQueryRequest: QuestionQueryRequest, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponsePageQuestionVO> {
            return localVarFp.listMyFavourQuestionByPageUsingPOST(questionQueryRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QuestionFavourControllerApi - object-oriented interface
 */
export class QuestionFavourControllerApi extends BaseAPI {
    /**
     * 
     * @summary doQuestionFavour
     * @param {QuestionFavourAddRequest} questionFavourAddRequest questionFavourAddRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public doQuestionFavourUsingPOST(questionFavourAddRequest: QuestionFavourAddRequest, options?: RawAxiosRequestConfig) {
        return QuestionFavourControllerApiFp(this.configuration).doQuestionFavourUsingPOST(questionFavourAddRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary listMyFavourQuestionByPage
     * @param {QuestionQueryRequest} questionQueryRequest questionQueryRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listMyFavourQuestionByPageUsingPOST(questionQueryRequest: QuestionQueryRequest, options?: RawAxiosRequestConfig) {
        return QuestionFavourControllerApiFp(this.configuration).listMyFavourQuestionByPageUsingPOST(questionQueryRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserControllerApi - axios parameter creator
 */
export const UserControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary addUser
         * @param {UserAddRequest} userAddRequest userAddRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserUsingPOST: async (userAddRequest: UserAddRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userAddRequest' is not null or undefined
            assertParamExists('addUserUsingPOST', 'userAddRequest', userAddRequest)
            const localVarPath = `/api/user/add`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userAddRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deleteUser
         * @param {DeleteRequest} deleteRequest deleteRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserUsingPOST: async (deleteRequest: DeleteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deleteRequest' is not null or undefined
            assertParamExists('deleteUserUsingPOST', 'deleteRequest', deleteRequest)
            const localVarPath = `/api/user/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getLoginUser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoginUserUsingGET: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/get/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getUserById
         * @param {number} [id] id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByIdUsingGET: async (id?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getUserVOById
         * @param {number} [id] id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserVOByIdUsingGET: async (id?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/get/vo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary listUserByPage
         * @param {UserQueryRequest} userQueryRequest userQueryRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserByPageUsingPOST: async (userQueryRequest: UserQueryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userQueryRequest' is not null or undefined
            assertParamExists('listUserByPageUsingPOST', 'userQueryRequest', userQueryRequest)
            const localVarPath = `/api/user/list/page`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userQueryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary listUserVOByPage
         * @param {UserQueryRequest} userQueryRequest userQueryRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserVOByPageUsingPOST: async (userQueryRequest: UserQueryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userQueryRequest' is not null or undefined
            assertParamExists('listUserVOByPageUsingPOST', 'userQueryRequest', userQueryRequest)
            const localVarPath = `/api/user/list/page/vo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userQueryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updateMyUser
         * @param {UserUpdateMyRequest} userUpdateMyRequest userUpdateMyRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMyUserUsingPOST: async (userUpdateMyRequest: UserUpdateMyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userUpdateMyRequest' is not null or undefined
            assertParamExists('updateMyUserUsingPOST', 'userUpdateMyRequest', userUpdateMyRequest)
            const localVarPath = `/api/user/update/my`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userUpdateMyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updateUser
         * @param {UserUpdateRequest} userUpdateRequest userUpdateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserUsingPOST: async (userUpdateRequest: UserUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userUpdateRequest' is not null or undefined
            assertParamExists('updateUserUsingPOST', 'userUpdateRequest', userUpdateRequest)
            const localVarPath = `/api/user/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary userLoginByWxOpen
         * @param {string} code code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLoginByWxOpenUsingGET: async (code: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('userLoginByWxOpenUsingGET', 'code', code)
            const localVarPath = `/api/user/login/wx_open`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary userLogin
         * @param {UserLoginRequest} userLoginRequest userLoginRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLoginUsingPOST: async (userLoginRequest: UserLoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userLoginRequest' is not null or undefined
            assertParamExists('userLoginUsingPOST', 'userLoginRequest', userLoginRequest)
            const localVarPath = `/api/user/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userLoginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary userLogout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLogoutUsingPOST: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary userRegister
         * @param {UserRegisterRequest} userRegisterRequest userRegisterRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRegisterUsingPOST: async (userRegisterRequest: UserRegisterRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userRegisterRequest' is not null or undefined
            assertParamExists('userRegisterUsingPOST', 'userRegisterRequest', userRegisterRequest)
            const localVarPath = `/api/user/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userRegisterRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserControllerApi - functional programming interface
 */
export const UserControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary addUser
         * @param {UserAddRequest} userAddRequest userAddRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addUserUsingPOST(userAddRequest: UserAddRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponselong>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addUserUsingPOST(userAddRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserControllerApi.addUserUsingPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary deleteUser
         * @param {DeleteRequest} deleteRequest deleteRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserUsingPOST(deleteRequest: DeleteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseboolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserUsingPOST(deleteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserControllerApi.deleteUserUsingPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary getLoginUser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLoginUserUsingGET(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseLoginUserVO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLoginUserUsingGET(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserControllerApi.getLoginUserUsingGET']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary getUserById
         * @param {number} [id] id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserByIdUsingGET(id?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserByIdUsingGET(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserControllerApi.getUserByIdUsingGET']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary getUserVOById
         * @param {number} [id] id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserVOByIdUsingGET(id?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseUserVO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserVOByIdUsingGET(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserControllerApi.getUserVOByIdUsingGET']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary listUserByPage
         * @param {UserQueryRequest} userQueryRequest userQueryRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserByPageUsingPOST(userQueryRequest: UserQueryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponsePageUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUserByPageUsingPOST(userQueryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserControllerApi.listUserByPageUsingPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary listUserVOByPage
         * @param {UserQueryRequest} userQueryRequest userQueryRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserVOByPageUsingPOST(userQueryRequest: UserQueryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponsePageUserVO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUserVOByPageUsingPOST(userQueryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserControllerApi.listUserVOByPageUsingPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary updateMyUser
         * @param {UserUpdateMyRequest} userUpdateMyRequest userUpdateMyRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMyUserUsingPOST(userUpdateMyRequest: UserUpdateMyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseboolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMyUserUsingPOST(userUpdateMyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserControllerApi.updateMyUserUsingPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary updateUser
         * @param {UserUpdateRequest} userUpdateRequest userUpdateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserUsingPOST(userUpdateRequest: UserUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseboolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserUsingPOST(userUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserControllerApi.updateUserUsingPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary userLoginByWxOpen
         * @param {string} code code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userLoginByWxOpenUsingGET(code: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseLoginUserVO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userLoginByWxOpenUsingGET(code, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserControllerApi.userLoginByWxOpenUsingGET']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary userLogin
         * @param {UserLoginRequest} userLoginRequest userLoginRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userLoginUsingPOST(userLoginRequest: UserLoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseLoginUserVO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userLoginUsingPOST(userLoginRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserControllerApi.userLoginUsingPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary userLogout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userLogoutUsingPOST(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseboolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userLogoutUsingPOST(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserControllerApi.userLogoutUsingPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary userRegister
         * @param {UserRegisterRequest} userRegisterRequest userRegisterRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userRegisterUsingPOST(userRegisterRequest: UserRegisterRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponselong>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userRegisterUsingPOST(userRegisterRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserControllerApi.userRegisterUsingPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserControllerApi - factory interface
 */
export const UserControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary addUser
         * @param {UserAddRequest} userAddRequest userAddRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserUsingPOST(userAddRequest: UserAddRequest, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponselong> {
            return localVarFp.addUserUsingPOST(userAddRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary deleteUser
         * @param {DeleteRequest} deleteRequest deleteRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserUsingPOST(deleteRequest: DeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponseboolean> {
            return localVarFp.deleteUserUsingPOST(deleteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getLoginUser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoginUserUsingGET(options?: RawAxiosRequestConfig): AxiosPromise<BaseResponseLoginUserVO> {
            return localVarFp.getLoginUserUsingGET(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getUserById
         * @param {number} [id] id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByIdUsingGET(id?: number, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponseUser> {
            return localVarFp.getUserByIdUsingGET(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getUserVOById
         * @param {number} [id] id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserVOByIdUsingGET(id?: number, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponseUserVO> {
            return localVarFp.getUserVOByIdUsingGET(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary listUserByPage
         * @param {UserQueryRequest} userQueryRequest userQueryRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserByPageUsingPOST(userQueryRequest: UserQueryRequest, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponsePageUser> {
            return localVarFp.listUserByPageUsingPOST(userQueryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary listUserVOByPage
         * @param {UserQueryRequest} userQueryRequest userQueryRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserVOByPageUsingPOST(userQueryRequest: UserQueryRequest, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponsePageUserVO> {
            return localVarFp.listUserVOByPageUsingPOST(userQueryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary updateMyUser
         * @param {UserUpdateMyRequest} userUpdateMyRequest userUpdateMyRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMyUserUsingPOST(userUpdateMyRequest: UserUpdateMyRequest, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponseboolean> {
            return localVarFp.updateMyUserUsingPOST(userUpdateMyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary updateUser
         * @param {UserUpdateRequest} userUpdateRequest userUpdateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserUsingPOST(userUpdateRequest: UserUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponseboolean> {
            return localVarFp.updateUserUsingPOST(userUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary userLoginByWxOpen
         * @param {string} code code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLoginByWxOpenUsingGET(code: string, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponseLoginUserVO> {
            return localVarFp.userLoginByWxOpenUsingGET(code, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary userLogin
         * @param {UserLoginRequest} userLoginRequest userLoginRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLoginUsingPOST(userLoginRequest: UserLoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponseLoginUserVO> {
            return localVarFp.userLoginUsingPOST(userLoginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary userLogout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLogoutUsingPOST(options?: RawAxiosRequestConfig): AxiosPromise<BaseResponseboolean> {
            return localVarFp.userLogoutUsingPOST(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary userRegister
         * @param {UserRegisterRequest} userRegisterRequest userRegisterRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRegisterUsingPOST(userRegisterRequest: UserRegisterRequest, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponselong> {
            return localVarFp.userRegisterUsingPOST(userRegisterRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserControllerApi - object-oriented interface
 */
export class UserControllerApi extends BaseAPI {
    /**
     * 
     * @summary addUser
     * @param {UserAddRequest} userAddRequest userAddRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public addUserUsingPOST(userAddRequest: UserAddRequest, options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).addUserUsingPOST(userAddRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary deleteUser
     * @param {DeleteRequest} deleteRequest deleteRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteUserUsingPOST(deleteRequest: DeleteRequest, options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).deleteUserUsingPOST(deleteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getLoginUser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getLoginUserUsingGET(options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).getLoginUserUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getUserById
     * @param {number} [id] id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUserByIdUsingGET(id?: number, options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).getUserByIdUsingGET(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getUserVOById
     * @param {number} [id] id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUserVOByIdUsingGET(id?: number, options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).getUserVOByIdUsingGET(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary listUserByPage
     * @param {UserQueryRequest} userQueryRequest userQueryRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listUserByPageUsingPOST(userQueryRequest: UserQueryRequest, options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).listUserByPageUsingPOST(userQueryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary listUserVOByPage
     * @param {UserQueryRequest} userQueryRequest userQueryRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listUserVOByPageUsingPOST(userQueryRequest: UserQueryRequest, options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).listUserVOByPageUsingPOST(userQueryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary updateMyUser
     * @param {UserUpdateMyRequest} userUpdateMyRequest userUpdateMyRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateMyUserUsingPOST(userUpdateMyRequest: UserUpdateMyRequest, options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).updateMyUserUsingPOST(userUpdateMyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary updateUser
     * @param {UserUpdateRequest} userUpdateRequest userUpdateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateUserUsingPOST(userUpdateRequest: UserUpdateRequest, options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).updateUserUsingPOST(userUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary userLoginByWxOpen
     * @param {string} code code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public userLoginByWxOpenUsingGET(code: string, options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).userLoginByWxOpenUsingGET(code, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary userLogin
     * @param {UserLoginRequest} userLoginRequest userLoginRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public userLoginUsingPOST(userLoginRequest: UserLoginRequest, options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).userLoginUsingPOST(userLoginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary userLogout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public userLogoutUsingPOST(options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).userLogoutUsingPOST(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary userRegister
     * @param {UserRegisterRequest} userRegisterRequest userRegisterRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public userRegisterUsingPOST(userRegisterRequest: UserRegisterRequest, options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).userRegisterUsingPOST(userRegisterRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WxMpControllerApi - axios parameter creator
 */
export const WxMpControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary check
         * @param {string} [echostr] echostr
         * @param {string} [nonce] nonce
         * @param {string} [signature] signature
         * @param {string} [timestamp] timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkUsingGET: async (echostr?: string, nonce?: string, signature?: string, timestamp?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (echostr !== undefined) {
                localVarQueryParameter['echostr'] = echostr;
            }

            if (nonce !== undefined) {
                localVarQueryParameter['nonce'] = nonce;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary receiveMessage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        receiveMessageUsingPOST: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary setMenu
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMenuUsingGET: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/setMenu`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WxMpControllerApi - functional programming interface
 */
export const WxMpControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WxMpControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary check
         * @param {string} [echostr] echostr
         * @param {string} [nonce] nonce
         * @param {string} [signature] signature
         * @param {string} [timestamp] timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkUsingGET(echostr?: string, nonce?: string, signature?: string, timestamp?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkUsingGET(echostr, nonce, signature, timestamp, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WxMpControllerApi.checkUsingGET']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary receiveMessage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async receiveMessageUsingPOST(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.receiveMessageUsingPOST(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WxMpControllerApi.receiveMessageUsingPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary setMenu
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setMenuUsingGET(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setMenuUsingGET(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WxMpControllerApi.setMenuUsingGET']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WxMpControllerApi - factory interface
 */
export const WxMpControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WxMpControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary check
         * @param {string} [echostr] echostr
         * @param {string} [nonce] nonce
         * @param {string} [signature] signature
         * @param {string} [timestamp] timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkUsingGET(echostr?: string, nonce?: string, signature?: string, timestamp?: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.checkUsingGET(echostr, nonce, signature, timestamp, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary receiveMessage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        receiveMessageUsingPOST(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.receiveMessageUsingPOST(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary setMenu
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMenuUsingGET(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.setMenuUsingGET(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WxMpControllerApi - object-oriented interface
 */
export class WxMpControllerApi extends BaseAPI {
    /**
     * 
     * @summary check
     * @param {string} [echostr] echostr
     * @param {string} [nonce] nonce
     * @param {string} [signature] signature
     * @param {string} [timestamp] timestamp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public checkUsingGET(echostr?: string, nonce?: string, signature?: string, timestamp?: string, options?: RawAxiosRequestConfig) {
        return WxMpControllerApiFp(this.configuration).checkUsingGET(echostr, nonce, signature, timestamp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary receiveMessage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public receiveMessageUsingPOST(options?: RawAxiosRequestConfig) {
        return WxMpControllerApiFp(this.configuration).receiveMessageUsingPOST(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary setMenu
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public setMenuUsingGET(options?: RawAxiosRequestConfig) {
        return WxMpControllerApiFp(this.configuration).setMenuUsingGET(options).then((request) => request(this.axios, this.basePath));
    }
}




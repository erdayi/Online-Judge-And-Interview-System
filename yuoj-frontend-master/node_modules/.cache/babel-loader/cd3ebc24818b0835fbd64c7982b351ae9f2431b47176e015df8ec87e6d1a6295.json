{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport Axis2D from '../coord/cartesian/Axis2D.js';\nimport { makeInner } from './model.js';\nexport function needFixJitter(seriesModel, axis) {\n  var coordinateSystem = seriesModel.coordinateSystem;\n  var coordType = coordinateSystem && coordinateSystem.type;\n  var baseAxis = coordinateSystem && coordinateSystem.getBaseAxis && coordinateSystem.getBaseAxis();\n  var scaleType = baseAxis && baseAxis.scale && baseAxis.scale.type;\n  var seriesValid = coordType === 'cartesian2d' && scaleType === 'ordinal' || coordType === 'single';\n  var axisValid = axis.model.get('jitter') > 0;\n  return seriesValid && axisValid;\n}\nvar inner = makeInner();\n/**\n * Fix jitter for overlapping data points.\n *\n * @param fixedAxis The axis whose coord doesn't change with jitter.\n * @param fixedCoord The coord of fixedAxis.\n * @param floatCoord The coord of the other axis, which should be changed with jittering.\n * @param radius The radius of the data point, considering the symbol is a circle.\n * @returns updated floatCoord.\n */\nexport function fixJitter(fixedAxis, fixedCoord, floatCoord, radius) {\n  if (fixedAxis instanceof Axis2D) {\n    var scaleType = fixedAxis.scale.type;\n    if (scaleType !== 'category' && scaleType !== 'ordinal') {\n      return floatCoord;\n    }\n  }\n  var axisModel = fixedAxis.model;\n  var jitter = axisModel.get('jitter');\n  var jitterOverlap = axisModel.get('jitterOverlap');\n  var jitterMargin = axisModel.get('jitterMargin') || 0;\n  // Get band width to limit jitter range\n  var bandWidth = fixedAxis.scale.type === 'ordinal' ? fixedAxis.getBandWidth() : null;\n  if (jitter > 0) {\n    if (jitterOverlap) {\n      return fixJitterIgnoreOverlaps(floatCoord, jitter, bandWidth, radius);\n    } else {\n      return fixJitterAvoidOverlaps(fixedAxis, fixedCoord, floatCoord, radius, jitter, jitterMargin);\n    }\n  }\n  return floatCoord;\n}\nfunction fixJitterIgnoreOverlaps(floatCoord, jitter, bandWidth, radius) {\n  // Don't clamp single axis\n  if (bandWidth === null) {\n    return floatCoord + (Math.random() - 0.5) * jitter;\n  }\n  var maxJitter = bandWidth - radius * 2;\n  var actualJitter = Math.min(Math.max(0, jitter), maxJitter);\n  return floatCoord + (Math.random() - 0.5) * actualJitter;\n}\nfunction fixJitterAvoidOverlaps(fixedAxis, fixedCoord, floatCoord, radius, jitter, margin) {\n  var store = inner(fixedAxis);\n  if (!store.items) {\n    store.items = [];\n  }\n  var items = store.items;\n  // Try both positive and negative directions, choose the one with smaller movement\n  var overlapA = placeJitterOnDirection(items, fixedCoord, floatCoord, radius, jitter, margin, 1);\n  var overlapB = placeJitterOnDirection(items, fixedCoord, floatCoord, radius, jitter, margin, -1);\n  var minFloat = Math.abs(overlapA - floatCoord) < Math.abs(overlapB - floatCoord) ? overlapA : overlapB;\n  // Clamp only category axis\n  var bandWidth = fixedAxis.scale.type === 'ordinal' ? fixedAxis.getBandWidth() : null;\n  var distance = Math.abs(minFloat - floatCoord);\n  if (distance > jitter / 2 || bandWidth && distance > bandWidth / 2 - radius) {\n    // If the new item is moved too far, then give up.\n    // Fall back to random jitter.\n    return fixJitterIgnoreOverlaps(floatCoord, jitter, bandWidth, radius);\n  }\n  // Add new point to array\n  items.push({\n    fixedCoord: fixedCoord,\n    floatCoord: minFloat,\n    r: radius\n  });\n  return minFloat;\n}\nfunction placeJitterOnDirection(items, fixedCoord, floatCoord, radius, jitter, margin, direction) {\n  var y = floatCoord;\n  // Check all existing items for overlap and find the maximum adjustment needed\n  for (var i = 0; i < items.length; i++) {\n    var item = items[i];\n    var dx = fixedCoord - item.fixedCoord;\n    var dy = y - item.floatCoord;\n    var d2 = dx * dx + dy * dy;\n    var r = radius + item.r + margin;\n    if (d2 < r * r) {\n      // Has overlap, calculate required adjustment\n      var requiredY = item.floatCoord + Math.sqrt(r * r - dx * dx) * direction;\n      // Check if this adjustment would move too far\n      if (Math.abs(requiredY - floatCoord) > jitter / 2) {\n        return Number.MAX_VALUE; // Give up\n      }\n      // Update y only when it's larger to the center\n      if (direction === 1 && requiredY > y || direction === -1 && requiredY < y) {\n        y = requiredY;\n        // Loop from the start again\n        i = -1; // Reset index to recheck all items\n        continue; // Recalculate with the new y position\n      }\n    }\n  }\n\n  return y;\n}","map":{"version":3,"names":["Axis2D","makeInner","needFixJitter","seriesModel","axis","coordinateSystem","coordType","type","baseAxis","getBaseAxis","scaleType","scale","seriesValid","axisValid","model","get","inner","fixJitter","fixedAxis","fixedCoord","floatCoord","radius","axisModel","jitter","jitterOverlap","jitterMargin","bandWidth","getBandWidth","fixJitterIgnoreOverlaps","fixJitterAvoidOverlaps","Math","random","maxJitter","actualJitter","min","max","margin","store","items","overlapA","placeJitterOnDirection","overlapB","minFloat","abs","distance","push","r","direction","y","i","length","item","dx","dy","d2","requiredY","sqrt","Number","MAX_VALUE"],"sources":["D:/code/java/program/oj/code/yuoj-frontend-master/node_modules/echarts/lib/util/jitter.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport Axis2D from '../coord/cartesian/Axis2D.js';\nimport { makeInner } from './model.js';\nexport function needFixJitter(seriesModel, axis) {\n  var coordinateSystem = seriesModel.coordinateSystem;\n  var coordType = coordinateSystem && coordinateSystem.type;\n  var baseAxis = coordinateSystem && coordinateSystem.getBaseAxis && coordinateSystem.getBaseAxis();\n  var scaleType = baseAxis && baseAxis.scale && baseAxis.scale.type;\n  var seriesValid = coordType === 'cartesian2d' && scaleType === 'ordinal' || coordType === 'single';\n  var axisValid = axis.model.get('jitter') > 0;\n  return seriesValid && axisValid;\n}\nvar inner = makeInner();\n/**\n * Fix jitter for overlapping data points.\n *\n * @param fixedAxis The axis whose coord doesn't change with jitter.\n * @param fixedCoord The coord of fixedAxis.\n * @param floatCoord The coord of the other axis, which should be changed with jittering.\n * @param radius The radius of the data point, considering the symbol is a circle.\n * @returns updated floatCoord.\n */\nexport function fixJitter(fixedAxis, fixedCoord, floatCoord, radius) {\n  if (fixedAxis instanceof Axis2D) {\n    var scaleType = fixedAxis.scale.type;\n    if (scaleType !== 'category' && scaleType !== 'ordinal') {\n      return floatCoord;\n    }\n  }\n  var axisModel = fixedAxis.model;\n  var jitter = axisModel.get('jitter');\n  var jitterOverlap = axisModel.get('jitterOverlap');\n  var jitterMargin = axisModel.get('jitterMargin') || 0;\n  // Get band width to limit jitter range\n  var bandWidth = fixedAxis.scale.type === 'ordinal' ? fixedAxis.getBandWidth() : null;\n  if (jitter > 0) {\n    if (jitterOverlap) {\n      return fixJitterIgnoreOverlaps(floatCoord, jitter, bandWidth, radius);\n    } else {\n      return fixJitterAvoidOverlaps(fixedAxis, fixedCoord, floatCoord, radius, jitter, jitterMargin);\n    }\n  }\n  return floatCoord;\n}\nfunction fixJitterIgnoreOverlaps(floatCoord, jitter, bandWidth, radius) {\n  // Don't clamp single axis\n  if (bandWidth === null) {\n    return floatCoord + (Math.random() - 0.5) * jitter;\n  }\n  var maxJitter = bandWidth - radius * 2;\n  var actualJitter = Math.min(Math.max(0, jitter), maxJitter);\n  return floatCoord + (Math.random() - 0.5) * actualJitter;\n}\nfunction fixJitterAvoidOverlaps(fixedAxis, fixedCoord, floatCoord, radius, jitter, margin) {\n  var store = inner(fixedAxis);\n  if (!store.items) {\n    store.items = [];\n  }\n  var items = store.items;\n  // Try both positive and negative directions, choose the one with smaller movement\n  var overlapA = placeJitterOnDirection(items, fixedCoord, floatCoord, radius, jitter, margin, 1);\n  var overlapB = placeJitterOnDirection(items, fixedCoord, floatCoord, radius, jitter, margin, -1);\n  var minFloat = Math.abs(overlapA - floatCoord) < Math.abs(overlapB - floatCoord) ? overlapA : overlapB;\n  // Clamp only category axis\n  var bandWidth = fixedAxis.scale.type === 'ordinal' ? fixedAxis.getBandWidth() : null;\n  var distance = Math.abs(minFloat - floatCoord);\n  if (distance > jitter / 2 || bandWidth && distance > bandWidth / 2 - radius) {\n    // If the new item is moved too far, then give up.\n    // Fall back to random jitter.\n    return fixJitterIgnoreOverlaps(floatCoord, jitter, bandWidth, radius);\n  }\n  // Add new point to array\n  items.push({\n    fixedCoord: fixedCoord,\n    floatCoord: minFloat,\n    r: radius\n  });\n  return minFloat;\n}\nfunction placeJitterOnDirection(items, fixedCoord, floatCoord, radius, jitter, margin, direction) {\n  var y = floatCoord;\n  // Check all existing items for overlap and find the maximum adjustment needed\n  for (var i = 0; i < items.length; i++) {\n    var item = items[i];\n    var dx = fixedCoord - item.fixedCoord;\n    var dy = y - item.floatCoord;\n    var d2 = dx * dx + dy * dy;\n    var r = radius + item.r + margin;\n    if (d2 < r * r) {\n      // Has overlap, calculate required adjustment\n      var requiredY = item.floatCoord + Math.sqrt(r * r - dx * dx) * direction;\n      // Check if this adjustment would move too far\n      if (Math.abs(requiredY - floatCoord) > jitter / 2) {\n        return Number.MAX_VALUE; // Give up\n      }\n      // Update y only when it's larger to the center\n      if (direction === 1 && requiredY > y || direction === -1 && requiredY < y) {\n        y = requiredY;\n        // Loop from the start again\n        i = -1; // Reset index to recheck all items\n        continue; // Recalculate with the new y position\n      }\n    }\n  }\n  return y;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
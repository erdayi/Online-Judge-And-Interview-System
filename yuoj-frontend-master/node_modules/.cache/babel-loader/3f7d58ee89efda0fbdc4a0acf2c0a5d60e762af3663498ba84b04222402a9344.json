{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// Layout helpers for each component positioning\nimport * as zrUtil from 'zrender/lib/core/util.js';\nimport BoundingRect from 'zrender/lib/core/BoundingRect.js';\nimport { parsePercent } from './number.js';\nimport * as formatUtil from './format.js';\nimport { error } from './log.js';\nimport { BoxCoordinateSystemCoordFrom, getCoordForBoxCoordSys } from '../core/CoordinateSystem.js';\nvar each = zrUtil.each;\n/**\n * @public\n */\nexport var LOCATION_PARAMS = ['left', 'right', 'top', 'bottom', 'width', 'height'];\n/**\n * @public\n */\nexport var HV_NAMES = [['width', 'left', 'right'], ['height', 'top', 'bottom']];\nfunction boxLayout(orient, group, gap, maxWidth, maxHeight) {\n  var x = 0;\n  var y = 0;\n  if (maxWidth == null) {\n    maxWidth = Infinity;\n  }\n  if (maxHeight == null) {\n    maxHeight = Infinity;\n  }\n  var currentLineMaxSize = 0;\n  group.eachChild(function (child, idx) {\n    var rect = child.getBoundingRect();\n    var nextChild = group.childAt(idx + 1);\n    var nextChildRect = nextChild && nextChild.getBoundingRect();\n    var nextX;\n    var nextY;\n    if (orient === 'horizontal') {\n      var moveX = rect.width + (nextChildRect ? -nextChildRect.x + rect.x : 0);\n      nextX = x + moveX;\n      // Wrap when width exceeds maxWidth or meet a `newline` group\n      // FIXME compare before adding gap?\n      if (nextX > maxWidth || child.newline) {\n        x = 0;\n        nextX = moveX;\n        y += currentLineMaxSize + gap;\n        currentLineMaxSize = rect.height;\n      } else {\n        // FIXME: consider rect.y is not `0`?\n        currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);\n      }\n    } else {\n      var moveY = rect.height + (nextChildRect ? -nextChildRect.y + rect.y : 0);\n      nextY = y + moveY;\n      // Wrap when width exceeds maxHeight or meet a `newline` group\n      if (nextY > maxHeight || child.newline) {\n        x += currentLineMaxSize + gap;\n        y = 0;\n        nextY = moveY;\n        currentLineMaxSize = rect.width;\n      } else {\n        currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);\n      }\n    }\n    if (child.newline) {\n      return;\n    }\n    child.x = x;\n    child.y = y;\n    child.markRedraw();\n    orient === 'horizontal' ? x = nextX + gap : y = nextY + gap;\n  });\n}\n/**\n * VBox or HBox layouting\n * @param {string} orient\n * @param {module:zrender/graphic/Group} group\n * @param {number} gap\n * @param {number} [width=Infinity]\n * @param {number} [height=Infinity]\n */\nexport var box = boxLayout;\n/**\n * VBox layouting\n * @param {module:zrender/graphic/Group} group\n * @param {number} gap\n * @param {number} [width=Infinity]\n * @param {number} [height=Infinity]\n */\nexport var vbox = zrUtil.curry(boxLayout, 'vertical');\n/**\n * HBox layouting\n * @param {module:zrender/graphic/Group} group\n * @param {number} gap\n * @param {number} [width=Infinity]\n * @param {number} [height=Infinity]\n */\nexport var hbox = zrUtil.curry(boxLayout, 'horizontal');\nexport function getBoxLayoutParams(boxLayoutModel, ignoreParent) {\n  return {\n    left: boxLayoutModel.getShallow('left', ignoreParent),\n    top: boxLayoutModel.getShallow('top', ignoreParent),\n    right: boxLayoutModel.getShallow('right', ignoreParent),\n    bottom: boxLayoutModel.getShallow('bottom', ignoreParent),\n    width: boxLayoutModel.getShallow('width', ignoreParent),\n    height: boxLayoutModel.getShallow('height', ignoreParent)\n  };\n}\nfunction getViewRectAndCenterForCircleLayout(seriesModel, api) {\n  var layoutRef = createBoxLayoutReference(seriesModel, api, {\n    enableLayoutOnlyByCenter: true\n  });\n  var boxLayoutParams = seriesModel.getBoxLayoutParams();\n  var viewRect;\n  var center;\n  if (layoutRef.type === BoxLayoutReferenceType.point) {\n    center = layoutRef.refPoint;\n    // `viewRect` is required in `pie/labelLayout.ts`.\n    viewRect = getLayoutRect(boxLayoutParams, {\n      width: api.getWidth(),\n      height: api.getHeight()\n    });\n  } else {\n    // layoutRef.type === layout.BoxLayoutReferenceType.rect\n    var centerOption = seriesModel.get('center');\n    var centerOptionArr = zrUtil.isArray(centerOption) ? centerOption : [centerOption, centerOption];\n    viewRect = getLayoutRect(boxLayoutParams, layoutRef.refContainer);\n    center = layoutRef.boxCoordFrom === BoxCoordinateSystemCoordFrom.coord2 ? layoutRef.refPoint // option `series.center` has been used as coord.\n    : [parsePercent(centerOptionArr[0], viewRect.width) + viewRect.x, parsePercent(centerOptionArr[1], viewRect.height) + viewRect.y];\n  }\n  return {\n    viewRect: viewRect,\n    center: center\n  };\n}\nexport function getCircleLayout(seriesModel, api) {\n  // center can be string or number when coordinateSystem is specified\n  var _a = getViewRectAndCenterForCircleLayout(seriesModel, api),\n    viewRect = _a.viewRect,\n    center = _a.center;\n  var radius = seriesModel.get('radius');\n  if (!zrUtil.isArray(radius)) {\n    radius = [0, radius];\n  }\n  var width = parsePercent(viewRect.width, api.getWidth());\n  var height = parsePercent(viewRect.height, api.getHeight());\n  var size = Math.min(width, height);\n  var r0 = parsePercent(radius[0], size / 2);\n  var r = parsePercent(radius[1], size / 2);\n  return {\n    cx: center[0],\n    cy: center[1],\n    r0: r0,\n    r: r,\n    viewRect: viewRect\n  };\n}\n/**\n * Parse position info.\n */\nexport function getLayoutRect(positionInfo, containerRect,\n// This is the space from the `containerRect` to the returned bounding rect.\n// Commonly used in option `legend.padding`, `timeline.padding`, `title.padding`,\n//  `visualMap.padding`, ...\n// [NOTICE]:\n//  It's named `margin`, because it's the space that outside the bounding rect. But from\n//  the perspective of the the caller, it's commonly used as the `padding` of a component,\n//  because conventionally background color covers this space.\n// [BEHAVIOR]:\n//  - If width/height is specified, `margin` does not effect them.\n//  - Otherwise, they are calculated based on the rect that `containerRect` shrinked by `margin`.\n//  - left/right/top/bottom are based on the rect that `containerRect` shrinked by `margin`.\nmargin) {\n  margin = formatUtil.normalizeCssArray(margin || 0);\n  var containerWidth = containerRect.width;\n  var containerHeight = containerRect.height;\n  var left = parsePercent(positionInfo.left, containerWidth);\n  var top = parsePercent(positionInfo.top, containerHeight);\n  var right = parsePercent(positionInfo.right, containerWidth);\n  var bottom = parsePercent(positionInfo.bottom, containerHeight);\n  var width = parsePercent(positionInfo.width, containerWidth);\n  var height = parsePercent(positionInfo.height, containerHeight);\n  var verticalMargin = margin[2] + margin[0];\n  var horizontalMargin = margin[1] + margin[3];\n  var aspect = positionInfo.aspect;\n  // If width is not specified, calculate width from left and right\n  if (isNaN(width)) {\n    width = containerWidth - right - horizontalMargin - left;\n  }\n  if (isNaN(height)) {\n    height = containerHeight - bottom - verticalMargin - top;\n  }\n  if (aspect != null) {\n    // If width and height are not given\n    // 1. Graph should not exceeds the container\n    // 2. Aspect must be keeped\n    // 3. Graph should take the space as more as possible\n    // FIXME\n    // Margin is not considered, because there is no case that both\n    // using margin and aspect so far.\n    if (isNaN(width) && isNaN(height)) {\n      // PENDING: if only `left` or `right` is defined, perhaps it's more preferable to\n      // calculate size based on `containerWidth - left` or `containerWidth - left` here,\n      // but for backward compatibility we do not change it.\n      if (aspect > containerWidth / containerHeight) {\n        width = containerWidth * 0.8;\n      } else {\n        height = containerHeight * 0.8;\n      }\n    }\n    // Calculate width or height with given aspect\n    if (isNaN(width)) {\n      width = aspect * height;\n    }\n    if (isNaN(height)) {\n      height = width / aspect;\n    }\n  }\n  // If left is not specified, calculate left from right and width\n  if (isNaN(left)) {\n    left = containerWidth - right - width - horizontalMargin;\n  }\n  if (isNaN(top)) {\n    top = containerHeight - bottom - height - verticalMargin;\n  }\n  // Align left and top\n  switch (positionInfo.left || positionInfo.right) {\n    case 'center':\n      left = containerWidth / 2 - width / 2 - margin[3];\n      break;\n    case 'right':\n      left = containerWidth - width - horizontalMargin;\n      break;\n  }\n  switch (positionInfo.top || positionInfo.bottom) {\n    case 'middle':\n    case 'center':\n      top = containerHeight / 2 - height / 2 - margin[0];\n      break;\n    case 'bottom':\n      top = containerHeight - height - verticalMargin;\n      break;\n  }\n  // If something is wrong and left, top, width, height are calculated as NaN\n  left = left || 0;\n  top = top || 0;\n  if (isNaN(width)) {\n    // Width may be NaN if only one value is given except width\n    width = containerWidth - horizontalMargin - left - (right || 0);\n  }\n  if (isNaN(height)) {\n    // Height may be NaN if only one value is given except height\n    height = containerHeight - verticalMargin - top - (bottom || 0);\n  }\n  var rect = new BoundingRect((containerRect.x || 0) + left + margin[3], (containerRect.y || 0) + top + margin[0], width, height);\n  rect.margin = margin;\n  return rect;\n}\n/**\n * PENDING:\n *  when preserveAspect: 'cover' and aspect is near Infinity\n *  or when preserveAspect: 'contain' and aspect is near 0,\n *  the result width or height is near Inifity. It's logically correct,\n *  Therefore currently we do not handle it, until bad cases arise.\n */\nexport function applyPreserveAspect(component, layoutRect,\n// That is, `width / height`.\n// Assume `aspect` is positive.\naspect) {\n  var preserveAspect = component.getShallow('preserveAspect', true);\n  if (!preserveAspect) {\n    return layoutRect;\n  }\n  var actualAspect = layoutRect.width / layoutRect.height;\n  if (Math.abs(Math.atan(aspect) - Math.atan(actualAspect)) < 1e-9) {\n    return layoutRect;\n  }\n  var preserveAspectAlign = component.getShallow('preserveAspectAlign', true);\n  var preserveAspectVerticalAlign = component.getShallow('preserveAspectVerticalAlign', true);\n  var layoutOptInner = {\n    width: layoutRect.width,\n    height: layoutRect.height\n  };\n  var isCover = preserveAspect === 'cover';\n  if (actualAspect > aspect && !isCover || actualAspect < aspect && isCover) {\n    layoutOptInner.width = layoutRect.height * aspect;\n    preserveAspectAlign === 'left' ? layoutOptInner.left = 0 : preserveAspectAlign === 'right' ? layoutOptInner.right = 0 : layoutOptInner.left = 'center';\n  } else {\n    layoutOptInner.height = layoutRect.width / aspect;\n    preserveAspectVerticalAlign === 'top' ? layoutOptInner.top = 0 : preserveAspectVerticalAlign === 'bottom' ? layoutOptInner.bottom = 0 : layoutOptInner.top = 'middle';\n  }\n  return getLayoutRect(layoutOptInner, layoutRect);\n}\nexport var BoxLayoutReferenceType = {\n  rect: 1,\n  point: 2\n};\n/**\n * Uniformly calculate layout reference (rect or center) based on either:\n *  - viewport:\n *      - Get `refContainer` as `{x: 0, y: 0, width: api.getWidth(), height: api.getHeight()}`\n *  - coordinate system, which can serve in several ways:\n *      - Use `dataToPoint` to get the `refPoint`, such as, in cartesian2d coord sys.\n *      - Use `dataToLayout` to get the `refContainer`, such as, in matrix coord sys.\n */\nexport function createBoxLayoutReference(model, api, opt) {\n  var refContainer;\n  var refPoint;\n  var layoutRefType;\n  var boxCoordSys = model.boxCoordinateSystem;\n  var boxCoordFrom;\n  if (boxCoordSys) {\n    var _a = getCoordForBoxCoordSys(model),\n      coord = _a.coord,\n      from = _a.from;\n    // Do not use `clamp` in `dataToLayout` and `dataToPoint`, because:\n    //  1. Should support overflow (such as, by dataZoom), where NaN should be in the result.\n    //  2. Be consistent with the way used in `series.data`\n    if (boxCoordSys.dataToLayout) {\n      layoutRefType = BoxLayoutReferenceType.rect;\n      boxCoordFrom = from;\n      var result = boxCoordSys.dataToLayout(coord);\n      refContainer = result.contentRect || result.rect;\n    } else if (opt && opt.enableLayoutOnlyByCenter && boxCoordSys.dataToPoint) {\n      layoutRefType = BoxLayoutReferenceType.point;\n      boxCoordFrom = from;\n      refPoint = boxCoordSys.dataToPoint(coord);\n    } else {\n      if (process.env.NODE_ENV !== 'production') {\n        error(model.type + \"[\" + model.componentIndex + \"]\" + (\" layout based on \" + boxCoordSys.type + \" is not supported.\"));\n      }\n    }\n  }\n  if (layoutRefType == null) {\n    layoutRefType = BoxLayoutReferenceType.rect;\n  }\n  if (layoutRefType === BoxLayoutReferenceType.rect) {\n    if (!refContainer) {\n      refContainer = {\n        x: 0,\n        y: 0,\n        width: api.getWidth(),\n        height: api.getHeight()\n      };\n    }\n    refPoint = [refContainer.x + refContainer.width / 2, refContainer.y + refContainer.height / 2];\n  }\n  return {\n    type: layoutRefType,\n    refContainer: refContainer,\n    refPoint: refPoint,\n    boxCoordFrom: boxCoordFrom\n  };\n}\n/**\n * Position a zr element in viewport\n *  Group position is specified by either\n *  {left, top}, {right, bottom}\n *  If all properties exists, right and bottom will be igonred.\n *\n * Logic:\n *     1. Scale (against origin point in parent coord)\n *     2. Rotate (against origin point in parent coord)\n *     3. Translate (with el.position by this method)\n * So this method only fixes the last step 'Translate', which does not affect\n * scaling and rotating.\n *\n * If be called repeatedly with the same input el, the same result will be gotten.\n *\n * Return true if the layout happened.\n *\n * @param el Should have `getBoundingRect` method.\n * @param positionInfo\n * @param positionInfo.left\n * @param positionInfo.top\n * @param positionInfo.right\n * @param positionInfo.bottom\n * @param positionInfo.width Only for opt.boundingModel: 'raw'\n * @param positionInfo.height Only for opt.boundingModel: 'raw'\n * @param containerRect\n * @param margin\n * @param opt\n * @param opt.hv Only horizontal or only vertical. Default to be [1, 1]\n * @param opt.boundingMode\n *        Specify how to calculate boundingRect when locating.\n *        'all': Position the boundingRect that is transformed and uioned\n *               both itself and its descendants.\n *               This mode simplies confine the elements in the bounding\n *               of their container (e.g., using 'right: 0').\n *        'raw': Position the boundingRect that is not transformed and only itself.\n *               This mode is useful when you want a element can overflow its\n *               container. (Consider a rotated circle needs to be located in a corner.)\n *               In this mode positionInfo.width/height can only be number.\n */\nexport function positionElement(el, positionInfo, containerRect, margin, opt, out) {\n  var h = !opt || !opt.hv || opt.hv[0];\n  var v = !opt || !opt.hv || opt.hv[1];\n  var boundingMode = opt && opt.boundingMode || 'all';\n  out = out || el;\n  out.x = el.x;\n  out.y = el.y;\n  if (!h && !v) {\n    return false;\n  }\n  var rect;\n  if (boundingMode === 'raw') {\n    rect = el.type === 'group' ? new BoundingRect(0, 0, +positionInfo.width || 0, +positionInfo.height || 0) : el.getBoundingRect();\n  } else {\n    rect = el.getBoundingRect();\n    if (el.needLocalTransform()) {\n      var transform = el.getLocalTransform();\n      // Notice: raw rect may be inner object of el,\n      // which should not be modified.\n      rect = rect.clone();\n      rect.applyTransform(transform);\n    }\n  }\n  // The real width and height can not be specified but calculated by the given el.\n  var layoutRect = getLayoutRect(zrUtil.defaults({\n    width: rect.width,\n    height: rect.height\n  }, positionInfo), containerRect, margin);\n  // Because 'tranlate' is the last step in transform\n  // (see zrender/core/Transformable#getLocalTransform),\n  // we can just only modify el.position to get final result.\n  var dx = h ? layoutRect.x - rect.x : 0;\n  var dy = v ? layoutRect.y - rect.y : 0;\n  if (boundingMode === 'raw') {\n    out.x = dx;\n    out.y = dy;\n  } else {\n    out.x += dx;\n    out.y += dy;\n  }\n  if (out === el) {\n    el.markRedraw();\n  }\n  return true;\n}\n/**\n * @param option Contains some of the properties in HV_NAMES.\n * @param hvIdx 0: horizontal; 1: vertical.\n */\nexport function sizeCalculable(option, hvIdx) {\n  return option[HV_NAMES[hvIdx][0]] != null || option[HV_NAMES[hvIdx][1]] != null && option[HV_NAMES[hvIdx][2]] != null;\n}\nexport function fetchLayoutMode(ins) {\n  var layoutMode = ins.layoutMode || ins.constructor.layoutMode;\n  return zrUtil.isObject(layoutMode) ? layoutMode : layoutMode ? {\n    type: layoutMode\n  } : null;\n}\n/**\n * Consider Case:\n * When default option has {left: 0, width: 100}, and we set {right: 0}\n * through setOption or media query, using normal zrUtil.merge will cause\n * {right: 0} does not take effect.\n *\n * @example\n * ComponentModel.extend({\n *     init: function () {\n *         ...\n *         let inputPositionParams = layout.getLayoutParams(option);\n *         this.mergeOption(inputPositionParams);\n *     },\n *     mergeOption: function (newOption) {\n *         newOption && zrUtil.merge(thisOption, newOption, true);\n *         layout.mergeLayoutParam(thisOption, newOption);\n *     }\n * });\n *\n * @param targetOption\n * @param newOption\n * @param opt\n */\nexport function mergeLayoutParam(targetOption, newOption, opt) {\n  var ignoreSize = opt && opt.ignoreSize;\n  !zrUtil.isArray(ignoreSize) && (ignoreSize = [ignoreSize, ignoreSize]);\n  var hResult = merge(HV_NAMES[0], 0);\n  var vResult = merge(HV_NAMES[1], 1);\n  copy(HV_NAMES[0], targetOption, hResult);\n  copy(HV_NAMES[1], targetOption, vResult);\n  function merge(names, hvIdx) {\n    var newParams = {};\n    var newValueCount = 0;\n    var merged = {};\n    var mergedValueCount = 0;\n    var enoughParamNumber = 2;\n    each(names, function (name) {\n      merged[name] = targetOption[name];\n    });\n    each(names, function (name) {\n      // Consider case: newOption.width is null, which is\n      // set by user for removing width setting.\n      zrUtil.hasOwn(newOption, name) && (newParams[name] = merged[name] = newOption[name]);\n      hasValue(newParams, name) && newValueCount++;\n      hasValue(merged, name) && mergedValueCount++;\n    });\n    if (ignoreSize[hvIdx]) {\n      // Only one of left/right is premitted to exist.\n      if (hasValue(newOption, names[1])) {\n        merged[names[2]] = null;\n      } else if (hasValue(newOption, names[2])) {\n        merged[names[1]] = null;\n      }\n      return merged;\n    }\n    // Case: newOption: {width: ..., right: ...},\n    // or targetOption: {right: ...} and newOption: {width: ...},\n    // There is no conflict when merged only has params count\n    // little than enoughParamNumber.\n    if (mergedValueCount === enoughParamNumber || !newValueCount) {\n      return merged;\n    }\n    // Case: newOption: {width: ..., right: ...},\n    // Than we can make sure user only want those two, and ignore\n    // all origin params in targetOption.\n    else if (newValueCount >= enoughParamNumber) {\n      return newParams;\n    } else {\n      // Chose another param from targetOption by priority.\n      for (var i = 0; i < names.length; i++) {\n        var name_1 = names[i];\n        if (!zrUtil.hasOwn(newParams, name_1) && zrUtil.hasOwn(targetOption, name_1)) {\n          newParams[name_1] = targetOption[name_1];\n          break;\n        }\n      }\n      return newParams;\n    }\n  }\n  function hasValue(obj, name) {\n    return obj[name] != null && obj[name] !== 'auto';\n  }\n  function copy(names, target, source) {\n    each(names, function (name) {\n      target[name] = source[name];\n    });\n  }\n}\n/**\n * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n */\nexport function getLayoutParams(source) {\n  return copyLayoutParams({}, source);\n}\n/**\n * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n * @param {Object} source\n * @return {Object} Result contains those props.\n */\nexport function copyLayoutParams(target, source) {\n  source && target && each(LOCATION_PARAMS, function (name) {\n    zrUtil.hasOwn(source, name) && (target[name] = source[name]);\n  });\n  return target;\n}","map":{"version":3,"names":["zrUtil","BoundingRect","parsePercent","formatUtil","error","BoxCoordinateSystemCoordFrom","getCoordForBoxCoordSys","each","LOCATION_PARAMS","HV_NAMES","boxLayout","orient","group","gap","maxWidth","maxHeight","x","y","Infinity","currentLineMaxSize","eachChild","child","idx","rect","getBoundingRect","nextChild","childAt","nextChildRect","nextX","nextY","moveX","width","newline","height","Math","max","moveY","markRedraw","box","vbox","curry","hbox","getBoxLayoutParams","boxLayoutModel","ignoreParent","left","getShallow","top","right","bottom","getViewRectAndCenterForCircleLayout","seriesModel","api","layoutRef","createBoxLayoutReference","enableLayoutOnlyByCenter","boxLayoutParams","viewRect","center","type","BoxLayoutReferenceType","point","refPoint","getLayoutRect","getWidth","getHeight","centerOption","get","centerOptionArr","isArray","refContainer","boxCoordFrom","coord2","getCircleLayout","_a","radius","size","min","r0","r","cx","cy","positionInfo","containerRect","margin","normalizeCssArray","containerWidth","containerHeight","verticalMargin","horizontalMargin","aspect","isNaN","applyPreserveAspect","component","layoutRect","preserveAspect","actualAspect","abs","atan","preserveAspectAlign","preserveAspectVerticalAlign","layoutOptInner","isCover","model","opt","layoutRefType","boxCoordSys","boxCoordinateSystem","coord","from","dataToLayout","result","contentRect","dataToPoint","process","env","NODE_ENV","componentIndex","positionElement","el","out","h","hv","v","boundingMode","needLocalTransform","transform","getLocalTransform","clone","applyTransform","defaults","dx","dy","sizeCalculable","option","hvIdx","fetchLayoutMode","ins","layoutMode","constructor","isObject","mergeLayoutParam","targetOption","newOption","ignoreSize","hResult","merge","vResult","copy","names","newParams","newValueCount","merged","mergedValueCount","enoughParamNumber","name","hasOwn","hasValue","i","length","name_1","obj","target","source","getLayoutParams","copyLayoutParams"],"sources":["D:/code/java/program/oj/code/yuoj-frontend-master/node_modules/echarts/lib/util/layout.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// Layout helpers for each component positioning\nimport * as zrUtil from 'zrender/lib/core/util.js';\nimport BoundingRect from 'zrender/lib/core/BoundingRect.js';\nimport { parsePercent } from './number.js';\nimport * as formatUtil from './format.js';\nimport { error } from './log.js';\nimport { BoxCoordinateSystemCoordFrom, getCoordForBoxCoordSys } from '../core/CoordinateSystem.js';\nvar each = zrUtil.each;\n/**\n * @public\n */\nexport var LOCATION_PARAMS = ['left', 'right', 'top', 'bottom', 'width', 'height'];\n/**\n * @public\n */\nexport var HV_NAMES = [['width', 'left', 'right'], ['height', 'top', 'bottom']];\nfunction boxLayout(orient, group, gap, maxWidth, maxHeight) {\n  var x = 0;\n  var y = 0;\n  if (maxWidth == null) {\n    maxWidth = Infinity;\n  }\n  if (maxHeight == null) {\n    maxHeight = Infinity;\n  }\n  var currentLineMaxSize = 0;\n  group.eachChild(function (child, idx) {\n    var rect = child.getBoundingRect();\n    var nextChild = group.childAt(idx + 1);\n    var nextChildRect = nextChild && nextChild.getBoundingRect();\n    var nextX;\n    var nextY;\n    if (orient === 'horizontal') {\n      var moveX = rect.width + (nextChildRect ? -nextChildRect.x + rect.x : 0);\n      nextX = x + moveX;\n      // Wrap when width exceeds maxWidth or meet a `newline` group\n      // FIXME compare before adding gap?\n      if (nextX > maxWidth || child.newline) {\n        x = 0;\n        nextX = moveX;\n        y += currentLineMaxSize + gap;\n        currentLineMaxSize = rect.height;\n      } else {\n        // FIXME: consider rect.y is not `0`?\n        currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);\n      }\n    } else {\n      var moveY = rect.height + (nextChildRect ? -nextChildRect.y + rect.y : 0);\n      nextY = y + moveY;\n      // Wrap when width exceeds maxHeight or meet a `newline` group\n      if (nextY > maxHeight || child.newline) {\n        x += currentLineMaxSize + gap;\n        y = 0;\n        nextY = moveY;\n        currentLineMaxSize = rect.width;\n      } else {\n        currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);\n      }\n    }\n    if (child.newline) {\n      return;\n    }\n    child.x = x;\n    child.y = y;\n    child.markRedraw();\n    orient === 'horizontal' ? x = nextX + gap : y = nextY + gap;\n  });\n}\n/**\n * VBox or HBox layouting\n * @param {string} orient\n * @param {module:zrender/graphic/Group} group\n * @param {number} gap\n * @param {number} [width=Infinity]\n * @param {number} [height=Infinity]\n */\nexport var box = boxLayout;\n/**\n * VBox layouting\n * @param {module:zrender/graphic/Group} group\n * @param {number} gap\n * @param {number} [width=Infinity]\n * @param {number} [height=Infinity]\n */\nexport var vbox = zrUtil.curry(boxLayout, 'vertical');\n/**\n * HBox layouting\n * @param {module:zrender/graphic/Group} group\n * @param {number} gap\n * @param {number} [width=Infinity]\n * @param {number} [height=Infinity]\n */\nexport var hbox = zrUtil.curry(boxLayout, 'horizontal');\nexport function getBoxLayoutParams(boxLayoutModel, ignoreParent) {\n  return {\n    left: boxLayoutModel.getShallow('left', ignoreParent),\n    top: boxLayoutModel.getShallow('top', ignoreParent),\n    right: boxLayoutModel.getShallow('right', ignoreParent),\n    bottom: boxLayoutModel.getShallow('bottom', ignoreParent),\n    width: boxLayoutModel.getShallow('width', ignoreParent),\n    height: boxLayoutModel.getShallow('height', ignoreParent)\n  };\n}\nfunction getViewRectAndCenterForCircleLayout(seriesModel, api) {\n  var layoutRef = createBoxLayoutReference(seriesModel, api, {\n    enableLayoutOnlyByCenter: true\n  });\n  var boxLayoutParams = seriesModel.getBoxLayoutParams();\n  var viewRect;\n  var center;\n  if (layoutRef.type === BoxLayoutReferenceType.point) {\n    center = layoutRef.refPoint;\n    // `viewRect` is required in `pie/labelLayout.ts`.\n    viewRect = getLayoutRect(boxLayoutParams, {\n      width: api.getWidth(),\n      height: api.getHeight()\n    });\n  } else {\n    // layoutRef.type === layout.BoxLayoutReferenceType.rect\n    var centerOption = seriesModel.get('center');\n    var centerOptionArr = zrUtil.isArray(centerOption) ? centerOption : [centerOption, centerOption];\n    viewRect = getLayoutRect(boxLayoutParams, layoutRef.refContainer);\n    center = layoutRef.boxCoordFrom === BoxCoordinateSystemCoordFrom.coord2 ? layoutRef.refPoint // option `series.center` has been used as coord.\n    : [parsePercent(centerOptionArr[0], viewRect.width) + viewRect.x, parsePercent(centerOptionArr[1], viewRect.height) + viewRect.y];\n  }\n  return {\n    viewRect: viewRect,\n    center: center\n  };\n}\nexport function getCircleLayout(seriesModel, api) {\n  // center can be string or number when coordinateSystem is specified\n  var _a = getViewRectAndCenterForCircleLayout(seriesModel, api),\n    viewRect = _a.viewRect,\n    center = _a.center;\n  var radius = seriesModel.get('radius');\n  if (!zrUtil.isArray(radius)) {\n    radius = [0, radius];\n  }\n  var width = parsePercent(viewRect.width, api.getWidth());\n  var height = parsePercent(viewRect.height, api.getHeight());\n  var size = Math.min(width, height);\n  var r0 = parsePercent(radius[0], size / 2);\n  var r = parsePercent(radius[1], size / 2);\n  return {\n    cx: center[0],\n    cy: center[1],\n    r0: r0,\n    r: r,\n    viewRect: viewRect\n  };\n}\n/**\n * Parse position info.\n */\nexport function getLayoutRect(positionInfo, containerRect,\n// This is the space from the `containerRect` to the returned bounding rect.\n// Commonly used in option `legend.padding`, `timeline.padding`, `title.padding`,\n//  `visualMap.padding`, ...\n// [NOTICE]:\n//  It's named `margin`, because it's the space that outside the bounding rect. But from\n//  the perspective of the the caller, it's commonly used as the `padding` of a component,\n//  because conventionally background color covers this space.\n// [BEHAVIOR]:\n//  - If width/height is specified, `margin` does not effect them.\n//  - Otherwise, they are calculated based on the rect that `containerRect` shrinked by `margin`.\n//  - left/right/top/bottom are based on the rect that `containerRect` shrinked by `margin`.\nmargin) {\n  margin = formatUtil.normalizeCssArray(margin || 0);\n  var containerWidth = containerRect.width;\n  var containerHeight = containerRect.height;\n  var left = parsePercent(positionInfo.left, containerWidth);\n  var top = parsePercent(positionInfo.top, containerHeight);\n  var right = parsePercent(positionInfo.right, containerWidth);\n  var bottom = parsePercent(positionInfo.bottom, containerHeight);\n  var width = parsePercent(positionInfo.width, containerWidth);\n  var height = parsePercent(positionInfo.height, containerHeight);\n  var verticalMargin = margin[2] + margin[0];\n  var horizontalMargin = margin[1] + margin[3];\n  var aspect = positionInfo.aspect;\n  // If width is not specified, calculate width from left and right\n  if (isNaN(width)) {\n    width = containerWidth - right - horizontalMargin - left;\n  }\n  if (isNaN(height)) {\n    height = containerHeight - bottom - verticalMargin - top;\n  }\n  if (aspect != null) {\n    // If width and height are not given\n    // 1. Graph should not exceeds the container\n    // 2. Aspect must be keeped\n    // 3. Graph should take the space as more as possible\n    // FIXME\n    // Margin is not considered, because there is no case that both\n    // using margin and aspect so far.\n    if (isNaN(width) && isNaN(height)) {\n      // PENDING: if only `left` or `right` is defined, perhaps it's more preferable to\n      // calculate size based on `containerWidth - left` or `containerWidth - left` here,\n      // but for backward compatibility we do not change it.\n      if (aspect > containerWidth / containerHeight) {\n        width = containerWidth * 0.8;\n      } else {\n        height = containerHeight * 0.8;\n      }\n    }\n    // Calculate width or height with given aspect\n    if (isNaN(width)) {\n      width = aspect * height;\n    }\n    if (isNaN(height)) {\n      height = width / aspect;\n    }\n  }\n  // If left is not specified, calculate left from right and width\n  if (isNaN(left)) {\n    left = containerWidth - right - width - horizontalMargin;\n  }\n  if (isNaN(top)) {\n    top = containerHeight - bottom - height - verticalMargin;\n  }\n  // Align left and top\n  switch (positionInfo.left || positionInfo.right) {\n    case 'center':\n      left = containerWidth / 2 - width / 2 - margin[3];\n      break;\n    case 'right':\n      left = containerWidth - width - horizontalMargin;\n      break;\n  }\n  switch (positionInfo.top || positionInfo.bottom) {\n    case 'middle':\n    case 'center':\n      top = containerHeight / 2 - height / 2 - margin[0];\n      break;\n    case 'bottom':\n      top = containerHeight - height - verticalMargin;\n      break;\n  }\n  // If something is wrong and left, top, width, height are calculated as NaN\n  left = left || 0;\n  top = top || 0;\n  if (isNaN(width)) {\n    // Width may be NaN if only one value is given except width\n    width = containerWidth - horizontalMargin - left - (right || 0);\n  }\n  if (isNaN(height)) {\n    // Height may be NaN if only one value is given except height\n    height = containerHeight - verticalMargin - top - (bottom || 0);\n  }\n  var rect = new BoundingRect((containerRect.x || 0) + left + margin[3], (containerRect.y || 0) + top + margin[0], width, height);\n  rect.margin = margin;\n  return rect;\n}\n/**\n * PENDING:\n *  when preserveAspect: 'cover' and aspect is near Infinity\n *  or when preserveAspect: 'contain' and aspect is near 0,\n *  the result width or height is near Inifity. It's logically correct,\n *  Therefore currently we do not handle it, until bad cases arise.\n */\nexport function applyPreserveAspect(component, layoutRect,\n// That is, `width / height`.\n// Assume `aspect` is positive.\naspect) {\n  var preserveAspect = component.getShallow('preserveAspect', true);\n  if (!preserveAspect) {\n    return layoutRect;\n  }\n  var actualAspect = layoutRect.width / layoutRect.height;\n  if (Math.abs(Math.atan(aspect) - Math.atan(actualAspect)) < 1e-9) {\n    return layoutRect;\n  }\n  var preserveAspectAlign = component.getShallow('preserveAspectAlign', true);\n  var preserveAspectVerticalAlign = component.getShallow('preserveAspectVerticalAlign', true);\n  var layoutOptInner = {\n    width: layoutRect.width,\n    height: layoutRect.height\n  };\n  var isCover = preserveAspect === 'cover';\n  if (actualAspect > aspect && !isCover || actualAspect < aspect && isCover) {\n    layoutOptInner.width = layoutRect.height * aspect;\n    preserveAspectAlign === 'left' ? layoutOptInner.left = 0 : preserveAspectAlign === 'right' ? layoutOptInner.right = 0 : layoutOptInner.left = 'center';\n  } else {\n    layoutOptInner.height = layoutRect.width / aspect;\n    preserveAspectVerticalAlign === 'top' ? layoutOptInner.top = 0 : preserveAspectVerticalAlign === 'bottom' ? layoutOptInner.bottom = 0 : layoutOptInner.top = 'middle';\n  }\n  return getLayoutRect(layoutOptInner, layoutRect);\n}\nexport var BoxLayoutReferenceType = {\n  rect: 1,\n  point: 2\n};\n/**\n * Uniformly calculate layout reference (rect or center) based on either:\n *  - viewport:\n *      - Get `refContainer` as `{x: 0, y: 0, width: api.getWidth(), height: api.getHeight()}`\n *  - coordinate system, which can serve in several ways:\n *      - Use `dataToPoint` to get the `refPoint`, such as, in cartesian2d coord sys.\n *      - Use `dataToLayout` to get the `refContainer`, such as, in matrix coord sys.\n */\nexport function createBoxLayoutReference(model, api, opt) {\n  var refContainer;\n  var refPoint;\n  var layoutRefType;\n  var boxCoordSys = model.boxCoordinateSystem;\n  var boxCoordFrom;\n  if (boxCoordSys) {\n    var _a = getCoordForBoxCoordSys(model),\n      coord = _a.coord,\n      from = _a.from;\n    // Do not use `clamp` in `dataToLayout` and `dataToPoint`, because:\n    //  1. Should support overflow (such as, by dataZoom), where NaN should be in the result.\n    //  2. Be consistent with the way used in `series.data`\n    if (boxCoordSys.dataToLayout) {\n      layoutRefType = BoxLayoutReferenceType.rect;\n      boxCoordFrom = from;\n      var result = boxCoordSys.dataToLayout(coord);\n      refContainer = result.contentRect || result.rect;\n    } else if (opt && opt.enableLayoutOnlyByCenter && boxCoordSys.dataToPoint) {\n      layoutRefType = BoxLayoutReferenceType.point;\n      boxCoordFrom = from;\n      refPoint = boxCoordSys.dataToPoint(coord);\n    } else {\n      if (process.env.NODE_ENV !== 'production') {\n        error(model.type + \"[\" + model.componentIndex + \"]\" + (\" layout based on \" + boxCoordSys.type + \" is not supported.\"));\n      }\n    }\n  }\n  if (layoutRefType == null) {\n    layoutRefType = BoxLayoutReferenceType.rect;\n  }\n  if (layoutRefType === BoxLayoutReferenceType.rect) {\n    if (!refContainer) {\n      refContainer = {\n        x: 0,\n        y: 0,\n        width: api.getWidth(),\n        height: api.getHeight()\n      };\n    }\n    refPoint = [refContainer.x + refContainer.width / 2, refContainer.y + refContainer.height / 2];\n  }\n  return {\n    type: layoutRefType,\n    refContainer: refContainer,\n    refPoint: refPoint,\n    boxCoordFrom: boxCoordFrom\n  };\n}\n/**\n * Position a zr element in viewport\n *  Group position is specified by either\n *  {left, top}, {right, bottom}\n *  If all properties exists, right and bottom will be igonred.\n *\n * Logic:\n *     1. Scale (against origin point in parent coord)\n *     2. Rotate (against origin point in parent coord)\n *     3. Translate (with el.position by this method)\n * So this method only fixes the last step 'Translate', which does not affect\n * scaling and rotating.\n *\n * If be called repeatedly with the same input el, the same result will be gotten.\n *\n * Return true if the layout happened.\n *\n * @param el Should have `getBoundingRect` method.\n * @param positionInfo\n * @param positionInfo.left\n * @param positionInfo.top\n * @param positionInfo.right\n * @param positionInfo.bottom\n * @param positionInfo.width Only for opt.boundingModel: 'raw'\n * @param positionInfo.height Only for opt.boundingModel: 'raw'\n * @param containerRect\n * @param margin\n * @param opt\n * @param opt.hv Only horizontal or only vertical. Default to be [1, 1]\n * @param opt.boundingMode\n *        Specify how to calculate boundingRect when locating.\n *        'all': Position the boundingRect that is transformed and uioned\n *               both itself and its descendants.\n *               This mode simplies confine the elements in the bounding\n *               of their container (e.g., using 'right: 0').\n *        'raw': Position the boundingRect that is not transformed and only itself.\n *               This mode is useful when you want a element can overflow its\n *               container. (Consider a rotated circle needs to be located in a corner.)\n *               In this mode positionInfo.width/height can only be number.\n */\nexport function positionElement(el, positionInfo, containerRect, margin, opt, out) {\n  var h = !opt || !opt.hv || opt.hv[0];\n  var v = !opt || !opt.hv || opt.hv[1];\n  var boundingMode = opt && opt.boundingMode || 'all';\n  out = out || el;\n  out.x = el.x;\n  out.y = el.y;\n  if (!h && !v) {\n    return false;\n  }\n  var rect;\n  if (boundingMode === 'raw') {\n    rect = el.type === 'group' ? new BoundingRect(0, 0, +positionInfo.width || 0, +positionInfo.height || 0) : el.getBoundingRect();\n  } else {\n    rect = el.getBoundingRect();\n    if (el.needLocalTransform()) {\n      var transform = el.getLocalTransform();\n      // Notice: raw rect may be inner object of el,\n      // which should not be modified.\n      rect = rect.clone();\n      rect.applyTransform(transform);\n    }\n  }\n  // The real width and height can not be specified but calculated by the given el.\n  var layoutRect = getLayoutRect(zrUtil.defaults({\n    width: rect.width,\n    height: rect.height\n  }, positionInfo), containerRect, margin);\n  // Because 'tranlate' is the last step in transform\n  // (see zrender/core/Transformable#getLocalTransform),\n  // we can just only modify el.position to get final result.\n  var dx = h ? layoutRect.x - rect.x : 0;\n  var dy = v ? layoutRect.y - rect.y : 0;\n  if (boundingMode === 'raw') {\n    out.x = dx;\n    out.y = dy;\n  } else {\n    out.x += dx;\n    out.y += dy;\n  }\n  if (out === el) {\n    el.markRedraw();\n  }\n  return true;\n}\n/**\n * @param option Contains some of the properties in HV_NAMES.\n * @param hvIdx 0: horizontal; 1: vertical.\n */\nexport function sizeCalculable(option, hvIdx) {\n  return option[HV_NAMES[hvIdx][0]] != null || option[HV_NAMES[hvIdx][1]] != null && option[HV_NAMES[hvIdx][2]] != null;\n}\nexport function fetchLayoutMode(ins) {\n  var layoutMode = ins.layoutMode || ins.constructor.layoutMode;\n  return zrUtil.isObject(layoutMode) ? layoutMode : layoutMode ? {\n    type: layoutMode\n  } : null;\n}\n/**\n * Consider Case:\n * When default option has {left: 0, width: 100}, and we set {right: 0}\n * through setOption or media query, using normal zrUtil.merge will cause\n * {right: 0} does not take effect.\n *\n * @example\n * ComponentModel.extend({\n *     init: function () {\n *         ...\n *         let inputPositionParams = layout.getLayoutParams(option);\n *         this.mergeOption(inputPositionParams);\n *     },\n *     mergeOption: function (newOption) {\n *         newOption && zrUtil.merge(thisOption, newOption, true);\n *         layout.mergeLayoutParam(thisOption, newOption);\n *     }\n * });\n *\n * @param targetOption\n * @param newOption\n * @param opt\n */\nexport function mergeLayoutParam(targetOption, newOption, opt) {\n  var ignoreSize = opt && opt.ignoreSize;\n  !zrUtil.isArray(ignoreSize) && (ignoreSize = [ignoreSize, ignoreSize]);\n  var hResult = merge(HV_NAMES[0], 0);\n  var vResult = merge(HV_NAMES[1], 1);\n  copy(HV_NAMES[0], targetOption, hResult);\n  copy(HV_NAMES[1], targetOption, vResult);\n  function merge(names, hvIdx) {\n    var newParams = {};\n    var newValueCount = 0;\n    var merged = {};\n    var mergedValueCount = 0;\n    var enoughParamNumber = 2;\n    each(names, function (name) {\n      merged[name] = targetOption[name];\n    });\n    each(names, function (name) {\n      // Consider case: newOption.width is null, which is\n      // set by user for removing width setting.\n      zrUtil.hasOwn(newOption, name) && (newParams[name] = merged[name] = newOption[name]);\n      hasValue(newParams, name) && newValueCount++;\n      hasValue(merged, name) && mergedValueCount++;\n    });\n    if (ignoreSize[hvIdx]) {\n      // Only one of left/right is premitted to exist.\n      if (hasValue(newOption, names[1])) {\n        merged[names[2]] = null;\n      } else if (hasValue(newOption, names[2])) {\n        merged[names[1]] = null;\n      }\n      return merged;\n    }\n    // Case: newOption: {width: ..., right: ...},\n    // or targetOption: {right: ...} and newOption: {width: ...},\n    // There is no conflict when merged only has params count\n    // little than enoughParamNumber.\n    if (mergedValueCount === enoughParamNumber || !newValueCount) {\n      return merged;\n    }\n    // Case: newOption: {width: ..., right: ...},\n    // Than we can make sure user only want those two, and ignore\n    // all origin params in targetOption.\n    else if (newValueCount >= enoughParamNumber) {\n      return newParams;\n    } else {\n      // Chose another param from targetOption by priority.\n      for (var i = 0; i < names.length; i++) {\n        var name_1 = names[i];\n        if (!zrUtil.hasOwn(newParams, name_1) && zrUtil.hasOwn(targetOption, name_1)) {\n          newParams[name_1] = targetOption[name_1];\n          break;\n        }\n      }\n      return newParams;\n    }\n  }\n  function hasValue(obj, name) {\n    return obj[name] != null && obj[name] !== 'auto';\n  }\n  function copy(names, target, source) {\n    each(names, function (name) {\n      target[name] = source[name];\n    });\n  }\n}\n/**\n * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n */\nexport function getLayoutParams(source) {\n  return copyLayoutParams({}, source);\n}\n/**\n * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n * @param {Object} source\n * @return {Object} Result contains those props.\n */\nexport function copyLayoutParams(target, source) {\n  source && target && each(LOCATION_PARAMS, function (name) {\n    zrUtil.hasOwn(source, name) && (target[name] = source[name]);\n  });\n  return target;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
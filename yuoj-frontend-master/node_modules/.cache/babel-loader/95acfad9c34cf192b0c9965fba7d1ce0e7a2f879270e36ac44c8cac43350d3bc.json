{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { OrientedBoundingRect, WH, XY, ensureCopyRect, ensureCopyTransform, expandOrShrinkRect, isBoundingRectAxisAligned } from '../util/graphic.js';\nimport { LabelMarginType } from './labelStyle.js';\nvar LABEL_LAYOUT_BASE_PROPS = ['label', 'labelLine', 'layoutOption', 'priority', 'defaultAttr', 'marginForce', 'minMarginForce', 'marginDefault', 'suggestIgnore'];\nvar LABEL_LAYOUT_DIRTY_BIT_OTHERS = 1;\nvar LABEL_LAYOUT_DIRTY_BIT_OBB = 2;\nvar LABEL_LAYOUT_DIRTY_ALL = LABEL_LAYOUT_DIRTY_BIT_OTHERS | LABEL_LAYOUT_DIRTY_BIT_OBB;\nexport function setLabelLayoutDirty(labelGeometry, dirtyOrClear, dirtyBits) {\n  dirtyBits = dirtyBits || LABEL_LAYOUT_DIRTY_ALL;\n  dirtyOrClear ? labelGeometry.dirty |= dirtyBits : labelGeometry.dirty &= ~dirtyBits;\n}\nfunction isLabelLayoutDirty(labelGeometry, dirtyBits) {\n  dirtyBits = dirtyBits || LABEL_LAYOUT_DIRTY_ALL;\n  return labelGeometry.dirty == null || !!(labelGeometry.dirty & dirtyBits);\n}\n/**\n * [CAUTION]\n *  - No auto dirty propagation mechanism yet. If the transform of the raw label or any of its ancestors is\n *    changed, must sync the changes to the props of `LabelGeometry` by:\n *    either explicitly call:\n *      `setLabelLayoutDirty(labelLayout, true); ensureLabelLayoutWithGeometry(labelLayout);`\n *    or call (if only translation is performed):\n *      `labelLayoutApplyTranslation(labelLayout);`\n *  - `label.ignore` is not necessarily falsy, and not considered in computing `LabelGeometry`,\n *    since it might be modified by some overlap resolving handling.\n *  - To duplicate or make a variation:\n *    use `newLabelLayoutWithGeometry`.\n *\n * The result can also be the input of this method.\n * @return `NullUndefined` if and only if `labelLayout` is `NullUndefined`.\n */\nexport function ensureLabelLayoutWithGeometry(labelLayout) {\n  if (!labelLayout) {\n    return;\n  }\n  if (isLabelLayoutDirty(labelLayout)) {\n    computeLabelGeometry(labelLayout, labelLayout.label, labelLayout);\n  }\n  return labelLayout;\n}\n/**\n * The props in `out` will be filled if existing, or created.\n */\nexport function computeLabelGeometry(out, label, opt) {\n  // [CAUTION] These props may be modified directly for performance consideration,\n  //  therefore, do not output the internal data structure of zrender Element.\n  var rawTransform = label.getComputedTransform();\n  out.transform = ensureCopyTransform(out.transform, rawTransform);\n  // NOTE: should call `getBoundingRect` after `getComputedTransform`, or may get an inaccurate bounding rect.\n  //  The reason is that `getComputedTransform` calls `__host.updateInnerText()` internally, which updates the label\n  //  by `textConfig` mounted on the host.\n  // PENDING: add a dirty bit for that in zrender?\n  var outLocalRect = out.localRect = ensureCopyRect(out.localRect, label.getBoundingRect());\n  var labelStyleExt = label.style;\n  var margin = labelStyleExt.margin;\n  var marginForce = opt && opt.marginForce;\n  var minMarginForce = opt && opt.minMarginForce;\n  var marginDefault = opt && opt.marginDefault;\n  var marginType = labelStyleExt.__marginType;\n  if (marginType == null && marginDefault) {\n    margin = marginDefault;\n    marginType = LabelMarginType.textMargin;\n  }\n  // `textMargin` and `minMargin` can not exist both.\n  for (var i = 0; i < 4; i++) {\n    _tmpLabelMargin[i] = marginType === LabelMarginType.minMargin && minMarginForce && minMarginForce[i] != null ? minMarginForce[i] : marginForce && marginForce[i] != null ? marginForce[i] : margin ? margin[i] : 0;\n  }\n  if (marginType === LabelMarginType.textMargin) {\n    expandOrShrinkRect(outLocalRect, _tmpLabelMargin, false, false);\n  }\n  var outGlobalRect = out.rect = ensureCopyRect(out.rect, outLocalRect);\n  if (rawTransform) {\n    outGlobalRect.applyTransform(rawTransform);\n  }\n  // Notice: label.style.margin is actually `minMargin / 2`, handled by `setTextStyleCommon`.\n  if (marginType === LabelMarginType.minMargin) {\n    expandOrShrinkRect(outGlobalRect, _tmpLabelMargin, false, false);\n  }\n  out.axisAligned = isBoundingRectAxisAligned(rawTransform);\n  (out.label = out.label || {}).ignore = label.ignore;\n  setLabelLayoutDirty(out, false);\n  setLabelLayoutDirty(out, true, LABEL_LAYOUT_DIRTY_BIT_OBB);\n  // Do not remove `obb` (if existing) for reuse, just reset the dirty bit.\n  return out;\n}\nvar _tmpLabelMargin = [0, 0, 0, 0];\n/**\n * The props in `out` will be filled if existing, or created.\n */\nexport function computeLabelGeometry2(out, rawLocalRect, rawTransform) {\n  out.transform = ensureCopyTransform(out.transform, rawTransform);\n  out.localRect = ensureCopyRect(out.localRect, rawLocalRect);\n  out.rect = ensureCopyRect(out.rect, rawLocalRect);\n  if (rawTransform) {\n    out.rect.applyTransform(rawTransform);\n  }\n  out.axisAligned = isBoundingRectAxisAligned(rawTransform);\n  out.obb = undefined; // Reset to undefined, will be created by `ensureOBB` when using.\n  (out.label = out.label || {}).ignore = false;\n  return out;\n}\n/**\n * This is a shortcut of\n *   ```js\n *   labelLayout.label.x = newX;\n *   labelLayout.label.y = newY;\n *   setLabelLayoutDirty(labelLayout, true);\n *   ensureLabelLayoutWithGeometry(labelLayout);\n *   ```\n * and provide better performance in this common case.\n */\nexport function labelLayoutApplyTranslation(labelLayout, offset) {\n  if (!labelLayout) {\n    return;\n  }\n  labelLayout.label.x += offset.x;\n  labelLayout.label.y += offset.y;\n  labelLayout.label.markRedraw();\n  var transform = labelLayout.transform;\n  if (transform) {\n    transform[4] += offset.x;\n    transform[5] += offset.y;\n  }\n  var globalRect = labelLayout.rect;\n  if (globalRect) {\n    globalRect.x += offset.x;\n    globalRect.y += offset.y;\n  }\n  var obb = labelLayout.obb;\n  if (obb) {\n    obb.fromBoundingRect(labelLayout.localRect, transform);\n  }\n}\n/**\n * To duplicate or make a variation of a label layout.\n * Copy the only relevant properties to avoid the conflict or wrongly reuse of the props of `LabelLayoutWithGeometry`.\n */\nexport function newLabelLayoutWithGeometry(newBaseWithDefaults, source) {\n  for (var i = 0; i < LABEL_LAYOUT_BASE_PROPS.length; i++) {\n    var prop = LABEL_LAYOUT_BASE_PROPS[i];\n    if (newBaseWithDefaults[prop] == null) {\n      newBaseWithDefaults[prop] = source[prop];\n    }\n  }\n  return ensureLabelLayoutWithGeometry(newBaseWithDefaults);\n}\n/**\n * Create obb if no one, can cache it.\n */\nfunction ensureOBB(labelGeometry) {\n  var obb = labelGeometry.obb;\n  if (!obb || isLabelLayoutDirty(labelGeometry, LABEL_LAYOUT_DIRTY_BIT_OBB)) {\n    labelGeometry.obb = obb = obb || new OrientedBoundingRect();\n    obb.fromBoundingRect(labelGeometry.localRect, labelGeometry.transform);\n    setLabelLayoutDirty(labelGeometry, false, LABEL_LAYOUT_DIRTY_BIT_OBB);\n  }\n  return obb;\n}\n/**\n * Adjust labels on x/y direction to avoid overlap.\n *\n * PENDING: the current implementation is based on the global bounding rect rather than the local rect,\n *  which may be not preferable in some edge cases when the label has rotation, but works for most cases,\n *  since rotation is unnecessary when there is sufficient space, while squeezing is applied regardless\n *  of overlapping when there is no enough space.\n *\n * NOTICE:\n *  - The input `list` and its content will be modified (sort, label.x/y, rect).\n *  - The caller should sync the modifications to the other parts by\n *    `setLabelLayoutDirty` and `ensureLabelLayoutWithGeometry` if needed.\n *\n * @return adjusted\n */\nexport function shiftLayoutOnXY(list, xyDimIdx,\n// 0 for x, 1 for y\nminBound,\n// for x, leftBound; for y, topBound\nmaxBound,\n// for x, rightBound; for y, bottomBound\n// If average the shifts on all labels and add them to 0\n// TODO: Not sure if should enable it.\n// Pros: The angle of lines will distribute more equally\n// Cons: In some layout. It may not what user wanted. like in pie. the label of last sector is usually changed unexpectedly.\nbalanceShift) {\n  var len = list.length;\n  var xyDim = XY[xyDimIdx];\n  var sizeDim = WH[xyDimIdx];\n  if (len < 2) {\n    return false;\n  }\n  list.sort(function (a, b) {\n    return a.rect[xyDim] - b.rect[xyDim];\n  });\n  var lastPos = 0;\n  var delta;\n  var adjusted = false;\n  // const shifts = [];\n  var totalShifts = 0;\n  for (var i = 0; i < len; i++) {\n    var item = list[i];\n    var rect = item.rect;\n    delta = rect[xyDim] - lastPos;\n    if (delta < 0) {\n      // shiftForward(i, len, -delta);\n      rect[xyDim] -= delta;\n      item.label[xyDim] -= delta;\n      adjusted = true;\n    }\n    var shift = Math.max(-delta, 0);\n    // shifts.push(shift);\n    totalShifts += shift;\n    lastPos = rect[xyDim] + rect[sizeDim];\n  }\n  if (totalShifts > 0 && balanceShift) {\n    // Shift back to make the distribution more equally.\n    shiftList(-totalShifts / len, 0, len);\n  }\n  // TODO bleedMargin?\n  var first = list[0];\n  var last = list[len - 1];\n  var minGap;\n  var maxGap;\n  updateMinMaxGap();\n  // If ends exceed two bounds, squeeze at most 80%, then take the gap of two bounds.\n  minGap < 0 && squeezeGaps(-minGap, 0.8);\n  maxGap < 0 && squeezeGaps(maxGap, 0.8);\n  updateMinMaxGap();\n  takeBoundsGap(minGap, maxGap, 1);\n  takeBoundsGap(maxGap, minGap, -1);\n  // Handle bailout when there is not enough space.\n  updateMinMaxGap();\n  if (minGap < 0) {\n    squeezeWhenBailout(-minGap);\n  }\n  if (maxGap < 0) {\n    squeezeWhenBailout(maxGap);\n  }\n  function updateMinMaxGap() {\n    minGap = first.rect[xyDim] - minBound;\n    maxGap = maxBound - last.rect[xyDim] - last.rect[sizeDim];\n  }\n  function takeBoundsGap(gapThisBound, gapOtherBound, moveDir) {\n    if (gapThisBound < 0) {\n      // Move from other gap if can.\n      var moveFromMaxGap = Math.min(gapOtherBound, -gapThisBound);\n      if (moveFromMaxGap > 0) {\n        shiftList(moveFromMaxGap * moveDir, 0, len);\n        var remained = moveFromMaxGap + gapThisBound;\n        if (remained < 0) {\n          squeezeGaps(-remained * moveDir, 1);\n        }\n      } else {\n        squeezeGaps(-gapThisBound * moveDir, 1);\n      }\n    }\n  }\n  function shiftList(delta, start, end) {\n    if (delta !== 0) {\n      adjusted = true;\n    }\n    for (var i = start; i < end; i++) {\n      var item = list[i];\n      var rect = item.rect;\n      rect[xyDim] += delta;\n      item.label[xyDim] += delta;\n    }\n  }\n  // Squeeze gaps if the labels exceed margin.\n  function squeezeGaps(delta, maxSqeezePercent) {\n    var gaps = [];\n    var totalGaps = 0;\n    for (var i = 1; i < len; i++) {\n      var prevItemRect = list[i - 1].rect;\n      var gap = Math.max(list[i].rect[xyDim] - prevItemRect[xyDim] - prevItemRect[sizeDim], 0);\n      gaps.push(gap);\n      totalGaps += gap;\n    }\n    if (!totalGaps) {\n      return;\n    }\n    var squeezePercent = Math.min(Math.abs(delta) / totalGaps, maxSqeezePercent);\n    if (delta > 0) {\n      for (var i = 0; i < len - 1; i++) {\n        // Distribute the shift delta to all gaps.\n        var movement = gaps[i] * squeezePercent;\n        // Forward\n        shiftList(movement, 0, i + 1);\n      }\n    } else {\n      // Backward\n      for (var i = len - 1; i > 0; i--) {\n        // Distribute the shift delta to all gaps.\n        var movement = gaps[i - 1] * squeezePercent;\n        shiftList(-movement, i, len);\n      }\n    }\n  }\n  /**\n   * Squeeze to allow overlap if there is no more space available.\n   * Let other overlapping strategy like hideOverlap do the job instead of keep exceeding the bounds.\n   */\n  function squeezeWhenBailout(delta) {\n    var dir = delta < 0 ? -1 : 1;\n    delta = Math.abs(delta);\n    var moveForEachLabel = Math.ceil(delta / (len - 1));\n    for (var i = 0; i < len - 1; i++) {\n      if (dir > 0) {\n        // Forward\n        shiftList(moveForEachLabel, 0, i + 1);\n      } else {\n        // Backward\n        shiftList(-moveForEachLabel, len - i - 1, len);\n      }\n      delta -= moveForEachLabel;\n      if (delta <= 0) {\n        return;\n      }\n    }\n  }\n  return adjusted;\n}\n/**\n * @see `SavedLabelAttr` in `LabelManager.ts`\n * @see `hideOverlap`\n */\nexport function restoreIgnore(labelList) {\n  for (var i = 0; i < labelList.length; i++) {\n    var labelItem = labelList[i];\n    var defaultAttr = labelItem.defaultAttr;\n    var labelLine = labelItem.labelLine;\n    labelItem.label.attr('ignore', defaultAttr.ignore);\n    labelLine && labelLine.attr('ignore', defaultAttr.labelGuideIgnore);\n  }\n}\n/**\n * [NOTICE - restore]:\n *  'series:layoutlabels' may be triggered during some shortcut passes, such as zooming in series.graph/geo\n *  (`updateLabelLayout`), where the modified `Element` props should be restorable from `defaultAttr`.\n *  @see `SavedLabelAttr` in `LabelManager.ts`\n *  `restoreIgnore` can be called to perform the restore, if needed.\n *\n * [NOTICE - state]:\n *  Regarding Element's states, this method is only designed for the normal state.\n *  PENDING: although currently this method is effectively called in other states in `updateLabelLayout` case,\n *      the bad case is not noticeable in the zooming scenario.\n */\nexport function hideOverlap(labelList) {\n  var displayedLabels = [];\n  // TODO, render overflow visible first, put in the displayedLabels.\n  labelList.sort(function (a, b) {\n    return (b.suggestIgnore ? 1 : 0) - (a.suggestIgnore ? 1 : 0) || b.priority - a.priority;\n  });\n  function hideEl(el) {\n    if (!el.ignore) {\n      // Show on emphasis.\n      var emphasisState = el.ensureState('emphasis');\n      if (emphasisState.ignore == null) {\n        emphasisState.ignore = false;\n      }\n    }\n    el.ignore = true;\n  }\n  for (var i = 0; i < labelList.length; i++) {\n    var labelItem = ensureLabelLayoutWithGeometry(labelList[i]);\n    // The current `el.ignore` is involved, since some previous overlap\n    // resolving strategies may have set `el.ignore` to true.\n    if (labelItem.label.ignore) {\n      continue;\n    }\n    var label = labelItem.label;\n    var labelLine = labelItem.labelLine;\n    // NOTICE: even when the with/height of globalRect of a label is 0, the label line should\n    // still be displayed, since we should follow the concept of \"truncation\", meaning that\n    // something exists even if it cannot be fully displayed. A visible label line is necessary\n    // to allow users to get a tooltip with label info on hover.\n    var overlapped = false;\n    for (var j = 0; j < displayedLabels.length; j++) {\n      if (labelIntersect(labelItem, displayedLabels[j], null, {\n        touchThreshold: 0.05\n      })) {\n        overlapped = true;\n        break;\n      }\n    }\n    // TODO Callback to determine if this overlap should be handled?\n    if (overlapped) {\n      hideEl(label);\n      labelLine && hideEl(labelLine);\n    } else {\n      displayedLabels.push(labelItem);\n    }\n  }\n}\n/**\n * Enable fast check for performance; use obb if inevitable.\n * If `mtv` is used, `targetLayoutInfo` can be moved based on the values filled into `mtv`.\n *\n * This method is based only on the current `Element` states (regardless of other states).\n * Typically this method (and the entire layout process) is performed in normal state.\n */\nexport function labelIntersect(baseLayoutInfo, targetLayoutInfo, mtv, intersectOpt) {\n  if (!baseLayoutInfo || !targetLayoutInfo) {\n    return false;\n  }\n  if (baseLayoutInfo.label && baseLayoutInfo.label.ignore || targetLayoutInfo.label && targetLayoutInfo.label.ignore) {\n    return false;\n  }\n  // Fast rejection.\n  if (!baseLayoutInfo.rect.intersect(targetLayoutInfo.rect, mtv, intersectOpt)) {\n    return false;\n  }\n  if (baseLayoutInfo.axisAligned && targetLayoutInfo.axisAligned) {\n    return true; // obb is the same as the normal bounding rect.\n  }\n\n  return ensureOBB(baseLayoutInfo).intersect(ensureOBB(targetLayoutInfo), mtv, intersectOpt);\n}","map":{"version":3,"names":["OrientedBoundingRect","WH","XY","ensureCopyRect","ensureCopyTransform","expandOrShrinkRect","isBoundingRectAxisAligned","LabelMarginType","LABEL_LAYOUT_BASE_PROPS","LABEL_LAYOUT_DIRTY_BIT_OTHERS","LABEL_LAYOUT_DIRTY_BIT_OBB","LABEL_LAYOUT_DIRTY_ALL","setLabelLayoutDirty","labelGeometry","dirtyOrClear","dirtyBits","dirty","isLabelLayoutDirty","ensureLabelLayoutWithGeometry","labelLayout","computeLabelGeometry","label","out","opt","rawTransform","getComputedTransform","transform","outLocalRect","localRect","getBoundingRect","labelStyleExt","style","margin","marginForce","minMarginForce","marginDefault","marginType","__marginType","textMargin","i","_tmpLabelMargin","minMargin","outGlobalRect","rect","applyTransform","axisAligned","ignore","computeLabelGeometry2","rawLocalRect","obb","undefined","labelLayoutApplyTranslation","offset","x","y","markRedraw","globalRect","fromBoundingRect","newLabelLayoutWithGeometry","newBaseWithDefaults","source","length","prop","ensureOBB","shiftLayoutOnXY","list","xyDimIdx","minBound","maxBound","balanceShift","len","xyDim","sizeDim","sort","a","b","lastPos","delta","adjusted","totalShifts","item","shift","Math","max","shiftList","first","last","minGap","maxGap","updateMinMaxGap","squeezeGaps","takeBoundsGap","squeezeWhenBailout","gapThisBound","gapOtherBound","moveDir","moveFromMaxGap","min","remained","start","end","maxSqeezePercent","gaps","totalGaps","prevItemRect","gap","push","squeezePercent","abs","movement","dir","moveForEachLabel","ceil","restoreIgnore","labelList","labelItem","defaultAttr","labelLine","attr","labelGuideIgnore","hideOverlap","displayedLabels","suggestIgnore","priority","hideEl","el","emphasisState","ensureState","overlapped","j","labelIntersect","touchThreshold","baseLayoutInfo","targetLayoutInfo","mtv","intersectOpt","intersect"],"sources":["D:/code/java/program/oj/code/yuoj-frontend-master/node_modules/echarts/lib/label/labelLayoutHelper.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { OrientedBoundingRect, WH, XY, ensureCopyRect, ensureCopyTransform, expandOrShrinkRect, isBoundingRectAxisAligned } from '../util/graphic.js';\nimport { LabelMarginType } from './labelStyle.js';\nvar LABEL_LAYOUT_BASE_PROPS = ['label', 'labelLine', 'layoutOption', 'priority', 'defaultAttr', 'marginForce', 'minMarginForce', 'marginDefault', 'suggestIgnore'];\nvar LABEL_LAYOUT_DIRTY_BIT_OTHERS = 1;\nvar LABEL_LAYOUT_DIRTY_BIT_OBB = 2;\nvar LABEL_LAYOUT_DIRTY_ALL = LABEL_LAYOUT_DIRTY_BIT_OTHERS | LABEL_LAYOUT_DIRTY_BIT_OBB;\nexport function setLabelLayoutDirty(labelGeometry, dirtyOrClear, dirtyBits) {\n  dirtyBits = dirtyBits || LABEL_LAYOUT_DIRTY_ALL;\n  dirtyOrClear ? labelGeometry.dirty |= dirtyBits : labelGeometry.dirty &= ~dirtyBits;\n}\nfunction isLabelLayoutDirty(labelGeometry, dirtyBits) {\n  dirtyBits = dirtyBits || LABEL_LAYOUT_DIRTY_ALL;\n  return labelGeometry.dirty == null || !!(labelGeometry.dirty & dirtyBits);\n}\n/**\n * [CAUTION]\n *  - No auto dirty propagation mechanism yet. If the transform of the raw label or any of its ancestors is\n *    changed, must sync the changes to the props of `LabelGeometry` by:\n *    either explicitly call:\n *      `setLabelLayoutDirty(labelLayout, true); ensureLabelLayoutWithGeometry(labelLayout);`\n *    or call (if only translation is performed):\n *      `labelLayoutApplyTranslation(labelLayout);`\n *  - `label.ignore` is not necessarily falsy, and not considered in computing `LabelGeometry`,\n *    since it might be modified by some overlap resolving handling.\n *  - To duplicate or make a variation:\n *    use `newLabelLayoutWithGeometry`.\n *\n * The result can also be the input of this method.\n * @return `NullUndefined` if and only if `labelLayout` is `NullUndefined`.\n */\nexport function ensureLabelLayoutWithGeometry(labelLayout) {\n  if (!labelLayout) {\n    return;\n  }\n  if (isLabelLayoutDirty(labelLayout)) {\n    computeLabelGeometry(labelLayout, labelLayout.label, labelLayout);\n  }\n  return labelLayout;\n}\n/**\n * The props in `out` will be filled if existing, or created.\n */\nexport function computeLabelGeometry(out, label, opt) {\n  // [CAUTION] These props may be modified directly for performance consideration,\n  //  therefore, do not output the internal data structure of zrender Element.\n  var rawTransform = label.getComputedTransform();\n  out.transform = ensureCopyTransform(out.transform, rawTransform);\n  // NOTE: should call `getBoundingRect` after `getComputedTransform`, or may get an inaccurate bounding rect.\n  //  The reason is that `getComputedTransform` calls `__host.updateInnerText()` internally, which updates the label\n  //  by `textConfig` mounted on the host.\n  // PENDING: add a dirty bit for that in zrender?\n  var outLocalRect = out.localRect = ensureCopyRect(out.localRect, label.getBoundingRect());\n  var labelStyleExt = label.style;\n  var margin = labelStyleExt.margin;\n  var marginForce = opt && opt.marginForce;\n  var minMarginForce = opt && opt.minMarginForce;\n  var marginDefault = opt && opt.marginDefault;\n  var marginType = labelStyleExt.__marginType;\n  if (marginType == null && marginDefault) {\n    margin = marginDefault;\n    marginType = LabelMarginType.textMargin;\n  }\n  // `textMargin` and `minMargin` can not exist both.\n  for (var i = 0; i < 4; i++) {\n    _tmpLabelMargin[i] = marginType === LabelMarginType.minMargin && minMarginForce && minMarginForce[i] != null ? minMarginForce[i] : marginForce && marginForce[i] != null ? marginForce[i] : margin ? margin[i] : 0;\n  }\n  if (marginType === LabelMarginType.textMargin) {\n    expandOrShrinkRect(outLocalRect, _tmpLabelMargin, false, false);\n  }\n  var outGlobalRect = out.rect = ensureCopyRect(out.rect, outLocalRect);\n  if (rawTransform) {\n    outGlobalRect.applyTransform(rawTransform);\n  }\n  // Notice: label.style.margin is actually `minMargin / 2`, handled by `setTextStyleCommon`.\n  if (marginType === LabelMarginType.minMargin) {\n    expandOrShrinkRect(outGlobalRect, _tmpLabelMargin, false, false);\n  }\n  out.axisAligned = isBoundingRectAxisAligned(rawTransform);\n  (out.label = out.label || {}).ignore = label.ignore;\n  setLabelLayoutDirty(out, false);\n  setLabelLayoutDirty(out, true, LABEL_LAYOUT_DIRTY_BIT_OBB);\n  // Do not remove `obb` (if existing) for reuse, just reset the dirty bit.\n  return out;\n}\nvar _tmpLabelMargin = [0, 0, 0, 0];\n/**\n * The props in `out` will be filled if existing, or created.\n */\nexport function computeLabelGeometry2(out, rawLocalRect, rawTransform) {\n  out.transform = ensureCopyTransform(out.transform, rawTransform);\n  out.localRect = ensureCopyRect(out.localRect, rawLocalRect);\n  out.rect = ensureCopyRect(out.rect, rawLocalRect);\n  if (rawTransform) {\n    out.rect.applyTransform(rawTransform);\n  }\n  out.axisAligned = isBoundingRectAxisAligned(rawTransform);\n  out.obb = undefined; // Reset to undefined, will be created by `ensureOBB` when using.\n  (out.label = out.label || {}).ignore = false;\n  return out;\n}\n/**\n * This is a shortcut of\n *   ```js\n *   labelLayout.label.x = newX;\n *   labelLayout.label.y = newY;\n *   setLabelLayoutDirty(labelLayout, true);\n *   ensureLabelLayoutWithGeometry(labelLayout);\n *   ```\n * and provide better performance in this common case.\n */\nexport function labelLayoutApplyTranslation(labelLayout, offset) {\n  if (!labelLayout) {\n    return;\n  }\n  labelLayout.label.x += offset.x;\n  labelLayout.label.y += offset.y;\n  labelLayout.label.markRedraw();\n  var transform = labelLayout.transform;\n  if (transform) {\n    transform[4] += offset.x;\n    transform[5] += offset.y;\n  }\n  var globalRect = labelLayout.rect;\n  if (globalRect) {\n    globalRect.x += offset.x;\n    globalRect.y += offset.y;\n  }\n  var obb = labelLayout.obb;\n  if (obb) {\n    obb.fromBoundingRect(labelLayout.localRect, transform);\n  }\n}\n/**\n * To duplicate or make a variation of a label layout.\n * Copy the only relevant properties to avoid the conflict or wrongly reuse of the props of `LabelLayoutWithGeometry`.\n */\nexport function newLabelLayoutWithGeometry(newBaseWithDefaults, source) {\n  for (var i = 0; i < LABEL_LAYOUT_BASE_PROPS.length; i++) {\n    var prop = LABEL_LAYOUT_BASE_PROPS[i];\n    if (newBaseWithDefaults[prop] == null) {\n      newBaseWithDefaults[prop] = source[prop];\n    }\n  }\n  return ensureLabelLayoutWithGeometry(newBaseWithDefaults);\n}\n/**\n * Create obb if no one, can cache it.\n */\nfunction ensureOBB(labelGeometry) {\n  var obb = labelGeometry.obb;\n  if (!obb || isLabelLayoutDirty(labelGeometry, LABEL_LAYOUT_DIRTY_BIT_OBB)) {\n    labelGeometry.obb = obb = obb || new OrientedBoundingRect();\n    obb.fromBoundingRect(labelGeometry.localRect, labelGeometry.transform);\n    setLabelLayoutDirty(labelGeometry, false, LABEL_LAYOUT_DIRTY_BIT_OBB);\n  }\n  return obb;\n}\n/**\n * Adjust labels on x/y direction to avoid overlap.\n *\n * PENDING: the current implementation is based on the global bounding rect rather than the local rect,\n *  which may be not preferable in some edge cases when the label has rotation, but works for most cases,\n *  since rotation is unnecessary when there is sufficient space, while squeezing is applied regardless\n *  of overlapping when there is no enough space.\n *\n * NOTICE:\n *  - The input `list` and its content will be modified (sort, label.x/y, rect).\n *  - The caller should sync the modifications to the other parts by\n *    `setLabelLayoutDirty` and `ensureLabelLayoutWithGeometry` if needed.\n *\n * @return adjusted\n */\nexport function shiftLayoutOnXY(list, xyDimIdx,\n// 0 for x, 1 for y\nminBound,\n// for x, leftBound; for y, topBound\nmaxBound,\n// for x, rightBound; for y, bottomBound\n// If average the shifts on all labels and add them to 0\n// TODO: Not sure if should enable it.\n// Pros: The angle of lines will distribute more equally\n// Cons: In some layout. It may not what user wanted. like in pie. the label of last sector is usually changed unexpectedly.\nbalanceShift) {\n  var len = list.length;\n  var xyDim = XY[xyDimIdx];\n  var sizeDim = WH[xyDimIdx];\n  if (len < 2) {\n    return false;\n  }\n  list.sort(function (a, b) {\n    return a.rect[xyDim] - b.rect[xyDim];\n  });\n  var lastPos = 0;\n  var delta;\n  var adjusted = false;\n  // const shifts = [];\n  var totalShifts = 0;\n  for (var i = 0; i < len; i++) {\n    var item = list[i];\n    var rect = item.rect;\n    delta = rect[xyDim] - lastPos;\n    if (delta < 0) {\n      // shiftForward(i, len, -delta);\n      rect[xyDim] -= delta;\n      item.label[xyDim] -= delta;\n      adjusted = true;\n    }\n    var shift = Math.max(-delta, 0);\n    // shifts.push(shift);\n    totalShifts += shift;\n    lastPos = rect[xyDim] + rect[sizeDim];\n  }\n  if (totalShifts > 0 && balanceShift) {\n    // Shift back to make the distribution more equally.\n    shiftList(-totalShifts / len, 0, len);\n  }\n  // TODO bleedMargin?\n  var first = list[0];\n  var last = list[len - 1];\n  var minGap;\n  var maxGap;\n  updateMinMaxGap();\n  // If ends exceed two bounds, squeeze at most 80%, then take the gap of two bounds.\n  minGap < 0 && squeezeGaps(-minGap, 0.8);\n  maxGap < 0 && squeezeGaps(maxGap, 0.8);\n  updateMinMaxGap();\n  takeBoundsGap(minGap, maxGap, 1);\n  takeBoundsGap(maxGap, minGap, -1);\n  // Handle bailout when there is not enough space.\n  updateMinMaxGap();\n  if (minGap < 0) {\n    squeezeWhenBailout(-minGap);\n  }\n  if (maxGap < 0) {\n    squeezeWhenBailout(maxGap);\n  }\n  function updateMinMaxGap() {\n    minGap = first.rect[xyDim] - minBound;\n    maxGap = maxBound - last.rect[xyDim] - last.rect[sizeDim];\n  }\n  function takeBoundsGap(gapThisBound, gapOtherBound, moveDir) {\n    if (gapThisBound < 0) {\n      // Move from other gap if can.\n      var moveFromMaxGap = Math.min(gapOtherBound, -gapThisBound);\n      if (moveFromMaxGap > 0) {\n        shiftList(moveFromMaxGap * moveDir, 0, len);\n        var remained = moveFromMaxGap + gapThisBound;\n        if (remained < 0) {\n          squeezeGaps(-remained * moveDir, 1);\n        }\n      } else {\n        squeezeGaps(-gapThisBound * moveDir, 1);\n      }\n    }\n  }\n  function shiftList(delta, start, end) {\n    if (delta !== 0) {\n      adjusted = true;\n    }\n    for (var i = start; i < end; i++) {\n      var item = list[i];\n      var rect = item.rect;\n      rect[xyDim] += delta;\n      item.label[xyDim] += delta;\n    }\n  }\n  // Squeeze gaps if the labels exceed margin.\n  function squeezeGaps(delta, maxSqeezePercent) {\n    var gaps = [];\n    var totalGaps = 0;\n    for (var i = 1; i < len; i++) {\n      var prevItemRect = list[i - 1].rect;\n      var gap = Math.max(list[i].rect[xyDim] - prevItemRect[xyDim] - prevItemRect[sizeDim], 0);\n      gaps.push(gap);\n      totalGaps += gap;\n    }\n    if (!totalGaps) {\n      return;\n    }\n    var squeezePercent = Math.min(Math.abs(delta) / totalGaps, maxSqeezePercent);\n    if (delta > 0) {\n      for (var i = 0; i < len - 1; i++) {\n        // Distribute the shift delta to all gaps.\n        var movement = gaps[i] * squeezePercent;\n        // Forward\n        shiftList(movement, 0, i + 1);\n      }\n    } else {\n      // Backward\n      for (var i = len - 1; i > 0; i--) {\n        // Distribute the shift delta to all gaps.\n        var movement = gaps[i - 1] * squeezePercent;\n        shiftList(-movement, i, len);\n      }\n    }\n  }\n  /**\n   * Squeeze to allow overlap if there is no more space available.\n   * Let other overlapping strategy like hideOverlap do the job instead of keep exceeding the bounds.\n   */\n  function squeezeWhenBailout(delta) {\n    var dir = delta < 0 ? -1 : 1;\n    delta = Math.abs(delta);\n    var moveForEachLabel = Math.ceil(delta / (len - 1));\n    for (var i = 0; i < len - 1; i++) {\n      if (dir > 0) {\n        // Forward\n        shiftList(moveForEachLabel, 0, i + 1);\n      } else {\n        // Backward\n        shiftList(-moveForEachLabel, len - i - 1, len);\n      }\n      delta -= moveForEachLabel;\n      if (delta <= 0) {\n        return;\n      }\n    }\n  }\n  return adjusted;\n}\n/**\n * @see `SavedLabelAttr` in `LabelManager.ts`\n * @see `hideOverlap`\n */\nexport function restoreIgnore(labelList) {\n  for (var i = 0; i < labelList.length; i++) {\n    var labelItem = labelList[i];\n    var defaultAttr = labelItem.defaultAttr;\n    var labelLine = labelItem.labelLine;\n    labelItem.label.attr('ignore', defaultAttr.ignore);\n    labelLine && labelLine.attr('ignore', defaultAttr.labelGuideIgnore);\n  }\n}\n/**\n * [NOTICE - restore]:\n *  'series:layoutlabels' may be triggered during some shortcut passes, such as zooming in series.graph/geo\n *  (`updateLabelLayout`), where the modified `Element` props should be restorable from `defaultAttr`.\n *  @see `SavedLabelAttr` in `LabelManager.ts`\n *  `restoreIgnore` can be called to perform the restore, if needed.\n *\n * [NOTICE - state]:\n *  Regarding Element's states, this method is only designed for the normal state.\n *  PENDING: although currently this method is effectively called in other states in `updateLabelLayout` case,\n *      the bad case is not noticeable in the zooming scenario.\n */\nexport function hideOverlap(labelList) {\n  var displayedLabels = [];\n  // TODO, render overflow visible first, put in the displayedLabels.\n  labelList.sort(function (a, b) {\n    return (b.suggestIgnore ? 1 : 0) - (a.suggestIgnore ? 1 : 0) || b.priority - a.priority;\n  });\n  function hideEl(el) {\n    if (!el.ignore) {\n      // Show on emphasis.\n      var emphasisState = el.ensureState('emphasis');\n      if (emphasisState.ignore == null) {\n        emphasisState.ignore = false;\n      }\n    }\n    el.ignore = true;\n  }\n  for (var i = 0; i < labelList.length; i++) {\n    var labelItem = ensureLabelLayoutWithGeometry(labelList[i]);\n    // The current `el.ignore` is involved, since some previous overlap\n    // resolving strategies may have set `el.ignore` to true.\n    if (labelItem.label.ignore) {\n      continue;\n    }\n    var label = labelItem.label;\n    var labelLine = labelItem.labelLine;\n    // NOTICE: even when the with/height of globalRect of a label is 0, the label line should\n    // still be displayed, since we should follow the concept of \"truncation\", meaning that\n    // something exists even if it cannot be fully displayed. A visible label line is necessary\n    // to allow users to get a tooltip with label info on hover.\n    var overlapped = false;\n    for (var j = 0; j < displayedLabels.length; j++) {\n      if (labelIntersect(labelItem, displayedLabels[j], null, {\n        touchThreshold: 0.05\n      })) {\n        overlapped = true;\n        break;\n      }\n    }\n    // TODO Callback to determine if this overlap should be handled?\n    if (overlapped) {\n      hideEl(label);\n      labelLine && hideEl(labelLine);\n    } else {\n      displayedLabels.push(labelItem);\n    }\n  }\n}\n/**\n * Enable fast check for performance; use obb if inevitable.\n * If `mtv` is used, `targetLayoutInfo` can be moved based on the values filled into `mtv`.\n *\n * This method is based only on the current `Element` states (regardless of other states).\n * Typically this method (and the entire layout process) is performed in normal state.\n */\nexport function labelIntersect(baseLayoutInfo, targetLayoutInfo, mtv, intersectOpt) {\n  if (!baseLayoutInfo || !targetLayoutInfo) {\n    return false;\n  }\n  if (baseLayoutInfo.label && baseLayoutInfo.label.ignore || targetLayoutInfo.label && targetLayoutInfo.label.ignore) {\n    return false;\n  }\n  // Fast rejection.\n  if (!baseLayoutInfo.rect.intersect(targetLayoutInfo.rect, mtv, intersectOpt)) {\n    return false;\n  }\n  if (baseLayoutInfo.axisAligned && targetLayoutInfo.axisAligned) {\n    return true; // obb is the same as the normal bounding rect.\n  }\n  return ensureOBB(baseLayoutInfo).intersect(ensureOBB(targetLayoutInfo), mtv, intersectOpt);\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
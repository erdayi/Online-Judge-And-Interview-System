{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport * as pathTool from 'zrender/lib/tool/path.js';\nimport * as matrix from 'zrender/lib/core/matrix.js';\nimport * as vector from 'zrender/lib/core/vector.js';\nimport Path from 'zrender/lib/graphic/Path.js';\nimport Transformable from 'zrender/lib/core/Transformable.js';\nimport ZRImage from 'zrender/lib/graphic/Image.js';\nimport Group from 'zrender/lib/graphic/Group.js';\nimport ZRText from 'zrender/lib/graphic/Text.js';\nimport Circle from 'zrender/lib/graphic/shape/Circle.js';\nimport Ellipse from 'zrender/lib/graphic/shape/Ellipse.js';\nimport Sector from 'zrender/lib/graphic/shape/Sector.js';\nimport Ring from 'zrender/lib/graphic/shape/Ring.js';\nimport Polygon from 'zrender/lib/graphic/shape/Polygon.js';\nimport Polyline from 'zrender/lib/graphic/shape/Polyline.js';\nimport Rect from 'zrender/lib/graphic/shape/Rect.js';\nimport Line from 'zrender/lib/graphic/shape/Line.js';\nimport BezierCurve from 'zrender/lib/graphic/shape/BezierCurve.js';\nimport Arc from 'zrender/lib/graphic/shape/Arc.js';\nimport CompoundPath from 'zrender/lib/graphic/CompoundPath.js';\nimport LinearGradient from 'zrender/lib/graphic/LinearGradient.js';\nimport RadialGradient from 'zrender/lib/graphic/RadialGradient.js';\nimport BoundingRect from 'zrender/lib/core/BoundingRect.js';\nimport OrientedBoundingRect from 'zrender/lib/core/OrientedBoundingRect.js';\nimport Point from 'zrender/lib/core/Point.js';\nimport IncrementalDisplayable from 'zrender/lib/graphic/IncrementalDisplayable.js';\nimport * as subPixelOptimizeUtil from 'zrender/lib/graphic/helper/subPixelOptimize.js';\nimport { extend, isArrayLike, map, defaults, isString, keys, each, hasOwn, isArray, isNumber, clone, assert } from 'zrender/lib/core/util.js';\nimport { getECData } from './innerStore.js';\nimport { updateProps, initProps, removeElement, removeElementWithFadeOut, isElementRemoved } from '../animation/basicTransition.js';\nimport { mathMin, mathMax, mathAbs } from './number.js';\n/**\n * @deprecated export for compatitable reason\n */\nexport { updateProps, initProps, removeElement, removeElementWithFadeOut, isElementRemoved };\nvar _customShapeMap = {};\nexport var XY = ['x', 'y'];\nexport var WH = ['width', 'height'];\n/**\n * Extend shape with parameters\n */\nexport function extendShape(opts) {\n  return Path.extend(opts);\n}\nvar extendPathFromString = pathTool.extendFromString;\n/**\n * Extend path\n */\nexport function extendPath(pathData, opts) {\n  return extendPathFromString(pathData, opts);\n}\n/**\n * Register a user defined shape.\n * The shape class can be fetched by `getShapeClass`\n * This method will overwrite the registered shapes, including\n * the registered built-in shapes, if using the same `name`.\n * The shape can be used in `custom series` and\n * `graphic component` by declaring `{type: name}`.\n *\n * @param name\n * @param ShapeClass Can be generated by `extendShape`.\n */\nexport function registerShape(name, ShapeClass) {\n  _customShapeMap[name] = ShapeClass;\n}\n/**\n * Find shape class registered by `registerShape`. Usually used in\n * fetching user defined shape.\n *\n * [Caution]:\n * (1) This method **MUST NOT be used inside echarts !!!**, unless it is prepared\n * to use user registered shapes.\n * Because the built-in shape (see `getBuiltInShape`) will be registered by\n * `registerShape` by default. That enables users to get both built-in\n * shapes as well as the shapes belonging to themsleves. But users can overwrite\n * the built-in shapes by using names like 'circle', 'rect' via calling\n * `registerShape`. So the echarts inner featrues should not fetch shapes from here\n * in case that it is overwritten by users, except that some features, like\n * `custom series`, `graphic component`, do it deliberately.\n *\n * (2) In the features like `custom series`, `graphic component`, the user input\n * `{tpye: 'xxx'}` does not only specify shapes but also specify other graphic\n * elements like `'group'`, `'text'`, `'image'` or event `'path'`. Those names\n * are reserved names, that is, if some user registers a shape named `'image'`,\n * the shape will not be used. If we intending to add some more reserved names\n * in feature, that might bring break changes (disable some existing user shape\n * names). But that case probably rarely happens. So we don't make more mechanism\n * to resolve this issue here.\n *\n * @param name\n * @return The shape class. If not found, return nothing.\n */\nexport function getShapeClass(name) {\n  if (_customShapeMap.hasOwnProperty(name)) {\n    return _customShapeMap[name];\n  }\n}\n/**\n * Create a path element from path data string\n * @param pathData\n * @param opts\n * @param rect\n * @param layout 'center' or 'cover' default to be cover\n */\nexport function makePath(pathData, opts, rect, layout) {\n  var path = pathTool.createFromString(pathData, opts);\n  if (rect) {\n    if (layout === 'center') {\n      rect = centerGraphic(rect, path.getBoundingRect());\n    }\n    resizePath(path, rect);\n  }\n  return path;\n}\n/**\n * Create a image element from image url\n * @param imageUrl image url\n * @param opts options\n * @param rect constrain rect\n * @param layout 'center' or 'cover'. Default to be 'cover'\n */\nexport function makeImage(imageUrl, rect, layout) {\n  var zrImg = new ZRImage({\n    style: {\n      image: imageUrl,\n      x: rect.x,\n      y: rect.y,\n      width: rect.width,\n      height: rect.height\n    },\n    onload: function (img) {\n      if (layout === 'center') {\n        var boundingRect = {\n          width: img.width,\n          height: img.height\n        };\n        zrImg.setStyle(centerGraphic(rect, boundingRect));\n      }\n    }\n  });\n  return zrImg;\n}\n/**\n * Get position of centered element in bounding box.\n *\n * @param  rect         element local bounding box\n * @param  boundingRect constraint bounding box\n * @return element position containing x, y, width, and height\n */\nfunction centerGraphic(rect, boundingRect) {\n  // Set rect to center, keep width / height ratio.\n  var aspect = boundingRect.width / boundingRect.height;\n  var width = rect.height * aspect;\n  var height;\n  if (width <= rect.width) {\n    height = rect.height;\n  } else {\n    width = rect.width;\n    height = width / aspect;\n  }\n  var cx = rect.x + rect.width / 2;\n  var cy = rect.y + rect.height / 2;\n  return {\n    x: cx - width / 2,\n    y: cy - height / 2,\n    width: width,\n    height: height\n  };\n}\nexport var mergePath = pathTool.mergePath;\n/**\n * Resize a path to fit the rect\n * @param path\n * @param rect\n */\nexport function resizePath(path, rect) {\n  if (!path.applyTransform) {\n    return;\n  }\n  var pathRect = path.getBoundingRect();\n  var m = pathRect.calculateTransform(rect);\n  path.applyTransform(m);\n}\n/**\n * Sub pixel optimize line for canvas\n */\nexport function subPixelOptimizeLine(shape, lineWidth) {\n  subPixelOptimizeUtil.subPixelOptimizeLine(shape, shape, {\n    lineWidth: lineWidth\n  });\n  return shape;\n}\n/**\n * Sub pixel optimize rect for canvas\n */\nexport function subPixelOptimizeRect(shape, style) {\n  subPixelOptimizeUtil.subPixelOptimizeRect(shape, shape, style);\n  return shape;\n}\n/**\n * Sub pixel optimize for canvas\n *\n * @param position Coordinate, such as x, y\n * @param lineWidth Should be nonnegative integer.\n * @param positiveOrNegative Default false (negative).\n * @return Optimized position.\n */\nexport var subPixelOptimize = subPixelOptimizeUtil.subPixelOptimize;\n/**\n * Get transform matrix of target (param target),\n * in coordinate of its ancestor (param ancestor)\n *\n * @param target\n * @param [ancestor]\n */\nexport function getTransform(target, ancestor) {\n  var mat = matrix.identity([]);\n  while (target && target !== ancestor) {\n    matrix.mul(mat, target.getLocalTransform(), mat);\n    target = target.parent;\n  }\n  return mat;\n}\n/**\n * Apply transform to an vertex.\n * @param target [x, y]\n * @param transform Can be:\n *      + Transform matrix: like [1, 0, 0, 1, 0, 0]\n *      + {position, rotation, scale}, the same as `zrender/Transformable`.\n * @param invert Whether use invert matrix.\n * @return [x, y]\n */\nexport function applyTransform(target, transform, invert) {\n  if (transform && !isArrayLike(transform)) {\n    transform = Transformable.getLocalTransform(transform);\n  }\n  if (invert) {\n    transform = matrix.invert([], transform);\n  }\n  return vector.applyTransform([], target, transform);\n}\n/**\n * @param direction 'left' 'right' 'top' 'bottom'\n * @param transform Transform matrix: like [1, 0, 0, 1, 0, 0]\n * @param invert Whether use invert matrix.\n * @return Transformed direction. 'left' 'right' 'top' 'bottom'\n */\nexport function transformDirection(direction, transform, invert) {\n  // Pick a base, ensure that transform result will not be (0, 0).\n  var hBase = transform[4] === 0 || transform[5] === 0 || transform[0] === 0 ? 1 : mathAbs(2 * transform[4] / transform[0]);\n  var vBase = transform[4] === 0 || transform[5] === 0 || transform[2] === 0 ? 1 : mathAbs(2 * transform[4] / transform[2]);\n  var vertex = [direction === 'left' ? -hBase : direction === 'right' ? hBase : 0, direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0];\n  vertex = applyTransform(vertex, transform, invert);\n  return mathAbs(vertex[0]) > mathAbs(vertex[1]) ? vertex[0] > 0 ? 'right' : 'left' : vertex[1] > 0 ? 'bottom' : 'top';\n}\nfunction isNotGroup(el) {\n  return !el.isGroup;\n}\nfunction isPath(el) {\n  return el.shape != null;\n}\n/**\n * Apply group transition animation from g1 to g2.\n * If no animatableModel, no animation.\n */\nexport function groupTransition(g1, g2, animatableModel) {\n  if (!g1 || !g2) {\n    return;\n  }\n  function getElMap(g) {\n    var elMap = {};\n    g.traverse(function (el) {\n      if (isNotGroup(el) && el.anid) {\n        elMap[el.anid] = el;\n      }\n    });\n    return elMap;\n  }\n  function getAnimatableProps(el) {\n    var obj = {\n      x: el.x,\n      y: el.y,\n      rotation: el.rotation\n    };\n    if (isPath(el)) {\n      obj.shape = clone(el.shape);\n    }\n    return obj;\n  }\n  var elMap1 = getElMap(g1);\n  g2.traverse(function (el) {\n    if (isNotGroup(el) && el.anid) {\n      var oldEl = elMap1[el.anid];\n      if (oldEl) {\n        var newProp = getAnimatableProps(el);\n        el.attr(getAnimatableProps(oldEl));\n        updateProps(el, newProp, animatableModel, getECData(el).dataIndex);\n      }\n    }\n  });\n}\nexport function clipPointsByRect(points, rect) {\n  // FIXME: This way might be incorrect when graphic clipped by a corner\n  // and when element has a border.\n  return map(points, function (point) {\n    var x = point[0];\n    x = mathMax(x, rect.x);\n    x = mathMin(x, rect.x + rect.width);\n    var y = point[1];\n    y = mathMax(y, rect.y);\n    y = mathMin(y, rect.y + rect.height);\n    return [x, y];\n  });\n}\n/**\n * Return a new clipped rect. If rect size are negative, return undefined.\n */\nexport function clipRectByRect(targetRect, rect) {\n  var x = mathMax(targetRect.x, rect.x);\n  var x2 = mathMin(targetRect.x + targetRect.width, rect.x + rect.width);\n  var y = mathMax(targetRect.y, rect.y);\n  var y2 = mathMin(targetRect.y + targetRect.height, rect.y + rect.height);\n  // If the total rect is cliped, nothing, including the border,\n  // should be painted. So return undefined.\n  if (x2 >= x && y2 >= y) {\n    return {\n      x: x,\n      y: y,\n      width: x2 - x,\n      height: y2 - y\n    };\n  }\n}\nexport function createIcon(iconStr,\n// Support 'image://' or 'path://' or direct svg path.\nopt, rect) {\n  var innerOpts = extend({\n    rectHover: true\n  }, opt);\n  var style = innerOpts.style = {\n    strokeNoScale: true\n  };\n  rect = rect || {\n    x: -1,\n    y: -1,\n    width: 2,\n    height: 2\n  };\n  if (iconStr) {\n    return iconStr.indexOf('image://') === 0 ? (style.image = iconStr.slice(8), defaults(style, rect), new ZRImage(innerOpts)) : makePath(iconStr.replace('path://', ''), innerOpts, rect, 'center');\n  }\n}\n/**\n * Return `true` if the given line (line `a`) and the given polygon\n * are intersect.\n * Note that we do not count colinear as intersect here because no\n * requirement for that. We could do that if required in future.\n */\nexport function linePolygonIntersect(a1x, a1y, a2x, a2y, points) {\n  for (var i = 0, p2 = points[points.length - 1]; i < points.length; i++) {\n    var p = points[i];\n    if (lineLineIntersect(a1x, a1y, a2x, a2y, p[0], p[1], p2[0], p2[1])) {\n      return true;\n    }\n    p2 = p;\n  }\n}\n/**\n * Return `true` if the given two lines (line `a` and line `b`)\n * are intersect.\n * Note that we do not count colinear as intersect here because no\n * requirement for that. We could do that if required in future.\n */\nexport function lineLineIntersect(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y) {\n  // let `vec_m` to be `vec_a2 - vec_a1` and `vec_n` to be `vec_b2 - vec_b1`.\n  var mx = a2x - a1x;\n  var my = a2y - a1y;\n  var nx = b2x - b1x;\n  var ny = b2y - b1y;\n  // `vec_m` and `vec_n` are parallel iff\n  //     existing `k` such that `vec_m = k · vec_n`, equivalent to `vec_m X vec_n = 0`.\n  var nmCrossProduct = crossProduct2d(nx, ny, mx, my);\n  if (nearZero(nmCrossProduct)) {\n    return false;\n  }\n  // `vec_m` and `vec_n` are intersect iff\n  //     existing `p` and `q` in [0, 1] such that `vec_a1 + p * vec_m = vec_b1 + q * vec_n`,\n  //     such that `q = ((vec_a1 - vec_b1) X vec_m) / (vec_n X vec_m)`\n  //           and `p = ((vec_a1 - vec_b1) X vec_n) / (vec_n X vec_m)`.\n  var b1a1x = a1x - b1x;\n  var b1a1y = a1y - b1y;\n  var q = crossProduct2d(b1a1x, b1a1y, mx, my) / nmCrossProduct;\n  if (q < 0 || q > 1) {\n    return false;\n  }\n  var p = crossProduct2d(b1a1x, b1a1y, nx, ny) / nmCrossProduct;\n  if (p < 0 || p > 1) {\n    return false;\n  }\n  return true;\n}\n/**\n * Cross product of 2-dimension vector.\n */\nfunction crossProduct2d(x1, y1, x2, y2) {\n  return x1 * y2 - x2 * y1;\n}\nfunction nearZero(val) {\n  return val <= 1e-6 && val >= -1e-6;\n}\n/**\n * NOTE:\n *  A negative-width/height rect (due to negative margins) is not supported;\n *  it will be clampped to zero width/height.\n *  Although negative-width/height rects can be defined reasonably following the\n *  similar sense in CSS, but they are rarely used, hard to understand and complicated.\n *\n * @param rect Assume its width/height >= 0 if existing.\n *  x/y/width/height is allowed to be NaN,\n *  for the case that only x/width or y/height is intended to be computed.\n * @param delta\n *  If be `number[]`, should be `[top, right, bottom, left]`,\n *      which can be used in padding or margin case.\n *      @see `normalizeCssArray` in `util/format.ts`\n *  If be `number`, it means [delta, delta, delta, delta],\n *      which can be used in lineWidth (borderWith) case,\n *      [NOTICE]: commonly pass lineWidth / 2, following the convention that border is\n *      half inside half outside of the rect.\n * @param shrinkOrExpand\n *  `true` - shrink if `delta[i]` is positive, commmonly used in `padding` case.\n *  `false` - expand if `delta[i]` is positive, commmonly used in `margin` case. (default)\n * @param noNegative\n *  `true` - negative `delta[i]` will be clampped to 0.\n *  `false` - No clamp to `delta`. (default).\n * @return The input `rect`.\n */\nexport function expandOrShrinkRect(rect, delta, shrinkOrExpand, noNegative, minSize // by default [0, 0].\n) {\n  if (delta == null) {\n    return rect;\n  } else if (isNumber(delta)) {\n    _tmpExpandRectDelta[0] = _tmpExpandRectDelta[1] = _tmpExpandRectDelta[2] = _tmpExpandRectDelta[3] = delta;\n  } else {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(delta.length === 4);\n    }\n    _tmpExpandRectDelta[0] = delta[0];\n    _tmpExpandRectDelta[1] = delta[1];\n    _tmpExpandRectDelta[2] = delta[2];\n    _tmpExpandRectDelta[3] = delta[3];\n  }\n  if (noNegative) {\n    _tmpExpandRectDelta[0] = mathMax(0, _tmpExpandRectDelta[0]);\n    _tmpExpandRectDelta[1] = mathMax(0, _tmpExpandRectDelta[1]);\n    _tmpExpandRectDelta[2] = mathMax(0, _tmpExpandRectDelta[2]);\n    _tmpExpandRectDelta[3] = mathMax(0, _tmpExpandRectDelta[3]);\n  }\n  if (shrinkOrExpand) {\n    _tmpExpandRectDelta[0] = -_tmpExpandRectDelta[0];\n    _tmpExpandRectDelta[1] = -_tmpExpandRectDelta[1];\n    _tmpExpandRectDelta[2] = -_tmpExpandRectDelta[2];\n    _tmpExpandRectDelta[3] = -_tmpExpandRectDelta[3];\n  }\n  expandRectOnOneDimension(rect, _tmpExpandRectDelta, 'x', 'width', 3, 1, minSize && minSize[0] || 0);\n  expandRectOnOneDimension(rect, _tmpExpandRectDelta, 'y', 'height', 0, 2, minSize && minSize[1] || 0);\n  return rect;\n}\nvar _tmpExpandRectDelta = [0, 0, 0, 0];\nfunction expandRectOnOneDimension(rect, delta, xy, wh, ltIdx, rbIdx, minSize) {\n  var deltaSum = delta[rbIdx] + delta[ltIdx];\n  var oldSize = rect[wh];\n  rect[wh] += deltaSum;\n  minSize = mathMax(0, mathMin(minSize, oldSize));\n  if (rect[wh] < minSize) {\n    rect[wh] = minSize;\n    // Try to make the position of the zero rect reasonable in most visual cases.\n    rect[xy] += delta[ltIdx] >= 0 ? -delta[ltIdx] : delta[rbIdx] >= 0 ? oldSize + delta[rbIdx] : mathAbs(deltaSum) > 1e-8 ? (oldSize - minSize) * delta[ltIdx] / deltaSum : 0;\n  } else {\n    rect[xy] -= delta[ltIdx];\n  }\n}\nexport function setTooltipConfig(opt) {\n  var itemTooltipOption = opt.itemTooltipOption;\n  var componentModel = opt.componentModel;\n  var itemName = opt.itemName;\n  var itemTooltipOptionObj = isString(itemTooltipOption) ? {\n    formatter: itemTooltipOption\n  } : itemTooltipOption;\n  var mainType = componentModel.mainType;\n  var componentIndex = componentModel.componentIndex;\n  var formatterParams = {\n    componentType: mainType,\n    name: itemName,\n    $vars: ['name']\n  };\n  formatterParams[mainType + 'Index'] = componentIndex;\n  var formatterParamsExtra = opt.formatterParamsExtra;\n  if (formatterParamsExtra) {\n    each(keys(formatterParamsExtra), function (key) {\n      if (!hasOwn(formatterParams, key)) {\n        formatterParams[key] = formatterParamsExtra[key];\n        formatterParams.$vars.push(key);\n      }\n    });\n  }\n  var ecData = getECData(opt.el);\n  ecData.componentMainType = mainType;\n  ecData.componentIndex = componentIndex;\n  ecData.tooltipConfig = {\n    name: itemName,\n    option: defaults({\n      content: itemName,\n      encodeHTMLContent: true,\n      formatterParams: formatterParams\n    }, itemTooltipOptionObj)\n  };\n}\nfunction traverseElement(el, cb) {\n  var stopped;\n  // TODO\n  // Polyfill for fixing zrender group traverse don't visit it's root issue.\n  if (el.isGroup) {\n    stopped = cb(el);\n  }\n  if (!stopped) {\n    el.traverse(cb);\n  }\n}\nexport function traverseElements(els, cb) {\n  if (els) {\n    if (isArray(els)) {\n      for (var i = 0; i < els.length; i++) {\n        traverseElement(els[i], cb);\n      }\n    } else {\n      traverseElement(els, cb);\n    }\n  }\n}\n/**\n * After a boundingRect applying a `transform`, whether to be still parallel screen X and Y.\n */\nexport function isBoundingRectAxisAligned(transform) {\n  return !transform || mathAbs(transform[1]) < AXIS_ALIGN_EPSILON && mathAbs(transform[2]) < AXIS_ALIGN_EPSILON || mathAbs(transform[0]) < AXIS_ALIGN_EPSILON && mathAbs(transform[3]) < AXIS_ALIGN_EPSILON;\n}\nvar AXIS_ALIGN_EPSILON = 1e-5;\n/**\n * Create or copy to the existing bounding rect to avoid modifying `source`.\n *\n * @usage\n *  out.rect = ensureCopyRect(out.rect, sourceRect);\n */\nexport function ensureCopyRect(target, source) {\n  return target ? BoundingRect.copy(target, source) : source.clone();\n}\n/**\n * Create or copy to the existing transform to avoid modifying `source`.\n *\n * [CAUTION]: transform is `NullUndefined` if no transform, following convention of zrender,\n *  and enable to bypass some unnecessary calculation, since in most cases there is no transform.\n *\n * @usage\n *  out.transform = ensureCopyTransform(out.transform, sourceTransform);\n */\nexport function ensureCopyTransform(target, source) {\n  return source ? matrix.copy(target || matrix.create(), source) : undefined;\n}\nexport function retrieveZInfo(model) {\n  return {\n    z: model.get('z') || 0,\n    zlevel: model.get('zlevel') || 0\n  };\n}\n/**\n * Assume all of the elements has the same `z` and `zlevel`.\n */\nexport function calcZ2Range(el) {\n  var max = -Infinity;\n  var min = Infinity;\n  traverseElement(el, function (el) {\n    visitEl(el);\n    visitEl(el.getTextContent());\n    visitEl(el.getTextGuideLine());\n  });\n  function visitEl(el) {\n    if (!el || el.isGroup) {\n      return;\n    }\n    var currentStates = el.currentStates;\n    if (currentStates.length) {\n      for (var idx = 0; idx < currentStates.length; idx++) {\n        calcZ2(el.states[currentStates[idx]]);\n      }\n    }\n    calcZ2(el);\n  }\n  function calcZ2(entity) {\n    if (entity) {\n      var z2 = entity.z2;\n      // Consider z2 may be NullUndefined\n      if (z2 > max) {\n        max = z2;\n      }\n      if (z2 < min) {\n        min = z2;\n      }\n    }\n  }\n  if (min > max) {\n    min = max = 0;\n  }\n  return {\n    min: min,\n    max: max\n  };\n}\nexport function traverseUpdateZ(el, z, zlevel) {\n  doUpdateZ(el, z, zlevel, -Infinity);\n}\nfunction doUpdateZ(el, z, zlevel,\n// FIXME: Ideally all the labels should be above all the glyphs by default,\n//  e.g. in graph, edge labels should be above node elements.\n//  Currently impl does not guarantee that.\nmaxZ2) {\n  // `ignoreModelZ` is used to intentionally lift elements to cover other elements,\n  // where maxZ2 (for label.z2) should also not be counted for its parents.\n  if (el.ignoreModelZ) {\n    return maxZ2;\n  }\n  // Group may also have textContent\n  var label = el.getTextContent();\n  var labelLine = el.getTextGuideLine();\n  var isGroup = el.isGroup;\n  if (isGroup) {\n    // set z & zlevel of children elements of Group\n    var children = el.childrenRef();\n    for (var i = 0; i < children.length; i++) {\n      maxZ2 = mathMax(doUpdateZ(children[i], z, zlevel, maxZ2), maxZ2);\n    }\n  } else {\n    // not Group\n    el.z = z;\n    el.zlevel = zlevel;\n    maxZ2 = mathMax(el.z2 || 0, maxZ2);\n  }\n  // always set z and zlevel if label/labelLine exists\n  if (label) {\n    label.z = z;\n    label.zlevel = zlevel;\n    // lift z2 of text content\n    // TODO if el.emphasis.z2 is spcefied, what about textContent.\n    isFinite(maxZ2) && (label.z2 = maxZ2 + 2);\n  }\n  if (labelLine) {\n    var textGuideLineConfig = el.textGuideLineConfig;\n    labelLine.z = z;\n    labelLine.zlevel = zlevel;\n    isFinite(maxZ2) && (labelLine.z2 = maxZ2 + (textGuideLineConfig && textGuideLineConfig.showAbove ? 1 : -1));\n  }\n  return maxZ2;\n}\n// Register built-in shapes. These shapes might be overwritten\n// by users, although we do not recommend that.\nregisterShape('circle', Circle);\nregisterShape('ellipse', Ellipse);\nregisterShape('sector', Sector);\nregisterShape('ring', Ring);\nregisterShape('polygon', Polygon);\nregisterShape('polyline', Polyline);\nregisterShape('rect', Rect);\nregisterShape('line', Line);\nregisterShape('bezierCurve', BezierCurve);\nregisterShape('arc', Arc);\nexport { Group, ZRImage as Image, ZRText as Text, Circle, Ellipse, Sector, Ring, Polygon, Polyline, Rect, Line, BezierCurve, Arc, IncrementalDisplayable, CompoundPath, LinearGradient, RadialGradient, BoundingRect, OrientedBoundingRect, Point, Path };","map":{"version":3,"names":["pathTool","matrix","vector","Path","Transformable","ZRImage","Group","ZRText","Circle","Ellipse","Sector","Ring","Polygon","Polyline","Rect","Line","BezierCurve","Arc","CompoundPath","LinearGradient","RadialGradient","BoundingRect","OrientedBoundingRect","Point","IncrementalDisplayable","subPixelOptimizeUtil","extend","isArrayLike","map","defaults","isString","keys","each","hasOwn","isArray","isNumber","clone","assert","getECData","updateProps","initProps","removeElement","removeElementWithFadeOut","isElementRemoved","mathMin","mathMax","mathAbs","_customShapeMap","XY","WH","extendShape","opts","extendPathFromString","extendFromString","extendPath","pathData","registerShape","name","ShapeClass","getShapeClass","hasOwnProperty","makePath","rect","layout","path","createFromString","centerGraphic","getBoundingRect","resizePath","makeImage","imageUrl","zrImg","style","image","x","y","width","height","onload","img","boundingRect","setStyle","aspect","cx","cy","mergePath","applyTransform","pathRect","m","calculateTransform","subPixelOptimizeLine","shape","lineWidth","subPixelOptimizeRect","subPixelOptimize","getTransform","target","ancestor","mat","identity","mul","getLocalTransform","parent","transform","invert","transformDirection","direction","hBase","vBase","vertex","isNotGroup","el","isGroup","isPath","groupTransition","g1","g2","animatableModel","getElMap","g","elMap","traverse","anid","getAnimatableProps","obj","rotation","elMap1","oldEl","newProp","attr","dataIndex","clipPointsByRect","points","point","clipRectByRect","targetRect","x2","y2","createIcon","iconStr","opt","innerOpts","rectHover","strokeNoScale","indexOf","slice","replace","linePolygonIntersect","a1x","a1y","a2x","a2y","i","p2","length","p","lineLineIntersect","b1x","b1y","b2x","b2y","mx","my","nx","ny","nmCrossProduct","crossProduct2d","nearZero","b1a1x","b1a1y","q","x1","y1","val","expandOrShrinkRect","delta","shrinkOrExpand","noNegative","minSize","_tmpExpandRectDelta","process","env","NODE_ENV","expandRectOnOneDimension","xy","wh","ltIdx","rbIdx","deltaSum","oldSize","setTooltipConfig","itemTooltipOption","componentModel","itemName","itemTooltipOptionObj","formatter","mainType","componentIndex","formatterParams","componentType","$vars","formatterParamsExtra","key","push","ecData","componentMainType","tooltipConfig","option","content","encodeHTMLContent","traverseElement","cb","stopped","traverseElements","els","isBoundingRectAxisAligned","AXIS_ALIGN_EPSILON","ensureCopyRect","source","copy","ensureCopyTransform","create","undefined","retrieveZInfo","model","z","get","zlevel","calcZ2Range","max","Infinity","min","visitEl","getTextContent","getTextGuideLine","currentStates","idx","calcZ2","states","entity","z2","traverseUpdateZ","doUpdateZ","maxZ2","ignoreModelZ","label","labelLine","children","childrenRef","isFinite","textGuideLineConfig","showAbove","Image","Text"],"sources":["D:/code/java/program/oj/code/yuoj-frontend-master/node_modules/echarts/lib/util/graphic.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport * as pathTool from 'zrender/lib/tool/path.js';\nimport * as matrix from 'zrender/lib/core/matrix.js';\nimport * as vector from 'zrender/lib/core/vector.js';\nimport Path from 'zrender/lib/graphic/Path.js';\nimport Transformable from 'zrender/lib/core/Transformable.js';\nimport ZRImage from 'zrender/lib/graphic/Image.js';\nimport Group from 'zrender/lib/graphic/Group.js';\nimport ZRText from 'zrender/lib/graphic/Text.js';\nimport Circle from 'zrender/lib/graphic/shape/Circle.js';\nimport Ellipse from 'zrender/lib/graphic/shape/Ellipse.js';\nimport Sector from 'zrender/lib/graphic/shape/Sector.js';\nimport Ring from 'zrender/lib/graphic/shape/Ring.js';\nimport Polygon from 'zrender/lib/graphic/shape/Polygon.js';\nimport Polyline from 'zrender/lib/graphic/shape/Polyline.js';\nimport Rect from 'zrender/lib/graphic/shape/Rect.js';\nimport Line from 'zrender/lib/graphic/shape/Line.js';\nimport BezierCurve from 'zrender/lib/graphic/shape/BezierCurve.js';\nimport Arc from 'zrender/lib/graphic/shape/Arc.js';\nimport CompoundPath from 'zrender/lib/graphic/CompoundPath.js';\nimport LinearGradient from 'zrender/lib/graphic/LinearGradient.js';\nimport RadialGradient from 'zrender/lib/graphic/RadialGradient.js';\nimport BoundingRect from 'zrender/lib/core/BoundingRect.js';\nimport OrientedBoundingRect from 'zrender/lib/core/OrientedBoundingRect.js';\nimport Point from 'zrender/lib/core/Point.js';\nimport IncrementalDisplayable from 'zrender/lib/graphic/IncrementalDisplayable.js';\nimport * as subPixelOptimizeUtil from 'zrender/lib/graphic/helper/subPixelOptimize.js';\nimport { extend, isArrayLike, map, defaults, isString, keys, each, hasOwn, isArray, isNumber, clone, assert } from 'zrender/lib/core/util.js';\nimport { getECData } from './innerStore.js';\nimport { updateProps, initProps, removeElement, removeElementWithFadeOut, isElementRemoved } from '../animation/basicTransition.js';\nimport { mathMin, mathMax, mathAbs } from './number.js';\n/**\n * @deprecated export for compatitable reason\n */\nexport { updateProps, initProps, removeElement, removeElementWithFadeOut, isElementRemoved };\nvar _customShapeMap = {};\nexport var XY = ['x', 'y'];\nexport var WH = ['width', 'height'];\n/**\n * Extend shape with parameters\n */\nexport function extendShape(opts) {\n  return Path.extend(opts);\n}\nvar extendPathFromString = pathTool.extendFromString;\n/**\n * Extend path\n */\nexport function extendPath(pathData, opts) {\n  return extendPathFromString(pathData, opts);\n}\n/**\n * Register a user defined shape.\n * The shape class can be fetched by `getShapeClass`\n * This method will overwrite the registered shapes, including\n * the registered built-in shapes, if using the same `name`.\n * The shape can be used in `custom series` and\n * `graphic component` by declaring `{type: name}`.\n *\n * @param name\n * @param ShapeClass Can be generated by `extendShape`.\n */\nexport function registerShape(name, ShapeClass) {\n  _customShapeMap[name] = ShapeClass;\n}\n/**\n * Find shape class registered by `registerShape`. Usually used in\n * fetching user defined shape.\n *\n * [Caution]:\n * (1) This method **MUST NOT be used inside echarts !!!**, unless it is prepared\n * to use user registered shapes.\n * Because the built-in shape (see `getBuiltInShape`) will be registered by\n * `registerShape` by default. That enables users to get both built-in\n * shapes as well as the shapes belonging to themsleves. But users can overwrite\n * the built-in shapes by using names like 'circle', 'rect' via calling\n * `registerShape`. So the echarts inner featrues should not fetch shapes from here\n * in case that it is overwritten by users, except that some features, like\n * `custom series`, `graphic component`, do it deliberately.\n *\n * (2) In the features like `custom series`, `graphic component`, the user input\n * `{tpye: 'xxx'}` does not only specify shapes but also specify other graphic\n * elements like `'group'`, `'text'`, `'image'` or event `'path'`. Those names\n * are reserved names, that is, if some user registers a shape named `'image'`,\n * the shape will not be used. If we intending to add some more reserved names\n * in feature, that might bring break changes (disable some existing user shape\n * names). But that case probably rarely happens. So we don't make more mechanism\n * to resolve this issue here.\n *\n * @param name\n * @return The shape class. If not found, return nothing.\n */\nexport function getShapeClass(name) {\n  if (_customShapeMap.hasOwnProperty(name)) {\n    return _customShapeMap[name];\n  }\n}\n/**\n * Create a path element from path data string\n * @param pathData\n * @param opts\n * @param rect\n * @param layout 'center' or 'cover' default to be cover\n */\nexport function makePath(pathData, opts, rect, layout) {\n  var path = pathTool.createFromString(pathData, opts);\n  if (rect) {\n    if (layout === 'center') {\n      rect = centerGraphic(rect, path.getBoundingRect());\n    }\n    resizePath(path, rect);\n  }\n  return path;\n}\n/**\n * Create a image element from image url\n * @param imageUrl image url\n * @param opts options\n * @param rect constrain rect\n * @param layout 'center' or 'cover'. Default to be 'cover'\n */\nexport function makeImage(imageUrl, rect, layout) {\n  var zrImg = new ZRImage({\n    style: {\n      image: imageUrl,\n      x: rect.x,\n      y: rect.y,\n      width: rect.width,\n      height: rect.height\n    },\n    onload: function (img) {\n      if (layout === 'center') {\n        var boundingRect = {\n          width: img.width,\n          height: img.height\n        };\n        zrImg.setStyle(centerGraphic(rect, boundingRect));\n      }\n    }\n  });\n  return zrImg;\n}\n/**\n * Get position of centered element in bounding box.\n *\n * @param  rect         element local bounding box\n * @param  boundingRect constraint bounding box\n * @return element position containing x, y, width, and height\n */\nfunction centerGraphic(rect, boundingRect) {\n  // Set rect to center, keep width / height ratio.\n  var aspect = boundingRect.width / boundingRect.height;\n  var width = rect.height * aspect;\n  var height;\n  if (width <= rect.width) {\n    height = rect.height;\n  } else {\n    width = rect.width;\n    height = width / aspect;\n  }\n  var cx = rect.x + rect.width / 2;\n  var cy = rect.y + rect.height / 2;\n  return {\n    x: cx - width / 2,\n    y: cy - height / 2,\n    width: width,\n    height: height\n  };\n}\nexport var mergePath = pathTool.mergePath;\n/**\n * Resize a path to fit the rect\n * @param path\n * @param rect\n */\nexport function resizePath(path, rect) {\n  if (!path.applyTransform) {\n    return;\n  }\n  var pathRect = path.getBoundingRect();\n  var m = pathRect.calculateTransform(rect);\n  path.applyTransform(m);\n}\n/**\n * Sub pixel optimize line for canvas\n */\nexport function subPixelOptimizeLine(shape, lineWidth) {\n  subPixelOptimizeUtil.subPixelOptimizeLine(shape, shape, {\n    lineWidth: lineWidth\n  });\n  return shape;\n}\n/**\n * Sub pixel optimize rect for canvas\n */\nexport function subPixelOptimizeRect(shape, style) {\n  subPixelOptimizeUtil.subPixelOptimizeRect(shape, shape, style);\n  return shape;\n}\n/**\n * Sub pixel optimize for canvas\n *\n * @param position Coordinate, such as x, y\n * @param lineWidth Should be nonnegative integer.\n * @param positiveOrNegative Default false (negative).\n * @return Optimized position.\n */\nexport var subPixelOptimize = subPixelOptimizeUtil.subPixelOptimize;\n/**\n * Get transform matrix of target (param target),\n * in coordinate of its ancestor (param ancestor)\n *\n * @param target\n * @param [ancestor]\n */\nexport function getTransform(target, ancestor) {\n  var mat = matrix.identity([]);\n  while (target && target !== ancestor) {\n    matrix.mul(mat, target.getLocalTransform(), mat);\n    target = target.parent;\n  }\n  return mat;\n}\n/**\n * Apply transform to an vertex.\n * @param target [x, y]\n * @param transform Can be:\n *      + Transform matrix: like [1, 0, 0, 1, 0, 0]\n *      + {position, rotation, scale}, the same as `zrender/Transformable`.\n * @param invert Whether use invert matrix.\n * @return [x, y]\n */\nexport function applyTransform(target, transform, invert) {\n  if (transform && !isArrayLike(transform)) {\n    transform = Transformable.getLocalTransform(transform);\n  }\n  if (invert) {\n    transform = matrix.invert([], transform);\n  }\n  return vector.applyTransform([], target, transform);\n}\n/**\n * @param direction 'left' 'right' 'top' 'bottom'\n * @param transform Transform matrix: like [1, 0, 0, 1, 0, 0]\n * @param invert Whether use invert matrix.\n * @return Transformed direction. 'left' 'right' 'top' 'bottom'\n */\nexport function transformDirection(direction, transform, invert) {\n  // Pick a base, ensure that transform result will not be (0, 0).\n  var hBase = transform[4] === 0 || transform[5] === 0 || transform[0] === 0 ? 1 : mathAbs(2 * transform[4] / transform[0]);\n  var vBase = transform[4] === 0 || transform[5] === 0 || transform[2] === 0 ? 1 : mathAbs(2 * transform[4] / transform[2]);\n  var vertex = [direction === 'left' ? -hBase : direction === 'right' ? hBase : 0, direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0];\n  vertex = applyTransform(vertex, transform, invert);\n  return mathAbs(vertex[0]) > mathAbs(vertex[1]) ? vertex[0] > 0 ? 'right' : 'left' : vertex[1] > 0 ? 'bottom' : 'top';\n}\nfunction isNotGroup(el) {\n  return !el.isGroup;\n}\nfunction isPath(el) {\n  return el.shape != null;\n}\n/**\n * Apply group transition animation from g1 to g2.\n * If no animatableModel, no animation.\n */\nexport function groupTransition(g1, g2, animatableModel) {\n  if (!g1 || !g2) {\n    return;\n  }\n  function getElMap(g) {\n    var elMap = {};\n    g.traverse(function (el) {\n      if (isNotGroup(el) && el.anid) {\n        elMap[el.anid] = el;\n      }\n    });\n    return elMap;\n  }\n  function getAnimatableProps(el) {\n    var obj = {\n      x: el.x,\n      y: el.y,\n      rotation: el.rotation\n    };\n    if (isPath(el)) {\n      obj.shape = clone(el.shape);\n    }\n    return obj;\n  }\n  var elMap1 = getElMap(g1);\n  g2.traverse(function (el) {\n    if (isNotGroup(el) && el.anid) {\n      var oldEl = elMap1[el.anid];\n      if (oldEl) {\n        var newProp = getAnimatableProps(el);\n        el.attr(getAnimatableProps(oldEl));\n        updateProps(el, newProp, animatableModel, getECData(el).dataIndex);\n      }\n    }\n  });\n}\nexport function clipPointsByRect(points, rect) {\n  // FIXME: This way might be incorrect when graphic clipped by a corner\n  // and when element has a border.\n  return map(points, function (point) {\n    var x = point[0];\n    x = mathMax(x, rect.x);\n    x = mathMin(x, rect.x + rect.width);\n    var y = point[1];\n    y = mathMax(y, rect.y);\n    y = mathMin(y, rect.y + rect.height);\n    return [x, y];\n  });\n}\n/**\n * Return a new clipped rect. If rect size are negative, return undefined.\n */\nexport function clipRectByRect(targetRect, rect) {\n  var x = mathMax(targetRect.x, rect.x);\n  var x2 = mathMin(targetRect.x + targetRect.width, rect.x + rect.width);\n  var y = mathMax(targetRect.y, rect.y);\n  var y2 = mathMin(targetRect.y + targetRect.height, rect.y + rect.height);\n  // If the total rect is cliped, nothing, including the border,\n  // should be painted. So return undefined.\n  if (x2 >= x && y2 >= y) {\n    return {\n      x: x,\n      y: y,\n      width: x2 - x,\n      height: y2 - y\n    };\n  }\n}\nexport function createIcon(iconStr,\n// Support 'image://' or 'path://' or direct svg path.\nopt, rect) {\n  var innerOpts = extend({\n    rectHover: true\n  }, opt);\n  var style = innerOpts.style = {\n    strokeNoScale: true\n  };\n  rect = rect || {\n    x: -1,\n    y: -1,\n    width: 2,\n    height: 2\n  };\n  if (iconStr) {\n    return iconStr.indexOf('image://') === 0 ? (style.image = iconStr.slice(8), defaults(style, rect), new ZRImage(innerOpts)) : makePath(iconStr.replace('path://', ''), innerOpts, rect, 'center');\n  }\n}\n/**\n * Return `true` if the given line (line `a`) and the given polygon\n * are intersect.\n * Note that we do not count colinear as intersect here because no\n * requirement for that. We could do that if required in future.\n */\nexport function linePolygonIntersect(a1x, a1y, a2x, a2y, points) {\n  for (var i = 0, p2 = points[points.length - 1]; i < points.length; i++) {\n    var p = points[i];\n    if (lineLineIntersect(a1x, a1y, a2x, a2y, p[0], p[1], p2[0], p2[1])) {\n      return true;\n    }\n    p2 = p;\n  }\n}\n/**\n * Return `true` if the given two lines (line `a` and line `b`)\n * are intersect.\n * Note that we do not count colinear as intersect here because no\n * requirement for that. We could do that if required in future.\n */\nexport function lineLineIntersect(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y) {\n  // let `vec_m` to be `vec_a2 - vec_a1` and `vec_n` to be `vec_b2 - vec_b1`.\n  var mx = a2x - a1x;\n  var my = a2y - a1y;\n  var nx = b2x - b1x;\n  var ny = b2y - b1y;\n  // `vec_m` and `vec_n` are parallel iff\n  //     existing `k` such that `vec_m = k · vec_n`, equivalent to `vec_m X vec_n = 0`.\n  var nmCrossProduct = crossProduct2d(nx, ny, mx, my);\n  if (nearZero(nmCrossProduct)) {\n    return false;\n  }\n  // `vec_m` and `vec_n` are intersect iff\n  //     existing `p` and `q` in [0, 1] such that `vec_a1 + p * vec_m = vec_b1 + q * vec_n`,\n  //     such that `q = ((vec_a1 - vec_b1) X vec_m) / (vec_n X vec_m)`\n  //           and `p = ((vec_a1 - vec_b1) X vec_n) / (vec_n X vec_m)`.\n  var b1a1x = a1x - b1x;\n  var b1a1y = a1y - b1y;\n  var q = crossProduct2d(b1a1x, b1a1y, mx, my) / nmCrossProduct;\n  if (q < 0 || q > 1) {\n    return false;\n  }\n  var p = crossProduct2d(b1a1x, b1a1y, nx, ny) / nmCrossProduct;\n  if (p < 0 || p > 1) {\n    return false;\n  }\n  return true;\n}\n/**\n * Cross product of 2-dimension vector.\n */\nfunction crossProduct2d(x1, y1, x2, y2) {\n  return x1 * y2 - x2 * y1;\n}\nfunction nearZero(val) {\n  return val <= 1e-6 && val >= -1e-6;\n}\n/**\n * NOTE:\n *  A negative-width/height rect (due to negative margins) is not supported;\n *  it will be clampped to zero width/height.\n *  Although negative-width/height rects can be defined reasonably following the\n *  similar sense in CSS, but they are rarely used, hard to understand and complicated.\n *\n * @param rect Assume its width/height >= 0 if existing.\n *  x/y/width/height is allowed to be NaN,\n *  for the case that only x/width or y/height is intended to be computed.\n * @param delta\n *  If be `number[]`, should be `[top, right, bottom, left]`,\n *      which can be used in padding or margin case.\n *      @see `normalizeCssArray` in `util/format.ts`\n *  If be `number`, it means [delta, delta, delta, delta],\n *      which can be used in lineWidth (borderWith) case,\n *      [NOTICE]: commonly pass lineWidth / 2, following the convention that border is\n *      half inside half outside of the rect.\n * @param shrinkOrExpand\n *  `true` - shrink if `delta[i]` is positive, commmonly used in `padding` case.\n *  `false` - expand if `delta[i]` is positive, commmonly used in `margin` case. (default)\n * @param noNegative\n *  `true` - negative `delta[i]` will be clampped to 0.\n *  `false` - No clamp to `delta`. (default).\n * @return The input `rect`.\n */\nexport function expandOrShrinkRect(rect, delta, shrinkOrExpand, noNegative, minSize // by default [0, 0].\n) {\n  if (delta == null) {\n    return rect;\n  } else if (isNumber(delta)) {\n    _tmpExpandRectDelta[0] = _tmpExpandRectDelta[1] = _tmpExpandRectDelta[2] = _tmpExpandRectDelta[3] = delta;\n  } else {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(delta.length === 4);\n    }\n    _tmpExpandRectDelta[0] = delta[0];\n    _tmpExpandRectDelta[1] = delta[1];\n    _tmpExpandRectDelta[2] = delta[2];\n    _tmpExpandRectDelta[3] = delta[3];\n  }\n  if (noNegative) {\n    _tmpExpandRectDelta[0] = mathMax(0, _tmpExpandRectDelta[0]);\n    _tmpExpandRectDelta[1] = mathMax(0, _tmpExpandRectDelta[1]);\n    _tmpExpandRectDelta[2] = mathMax(0, _tmpExpandRectDelta[2]);\n    _tmpExpandRectDelta[3] = mathMax(0, _tmpExpandRectDelta[3]);\n  }\n  if (shrinkOrExpand) {\n    _tmpExpandRectDelta[0] = -_tmpExpandRectDelta[0];\n    _tmpExpandRectDelta[1] = -_tmpExpandRectDelta[1];\n    _tmpExpandRectDelta[2] = -_tmpExpandRectDelta[2];\n    _tmpExpandRectDelta[3] = -_tmpExpandRectDelta[3];\n  }\n  expandRectOnOneDimension(rect, _tmpExpandRectDelta, 'x', 'width', 3, 1, minSize && minSize[0] || 0);\n  expandRectOnOneDimension(rect, _tmpExpandRectDelta, 'y', 'height', 0, 2, minSize && minSize[1] || 0);\n  return rect;\n}\nvar _tmpExpandRectDelta = [0, 0, 0, 0];\nfunction expandRectOnOneDimension(rect, delta, xy, wh, ltIdx, rbIdx, minSize) {\n  var deltaSum = delta[rbIdx] + delta[ltIdx];\n  var oldSize = rect[wh];\n  rect[wh] += deltaSum;\n  minSize = mathMax(0, mathMin(minSize, oldSize));\n  if (rect[wh] < minSize) {\n    rect[wh] = minSize;\n    // Try to make the position of the zero rect reasonable in most visual cases.\n    rect[xy] += delta[ltIdx] >= 0 ? -delta[ltIdx] : delta[rbIdx] >= 0 ? oldSize + delta[rbIdx] : mathAbs(deltaSum) > 1e-8 ? (oldSize - minSize) * delta[ltIdx] / deltaSum : 0;\n  } else {\n    rect[xy] -= delta[ltIdx];\n  }\n}\nexport function setTooltipConfig(opt) {\n  var itemTooltipOption = opt.itemTooltipOption;\n  var componentModel = opt.componentModel;\n  var itemName = opt.itemName;\n  var itemTooltipOptionObj = isString(itemTooltipOption) ? {\n    formatter: itemTooltipOption\n  } : itemTooltipOption;\n  var mainType = componentModel.mainType;\n  var componentIndex = componentModel.componentIndex;\n  var formatterParams = {\n    componentType: mainType,\n    name: itemName,\n    $vars: ['name']\n  };\n  formatterParams[mainType + 'Index'] = componentIndex;\n  var formatterParamsExtra = opt.formatterParamsExtra;\n  if (formatterParamsExtra) {\n    each(keys(formatterParamsExtra), function (key) {\n      if (!hasOwn(formatterParams, key)) {\n        formatterParams[key] = formatterParamsExtra[key];\n        formatterParams.$vars.push(key);\n      }\n    });\n  }\n  var ecData = getECData(opt.el);\n  ecData.componentMainType = mainType;\n  ecData.componentIndex = componentIndex;\n  ecData.tooltipConfig = {\n    name: itemName,\n    option: defaults({\n      content: itemName,\n      encodeHTMLContent: true,\n      formatterParams: formatterParams\n    }, itemTooltipOptionObj)\n  };\n}\nfunction traverseElement(el, cb) {\n  var stopped;\n  // TODO\n  // Polyfill for fixing zrender group traverse don't visit it's root issue.\n  if (el.isGroup) {\n    stopped = cb(el);\n  }\n  if (!stopped) {\n    el.traverse(cb);\n  }\n}\nexport function traverseElements(els, cb) {\n  if (els) {\n    if (isArray(els)) {\n      for (var i = 0; i < els.length; i++) {\n        traverseElement(els[i], cb);\n      }\n    } else {\n      traverseElement(els, cb);\n    }\n  }\n}\n/**\n * After a boundingRect applying a `transform`, whether to be still parallel screen X and Y.\n */\nexport function isBoundingRectAxisAligned(transform) {\n  return !transform || mathAbs(transform[1]) < AXIS_ALIGN_EPSILON && mathAbs(transform[2]) < AXIS_ALIGN_EPSILON || mathAbs(transform[0]) < AXIS_ALIGN_EPSILON && mathAbs(transform[3]) < AXIS_ALIGN_EPSILON;\n}\nvar AXIS_ALIGN_EPSILON = 1e-5;\n/**\n * Create or copy to the existing bounding rect to avoid modifying `source`.\n *\n * @usage\n *  out.rect = ensureCopyRect(out.rect, sourceRect);\n */\nexport function ensureCopyRect(target, source) {\n  return target ? BoundingRect.copy(target, source) : source.clone();\n}\n/**\n * Create or copy to the existing transform to avoid modifying `source`.\n *\n * [CAUTION]: transform is `NullUndefined` if no transform, following convention of zrender,\n *  and enable to bypass some unnecessary calculation, since in most cases there is no transform.\n *\n * @usage\n *  out.transform = ensureCopyTransform(out.transform, sourceTransform);\n */\nexport function ensureCopyTransform(target, source) {\n  return source ? matrix.copy(target || matrix.create(), source) : undefined;\n}\nexport function retrieveZInfo(model) {\n  return {\n    z: model.get('z') || 0,\n    zlevel: model.get('zlevel') || 0\n  };\n}\n/**\n * Assume all of the elements has the same `z` and `zlevel`.\n */\nexport function calcZ2Range(el) {\n  var max = -Infinity;\n  var min = Infinity;\n  traverseElement(el, function (el) {\n    visitEl(el);\n    visitEl(el.getTextContent());\n    visitEl(el.getTextGuideLine());\n  });\n  function visitEl(el) {\n    if (!el || el.isGroup) {\n      return;\n    }\n    var currentStates = el.currentStates;\n    if (currentStates.length) {\n      for (var idx = 0; idx < currentStates.length; idx++) {\n        calcZ2(el.states[currentStates[idx]]);\n      }\n    }\n    calcZ2(el);\n  }\n  function calcZ2(entity) {\n    if (entity) {\n      var z2 = entity.z2;\n      // Consider z2 may be NullUndefined\n      if (z2 > max) {\n        max = z2;\n      }\n      if (z2 < min) {\n        min = z2;\n      }\n    }\n  }\n  if (min > max) {\n    min = max = 0;\n  }\n  return {\n    min: min,\n    max: max\n  };\n}\nexport function traverseUpdateZ(el, z, zlevel) {\n  doUpdateZ(el, z, zlevel, -Infinity);\n}\nfunction doUpdateZ(el, z, zlevel,\n// FIXME: Ideally all the labels should be above all the glyphs by default,\n//  e.g. in graph, edge labels should be above node elements.\n//  Currently impl does not guarantee that.\nmaxZ2) {\n  // `ignoreModelZ` is used to intentionally lift elements to cover other elements,\n  // where maxZ2 (for label.z2) should also not be counted for its parents.\n  if (el.ignoreModelZ) {\n    return maxZ2;\n  }\n  // Group may also have textContent\n  var label = el.getTextContent();\n  var labelLine = el.getTextGuideLine();\n  var isGroup = el.isGroup;\n  if (isGroup) {\n    // set z & zlevel of children elements of Group\n    var children = el.childrenRef();\n    for (var i = 0; i < children.length; i++) {\n      maxZ2 = mathMax(doUpdateZ(children[i], z, zlevel, maxZ2), maxZ2);\n    }\n  } else {\n    // not Group\n    el.z = z;\n    el.zlevel = zlevel;\n    maxZ2 = mathMax(el.z2 || 0, maxZ2);\n  }\n  // always set z and zlevel if label/labelLine exists\n  if (label) {\n    label.z = z;\n    label.zlevel = zlevel;\n    // lift z2 of text content\n    // TODO if el.emphasis.z2 is spcefied, what about textContent.\n    isFinite(maxZ2) && (label.z2 = maxZ2 + 2);\n  }\n  if (labelLine) {\n    var textGuideLineConfig = el.textGuideLineConfig;\n    labelLine.z = z;\n    labelLine.zlevel = zlevel;\n    isFinite(maxZ2) && (labelLine.z2 = maxZ2 + (textGuideLineConfig && textGuideLineConfig.showAbove ? 1 : -1));\n  }\n  return maxZ2;\n}\n// Register built-in shapes. These shapes might be overwritten\n// by users, although we do not recommend that.\nregisterShape('circle', Circle);\nregisterShape('ellipse', Ellipse);\nregisterShape('sector', Sector);\nregisterShape('ring', Ring);\nregisterShape('polygon', Polygon);\nregisterShape('polyline', Polyline);\nregisterShape('rect', Rect);\nregisterShape('line', Line);\nregisterShape('bezierCurve', BezierCurve);\nregisterShape('arc', Arc);\nexport { Group, ZRImage as Image, ZRText as Text, Circle, Ellipse, Sector, Ring, Polygon, Polyline, Rect, Line, BezierCurve, Arc, IncrementalDisplayable, CompoundPath, LinearGradient, RadialGradient, BoundingRect, OrientedBoundingRect, Point, Path };"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { toErrorMessage } from '../../../base/common/errorMessage.js';\nimport { isCancellationError } from '../../../base/common/errors.js';\nimport { matchesContiguousSubString, matchesPrefix, matchesWords, or } from '../../../base/common/filters.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { LRUCache } from '../../../base/common/map.js';\nimport { withNullAsUndefined } from '../../../base/common/types.js';\nimport { localize } from '../../../nls.js';\nimport { ICommandService } from '../../commands/common/commands.js';\nimport { IConfigurationService } from '../../configuration/common/configuration.js';\nimport { IDialogService } from '../../dialogs/common/dialogs.js';\nimport { IInstantiationService } from '../../instantiation/common/instantiation.js';\nimport { IKeybindingService } from '../../keybinding/common/keybinding.js';\nimport { PickerQuickAccessProvider } from './pickerQuickAccess.js';\nimport { IStorageService } from '../../storage/common/storage.js';\nimport { ITelemetryService } from '../../telemetry/common/telemetry.js';\nlet AbstractCommandsQuickAccessProvider = class AbstractCommandsQuickAccessProvider extends PickerQuickAccessProvider {\n  constructor(options, instantiationService, keybindingService, commandService, telemetryService, dialogService) {\n    super(AbstractCommandsQuickAccessProvider.PREFIX, options);\n    this.instantiationService = instantiationService;\n    this.keybindingService = keybindingService;\n    this.commandService = commandService;\n    this.telemetryService = telemetryService;\n    this.dialogService = dialogService;\n    this.commandsHistory = this._register(this.instantiationService.createInstance(CommandsHistory));\n    this.options = options;\n  }\n  _getPicks(filter, _disposables, token, runOptions) {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function* () {\n      // Ask subclass for all command picks\n      const allCommandPicks = yield this.getCommandPicks(token);\n      if (token.isCancellationRequested) {\n        return [];\n      }\n      // Filter\n      const filteredCommandPicks = [];\n      for (const commandPick of allCommandPicks) {\n        const labelHighlights = withNullAsUndefined(AbstractCommandsQuickAccessProvider.WORD_FILTER(filter, commandPick.label));\n        const aliasHighlights = commandPick.commandAlias ? withNullAsUndefined(AbstractCommandsQuickAccessProvider.WORD_FILTER(filter, commandPick.commandAlias)) : undefined;\n        // Add if matching in label or alias\n        if (labelHighlights || aliasHighlights) {\n          commandPick.highlights = {\n            label: labelHighlights,\n            detail: this.options.showAlias ? aliasHighlights : undefined\n          };\n          filteredCommandPicks.push(commandPick);\n        }\n        // Also add if we have a 100% command ID match\n        else if (filter === commandPick.commandId) {\n          filteredCommandPicks.push(commandPick);\n        }\n      }\n      // Add description to commands that have duplicate labels\n      const mapLabelToCommand = new Map();\n      for (const commandPick of filteredCommandPicks) {\n        const existingCommandForLabel = mapLabelToCommand.get(commandPick.label);\n        if (existingCommandForLabel) {\n          commandPick.description = commandPick.commandId;\n          existingCommandForLabel.description = existingCommandForLabel.commandId;\n        } else {\n          mapLabelToCommand.set(commandPick.label, commandPick);\n        }\n      }\n      // Sort by MRU order and fallback to name otherwise\n      filteredCommandPicks.sort((commandPickA, commandPickB) => {\n        const commandACounter = this.commandsHistory.peek(commandPickA.commandId);\n        const commandBCounter = this.commandsHistory.peek(commandPickB.commandId);\n        if (commandACounter && commandBCounter) {\n          return commandACounter > commandBCounter ? -1 : 1; // use more recently used command before older\n        }\n\n        if (commandACounter) {\n          return -1; // first command was used, so it wins over the non used one\n        }\n\n        if (commandBCounter) {\n          return 1; // other command was used so it wins over the command\n        }\n\n        if (this.options.suggestedCommandIds) {\n          const commandASuggestion = this.options.suggestedCommandIds.has(commandPickA.commandId);\n          const commandBSuggestion = this.options.suggestedCommandIds.has(commandPickB.commandId);\n          if (commandASuggestion && commandBSuggestion) {\n            return 0; // honor the order of the array\n          }\n\n          if (commandASuggestion) {\n            return -1; // first command was suggested, so it wins over the non suggested one\n          }\n\n          if (commandBSuggestion) {\n            return 1; // other command was suggested so it wins over the command\n          }\n        }\n        // both commands were never used, so we sort by name\n        return commandPickA.label.localeCompare(commandPickB.label);\n      });\n      const commandPicks = [];\n      let addOtherSeparator = false;\n      let addCommonlyUsedSeparator = !!this.options.suggestedCommandIds;\n      for (let i = 0; i < filteredCommandPicks.length; i++) {\n        const commandPick = filteredCommandPicks[i];\n        // Separator: recently used\n        if (i === 0 && this.commandsHistory.peek(commandPick.commandId)) {\n          commandPicks.push({\n            type: 'separator',\n            label: localize('recentlyUsed', \"recently used\")\n          });\n          addOtherSeparator = true;\n        }\n        // Separator: commonly used\n        if (addCommonlyUsedSeparator && !this.commandsHistory.peek(commandPick.commandId) && ((_a = this.options.suggestedCommandIds) === null || _a === void 0 ? void 0 : _a.has(commandPick.commandId))) {\n          commandPicks.push({\n            type: 'separator',\n            label: localize('commonlyUsed', \"commonly used\")\n          });\n          addOtherSeparator = true;\n          addCommonlyUsedSeparator = false;\n        }\n        // Separator: other commands\n        if (addOtherSeparator && !this.commandsHistory.peek(commandPick.commandId) && !((_b = this.options.suggestedCommandIds) === null || _b === void 0 ? void 0 : _b.has(commandPick.commandId))) {\n          commandPicks.push({\n            type: 'separator',\n            label: localize('morecCommands', \"other commands\")\n          });\n          addOtherSeparator = false;\n        }\n        // Command\n        commandPicks.push(this.toCommandPick(commandPick, runOptions));\n      }\n      if (!this.hasAdditionalCommandPicks(filter, token)) {\n        return commandPicks;\n      }\n      return {\n        picks: commandPicks,\n        additionalPicks: (() => __awaiter(this, void 0, void 0, function* () {\n          const additionalCommandPicks = yield this.getAdditionalCommandPicks(allCommandPicks, filteredCommandPicks, filter, token);\n          if (token.isCancellationRequested) {\n            return [];\n          }\n          return additionalCommandPicks.map(commandPick => this.toCommandPick(commandPick, runOptions));\n        }))()\n      };\n    });\n  }\n  toCommandPick(commandPick, runOptions) {\n    if (commandPick.type === 'separator') {\n      return commandPick;\n    }\n    const keybinding = this.keybindingService.lookupKeybinding(commandPick.commandId);\n    const ariaLabel = keybinding ? localize('commandPickAriaLabelWithKeybinding', \"{0}, {1}\", commandPick.label, keybinding.getAriaLabel()) : commandPick.label;\n    return Object.assign(Object.assign({}, commandPick), {\n      ariaLabel,\n      detail: this.options.showAlias && commandPick.commandAlias !== commandPick.label ? commandPick.commandAlias : undefined,\n      keybinding,\n      accept: () => __awaiter(this, void 0, void 0, function* () {\n        var _a, _b;\n        // Add to history\n        this.commandsHistory.push(commandPick.commandId);\n        // Telementry\n        this.telemetryService.publicLog2('workbenchActionExecuted', {\n          id: commandPick.commandId,\n          from: (_a = runOptions === null || runOptions === void 0 ? void 0 : runOptions.from) !== null && _a !== void 0 ? _a : 'quick open'\n        });\n        // Run\n        try {\n          ((_b = commandPick.args) === null || _b === void 0 ? void 0 : _b.length) ? yield this.commandService.executeCommand(commandPick.commandId, ...commandPick.args) : yield this.commandService.executeCommand(commandPick.commandId);\n        } catch (error) {\n          if (!isCancellationError(error)) {\n            this.dialogService.error(localize('canNotRun', \"Command '{0}' resulted in an error\", commandPick.label), toErrorMessage(error));\n          }\n        }\n      })\n    });\n  }\n};\nAbstractCommandsQuickAccessProvider.PREFIX = '>';\nAbstractCommandsQuickAccessProvider.WORD_FILTER = or(matchesPrefix, matchesWords, matchesContiguousSubString);\nAbstractCommandsQuickAccessProvider = __decorate([__param(1, IInstantiationService), __param(2, IKeybindingService), __param(3, ICommandService), __param(4, ITelemetryService), __param(5, IDialogService)], AbstractCommandsQuickAccessProvider);\nexport { AbstractCommandsQuickAccessProvider };\nlet CommandsHistory = class CommandsHistory extends Disposable {\n  constructor(storageService, configurationService) {\n    super();\n    this.storageService = storageService;\n    this.configurationService = configurationService;\n    this.configuredCommandsHistoryLength = 0;\n    this.updateConfiguration();\n    this.load();\n    this.registerListeners();\n  }\n  registerListeners() {\n    this._register(this.configurationService.onDidChangeConfiguration(e => this.updateConfiguration(e)));\n  }\n  updateConfiguration(e) {\n    if (e && !e.affectsConfiguration('workbench.commandPalette.history')) {\n      return;\n    }\n    this.configuredCommandsHistoryLength = CommandsHistory.getConfiguredCommandHistoryLength(this.configurationService);\n    if (CommandsHistory.cache && CommandsHistory.cache.limit !== this.configuredCommandsHistoryLength) {\n      CommandsHistory.cache.limit = this.configuredCommandsHistoryLength;\n      CommandsHistory.saveState(this.storageService);\n    }\n  }\n  load() {\n    const raw = this.storageService.get(CommandsHistory.PREF_KEY_CACHE, 0 /* StorageScope.PROFILE */);\n    let serializedCache;\n    if (raw) {\n      try {\n        serializedCache = JSON.parse(raw);\n      } catch (error) {\n        // invalid data\n      }\n    }\n    const cache = CommandsHistory.cache = new LRUCache(this.configuredCommandsHistoryLength, 1);\n    if (serializedCache) {\n      let entries;\n      if (serializedCache.usesLRU) {\n        entries = serializedCache.entries;\n      } else {\n        entries = serializedCache.entries.sort((a, b) => a.value - b.value);\n      }\n      entries.forEach(entry => cache.set(entry.key, entry.value));\n    }\n    CommandsHistory.counter = this.storageService.getNumber(CommandsHistory.PREF_KEY_COUNTER, 0 /* StorageScope.PROFILE */, CommandsHistory.counter);\n  }\n  push(commandId) {\n    if (!CommandsHistory.cache) {\n      return;\n    }\n    CommandsHistory.cache.set(commandId, CommandsHistory.counter++); // set counter to command\n    CommandsHistory.saveState(this.storageService);\n  }\n  peek(commandId) {\n    var _a;\n    return (_a = CommandsHistory.cache) === null || _a === void 0 ? void 0 : _a.peek(commandId);\n  }\n  static saveState(storageService) {\n    if (!CommandsHistory.cache) {\n      return;\n    }\n    const serializedCache = {\n      usesLRU: true,\n      entries: []\n    };\n    CommandsHistory.cache.forEach((value, key) => serializedCache.entries.push({\n      key,\n      value\n    }));\n    storageService.store(CommandsHistory.PREF_KEY_CACHE, JSON.stringify(serializedCache), 0 /* StorageScope.PROFILE */, 0 /* StorageTarget.USER */);\n    storageService.store(CommandsHistory.PREF_KEY_COUNTER, CommandsHistory.counter, 0 /* StorageScope.PROFILE */, 0 /* StorageTarget.USER */);\n  }\n\n  static getConfiguredCommandHistoryLength(configurationService) {\n    var _a, _b;\n    const config = configurationService.getValue();\n    const configuredCommandHistoryLength = (_b = (_a = config.workbench) === null || _a === void 0 ? void 0 : _a.commandPalette) === null || _b === void 0 ? void 0 : _b.history;\n    if (typeof configuredCommandHistoryLength === 'number') {\n      return configuredCommandHistoryLength;\n    }\n    return CommandsHistory.DEFAULT_COMMANDS_HISTORY_LENGTH;\n  }\n};\nCommandsHistory.DEFAULT_COMMANDS_HISTORY_LENGTH = 50;\nCommandsHistory.PREF_KEY_CACHE = 'commandPalette.mru.cache';\nCommandsHistory.PREF_KEY_COUNTER = 'commandPalette.mru.counter';\nCommandsHistory.counter = 1;\nCommandsHistory = __decorate([__param(0, IStorageService), __param(1, IConfigurationService)], CommandsHistory);\nexport { CommandsHistory };","map":{"version":3,"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","toErrorMessage","isCancellationError","matchesContiguousSubString","matchesPrefix","matchesWords","or","Disposable","LRUCache","withNullAsUndefined","localize","ICommandService","IConfigurationService","IDialogService","IInstantiationService","IKeybindingService","PickerQuickAccessProvider","IStorageService","ITelemetryService","AbstractCommandsQuickAccessProvider","constructor","options","instantiationService","keybindingService","commandService","telemetryService","dialogService","PREFIX","commandsHistory","_register","createInstance","CommandsHistory","_getPicks","filter","_disposables","token","runOptions","_a","_b","allCommandPicks","getCommandPicks","isCancellationRequested","filteredCommandPicks","commandPick","labelHighlights","WORD_FILTER","label","aliasHighlights","commandAlias","undefined","highlights","detail","showAlias","push","commandId","mapLabelToCommand","Map","existingCommandForLabel","get","description","set","sort","commandPickA","commandPickB","commandACounter","peek","commandBCounter","suggestedCommandIds","commandASuggestion","has","commandBSuggestion","localeCompare","commandPicks","addOtherSeparator","addCommonlyUsedSeparator","type","toCommandPick","hasAdditionalCommandPicks","picks","additionalPicks","additionalCommandPicks","getAdditionalCommandPicks","map","keybinding","lookupKeybinding","ariaLabel","getAriaLabel","assign","accept","publicLog2","id","from","args","executeCommand","error","storageService","configurationService","configuredCommandsHistoryLength","updateConfiguration","load","registerListeners","onDidChangeConfiguration","affectsConfiguration","getConfiguredCommandHistoryLength","cache","limit","saveState","raw","PREF_KEY_CACHE","serializedCache","JSON","parse","entries","usesLRU","a","b","forEach","entry","counter","getNumber","PREF_KEY_COUNTER","store","stringify","config","getValue","configuredCommandHistoryLength","workbench","commandPalette","history","DEFAULT_COMMANDS_HISTORY_LENGTH"],"sources":["D:/code/java/program/oj/code/yuoj-frontend-master/node_modules/monaco-editor/esm/vs/platform/quickinput/browser/commandsQuickAccess.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { toErrorMessage } from '../../../base/common/errorMessage.js';\nimport { isCancellationError } from '../../../base/common/errors.js';\nimport { matchesContiguousSubString, matchesPrefix, matchesWords, or } from '../../../base/common/filters.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { LRUCache } from '../../../base/common/map.js';\nimport { withNullAsUndefined } from '../../../base/common/types.js';\nimport { localize } from '../../../nls.js';\nimport { ICommandService } from '../../commands/common/commands.js';\nimport { IConfigurationService } from '../../configuration/common/configuration.js';\nimport { IDialogService } from '../../dialogs/common/dialogs.js';\nimport { IInstantiationService } from '../../instantiation/common/instantiation.js';\nimport { IKeybindingService } from '../../keybinding/common/keybinding.js';\nimport { PickerQuickAccessProvider } from './pickerQuickAccess.js';\nimport { IStorageService } from '../../storage/common/storage.js';\nimport { ITelemetryService } from '../../telemetry/common/telemetry.js';\nlet AbstractCommandsQuickAccessProvider = class AbstractCommandsQuickAccessProvider extends PickerQuickAccessProvider {\n    constructor(options, instantiationService, keybindingService, commandService, telemetryService, dialogService) {\n        super(AbstractCommandsQuickAccessProvider.PREFIX, options);\n        this.instantiationService = instantiationService;\n        this.keybindingService = keybindingService;\n        this.commandService = commandService;\n        this.telemetryService = telemetryService;\n        this.dialogService = dialogService;\n        this.commandsHistory = this._register(this.instantiationService.createInstance(CommandsHistory));\n        this.options = options;\n    }\n    _getPicks(filter, _disposables, token, runOptions) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            // Ask subclass for all command picks\n            const allCommandPicks = yield this.getCommandPicks(token);\n            if (token.isCancellationRequested) {\n                return [];\n            }\n            // Filter\n            const filteredCommandPicks = [];\n            for (const commandPick of allCommandPicks) {\n                const labelHighlights = withNullAsUndefined(AbstractCommandsQuickAccessProvider.WORD_FILTER(filter, commandPick.label));\n                const aliasHighlights = commandPick.commandAlias ? withNullAsUndefined(AbstractCommandsQuickAccessProvider.WORD_FILTER(filter, commandPick.commandAlias)) : undefined;\n                // Add if matching in label or alias\n                if (labelHighlights || aliasHighlights) {\n                    commandPick.highlights = {\n                        label: labelHighlights,\n                        detail: this.options.showAlias ? aliasHighlights : undefined\n                    };\n                    filteredCommandPicks.push(commandPick);\n                }\n                // Also add if we have a 100% command ID match\n                else if (filter === commandPick.commandId) {\n                    filteredCommandPicks.push(commandPick);\n                }\n            }\n            // Add description to commands that have duplicate labels\n            const mapLabelToCommand = new Map();\n            for (const commandPick of filteredCommandPicks) {\n                const existingCommandForLabel = mapLabelToCommand.get(commandPick.label);\n                if (existingCommandForLabel) {\n                    commandPick.description = commandPick.commandId;\n                    existingCommandForLabel.description = existingCommandForLabel.commandId;\n                }\n                else {\n                    mapLabelToCommand.set(commandPick.label, commandPick);\n                }\n            }\n            // Sort by MRU order and fallback to name otherwise\n            filteredCommandPicks.sort((commandPickA, commandPickB) => {\n                const commandACounter = this.commandsHistory.peek(commandPickA.commandId);\n                const commandBCounter = this.commandsHistory.peek(commandPickB.commandId);\n                if (commandACounter && commandBCounter) {\n                    return commandACounter > commandBCounter ? -1 : 1; // use more recently used command before older\n                }\n                if (commandACounter) {\n                    return -1; // first command was used, so it wins over the non used one\n                }\n                if (commandBCounter) {\n                    return 1; // other command was used so it wins over the command\n                }\n                if (this.options.suggestedCommandIds) {\n                    const commandASuggestion = this.options.suggestedCommandIds.has(commandPickA.commandId);\n                    const commandBSuggestion = this.options.suggestedCommandIds.has(commandPickB.commandId);\n                    if (commandASuggestion && commandBSuggestion) {\n                        return 0; // honor the order of the array\n                    }\n                    if (commandASuggestion) {\n                        return -1; // first command was suggested, so it wins over the non suggested one\n                    }\n                    if (commandBSuggestion) {\n                        return 1; // other command was suggested so it wins over the command\n                    }\n                }\n                // both commands were never used, so we sort by name\n                return commandPickA.label.localeCompare(commandPickB.label);\n            });\n            const commandPicks = [];\n            let addOtherSeparator = false;\n            let addCommonlyUsedSeparator = !!this.options.suggestedCommandIds;\n            for (let i = 0; i < filteredCommandPicks.length; i++) {\n                const commandPick = filteredCommandPicks[i];\n                // Separator: recently used\n                if (i === 0 && this.commandsHistory.peek(commandPick.commandId)) {\n                    commandPicks.push({ type: 'separator', label: localize('recentlyUsed', \"recently used\") });\n                    addOtherSeparator = true;\n                }\n                // Separator: commonly used\n                if (addCommonlyUsedSeparator && !this.commandsHistory.peek(commandPick.commandId) && ((_a = this.options.suggestedCommandIds) === null || _a === void 0 ? void 0 : _a.has(commandPick.commandId))) {\n                    commandPicks.push({ type: 'separator', label: localize('commonlyUsed', \"commonly used\") });\n                    addOtherSeparator = true;\n                    addCommonlyUsedSeparator = false;\n                }\n                // Separator: other commands\n                if (addOtherSeparator && !this.commandsHistory.peek(commandPick.commandId) && !((_b = this.options.suggestedCommandIds) === null || _b === void 0 ? void 0 : _b.has(commandPick.commandId))) {\n                    commandPicks.push({ type: 'separator', label: localize('morecCommands', \"other commands\") });\n                    addOtherSeparator = false;\n                }\n                // Command\n                commandPicks.push(this.toCommandPick(commandPick, runOptions));\n            }\n            if (!this.hasAdditionalCommandPicks(filter, token)) {\n                return commandPicks;\n            }\n            return {\n                picks: commandPicks,\n                additionalPicks: (() => __awaiter(this, void 0, void 0, function* () {\n                    const additionalCommandPicks = yield this.getAdditionalCommandPicks(allCommandPicks, filteredCommandPicks, filter, token);\n                    if (token.isCancellationRequested) {\n                        return [];\n                    }\n                    return additionalCommandPicks.map(commandPick => this.toCommandPick(commandPick, runOptions));\n                }))()\n            };\n        });\n    }\n    toCommandPick(commandPick, runOptions) {\n        if (commandPick.type === 'separator') {\n            return commandPick;\n        }\n        const keybinding = this.keybindingService.lookupKeybinding(commandPick.commandId);\n        const ariaLabel = keybinding ?\n            localize('commandPickAriaLabelWithKeybinding', \"{0}, {1}\", commandPick.label, keybinding.getAriaLabel()) :\n            commandPick.label;\n        return Object.assign(Object.assign({}, commandPick), { ariaLabel, detail: this.options.showAlias && commandPick.commandAlias !== commandPick.label ? commandPick.commandAlias : undefined, keybinding, accept: () => __awaiter(this, void 0, void 0, function* () {\n                var _a, _b;\n                // Add to history\n                this.commandsHistory.push(commandPick.commandId);\n                // Telementry\n                this.telemetryService.publicLog2('workbenchActionExecuted', {\n                    id: commandPick.commandId,\n                    from: (_a = runOptions === null || runOptions === void 0 ? void 0 : runOptions.from) !== null && _a !== void 0 ? _a : 'quick open'\n                });\n                // Run\n                try {\n                    ((_b = commandPick.args) === null || _b === void 0 ? void 0 : _b.length)\n                        ? yield this.commandService.executeCommand(commandPick.commandId, ...commandPick.args)\n                        : yield this.commandService.executeCommand(commandPick.commandId);\n                }\n                catch (error) {\n                    if (!isCancellationError(error)) {\n                        this.dialogService.error(localize('canNotRun', \"Command '{0}' resulted in an error\", commandPick.label), toErrorMessage(error));\n                    }\n                }\n            }) });\n    }\n};\nAbstractCommandsQuickAccessProvider.PREFIX = '>';\nAbstractCommandsQuickAccessProvider.WORD_FILTER = or(matchesPrefix, matchesWords, matchesContiguousSubString);\nAbstractCommandsQuickAccessProvider = __decorate([\n    __param(1, IInstantiationService),\n    __param(2, IKeybindingService),\n    __param(3, ICommandService),\n    __param(4, ITelemetryService),\n    __param(5, IDialogService)\n], AbstractCommandsQuickAccessProvider);\nexport { AbstractCommandsQuickAccessProvider };\nlet CommandsHistory = class CommandsHistory extends Disposable {\n    constructor(storageService, configurationService) {\n        super();\n        this.storageService = storageService;\n        this.configurationService = configurationService;\n        this.configuredCommandsHistoryLength = 0;\n        this.updateConfiguration();\n        this.load();\n        this.registerListeners();\n    }\n    registerListeners() {\n        this._register(this.configurationService.onDidChangeConfiguration(e => this.updateConfiguration(e)));\n    }\n    updateConfiguration(e) {\n        if (e && !e.affectsConfiguration('workbench.commandPalette.history')) {\n            return;\n        }\n        this.configuredCommandsHistoryLength = CommandsHistory.getConfiguredCommandHistoryLength(this.configurationService);\n        if (CommandsHistory.cache && CommandsHistory.cache.limit !== this.configuredCommandsHistoryLength) {\n            CommandsHistory.cache.limit = this.configuredCommandsHistoryLength;\n            CommandsHistory.saveState(this.storageService);\n        }\n    }\n    load() {\n        const raw = this.storageService.get(CommandsHistory.PREF_KEY_CACHE, 0 /* StorageScope.PROFILE */);\n        let serializedCache;\n        if (raw) {\n            try {\n                serializedCache = JSON.parse(raw);\n            }\n            catch (error) {\n                // invalid data\n            }\n        }\n        const cache = CommandsHistory.cache = new LRUCache(this.configuredCommandsHistoryLength, 1);\n        if (serializedCache) {\n            let entries;\n            if (serializedCache.usesLRU) {\n                entries = serializedCache.entries;\n            }\n            else {\n                entries = serializedCache.entries.sort((a, b) => a.value - b.value);\n            }\n            entries.forEach(entry => cache.set(entry.key, entry.value));\n        }\n        CommandsHistory.counter = this.storageService.getNumber(CommandsHistory.PREF_KEY_COUNTER, 0 /* StorageScope.PROFILE */, CommandsHistory.counter);\n    }\n    push(commandId) {\n        if (!CommandsHistory.cache) {\n            return;\n        }\n        CommandsHistory.cache.set(commandId, CommandsHistory.counter++); // set counter to command\n        CommandsHistory.saveState(this.storageService);\n    }\n    peek(commandId) {\n        var _a;\n        return (_a = CommandsHistory.cache) === null || _a === void 0 ? void 0 : _a.peek(commandId);\n    }\n    static saveState(storageService) {\n        if (!CommandsHistory.cache) {\n            return;\n        }\n        const serializedCache = { usesLRU: true, entries: [] };\n        CommandsHistory.cache.forEach((value, key) => serializedCache.entries.push({ key, value }));\n        storageService.store(CommandsHistory.PREF_KEY_CACHE, JSON.stringify(serializedCache), 0 /* StorageScope.PROFILE */, 0 /* StorageTarget.USER */);\n        storageService.store(CommandsHistory.PREF_KEY_COUNTER, CommandsHistory.counter, 0 /* StorageScope.PROFILE */, 0 /* StorageTarget.USER */);\n    }\n    static getConfiguredCommandHistoryLength(configurationService) {\n        var _a, _b;\n        const config = configurationService.getValue();\n        const configuredCommandHistoryLength = (_b = (_a = config.workbench) === null || _a === void 0 ? void 0 : _a.commandPalette) === null || _b === void 0 ? void 0 : _b.history;\n        if (typeof configuredCommandHistoryLength === 'number') {\n            return configuredCommandHistoryLength;\n        }\n        return CommandsHistory.DEFAULT_COMMANDS_HISTORY_LENGTH;\n    }\n};\nCommandsHistory.DEFAULT_COMMANDS_HISTORY_LENGTH = 50;\nCommandsHistory.PREF_KEY_CACHE = 'commandPalette.mru.cache';\nCommandsHistory.PREF_KEY_COUNTER = 'commandPalette.mru.counter';\nCommandsHistory.counter = 1;\nCommandsHistory = __decorate([\n    __param(0, IStorageService),\n    __param(1, IConfigurationService)\n], CommandsHistory);\nexport { CommandsHistory };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
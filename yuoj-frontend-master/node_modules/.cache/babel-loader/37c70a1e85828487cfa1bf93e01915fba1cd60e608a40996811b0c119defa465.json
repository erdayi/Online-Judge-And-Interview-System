{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { makeInner, normalizeToArray } from '../util/model.js';\nimport { assert, bind, each, eqNaN, extend, hasOwn, indexOf, isArrayLike, keys, reduce } from 'zrender/lib/core/util.js';\nimport { cloneValue } from 'zrender/lib/animation/Animator.js';\nimport Displayable from 'zrender/lib/graphic/Displayable.js';\nimport { getAnimationConfig } from './basicTransition.js';\nimport { Path } from '../util/graphic.js';\nimport { warn } from '../util/log.js';\nimport { TRANSFORMABLE_PROPS } from 'zrender/lib/core/Transformable.js';\nvar LEGACY_TRANSFORM_PROPS_MAP = {\n  position: ['x', 'y'],\n  scale: ['scaleX', 'scaleY'],\n  origin: ['originX', 'originY']\n};\nvar LEGACY_TRANSFORM_PROPS = keys(LEGACY_TRANSFORM_PROPS_MAP);\nvar TRANSFORM_PROPS_MAP = reduce(TRANSFORMABLE_PROPS, function (obj, key) {\n  obj[key] = 1;\n  return obj;\n}, {});\nvar transformPropNamesStr = TRANSFORMABLE_PROPS.join(', ');\n// '' means root\nexport var ELEMENT_ANIMATABLE_PROPS = ['', 'style', 'shape', 'extra'];\n;\nvar transitionInnerStore = makeInner();\n;\nfunction getElementAnimationConfig(animationType, el, elOption, parentModel, dataIndex) {\n  var animationProp = animationType + \"Animation\";\n  var config = getAnimationConfig(animationType, parentModel, dataIndex) || {};\n  var userDuring = transitionInnerStore(el).userDuring;\n  // Only set when duration is > 0 and it's need to be animated.\n  if (config.duration > 0) {\n    // For simplicity, if during not specified, the previous during will not work any more.\n    config.during = userDuring ? bind(duringCall, {\n      el: el,\n      userDuring: userDuring\n    }) : null;\n    config.setToFinal = true;\n    config.scope = animationType;\n  }\n  extend(config, elOption[animationProp]);\n  return config;\n}\nexport function applyUpdateTransition(el, elOption, animatableModel, opts) {\n  opts = opts || {};\n  var dataIndex = opts.dataIndex,\n    isInit = opts.isInit,\n    clearStyle = opts.clearStyle;\n  var hasAnimation = animatableModel.isAnimationEnabled();\n  // Save the meta info for further morphing. Like apply on the sub morphing elements.\n  var store = transitionInnerStore(el);\n  var styleOpt = elOption.style;\n  store.userDuring = elOption.during;\n  var transFromProps = {};\n  var propsToSet = {};\n  prepareTransformAllPropsFinal(el, elOption, propsToSet);\n  if (el.type === 'compound') {\n    /**\n     * We cannot directly clone shape for compoundPath,\n     * because it makes the path to be an object instead of a Path instance,\n     * and thus missing `buildPath` method.\n     */\n    var paths = el.shape.paths;\n    var optionPaths = elOption.shape.paths;\n    for (var i = 0; i < optionPaths.length; i++) {\n      var path = optionPaths[i];\n      prepareShapeOrExtraAllPropsFinal('shape', path, paths[i]);\n    }\n  } else {\n    prepareShapeOrExtraAllPropsFinal('shape', elOption, propsToSet);\n    prepareShapeOrExtraAllPropsFinal('extra', elOption, propsToSet);\n  }\n  if (!isInit && hasAnimation) {\n    prepareTransformTransitionFrom(el, elOption, transFromProps);\n    prepareShapeOrExtraTransitionFrom('shape', el, elOption, transFromProps);\n    prepareShapeOrExtraTransitionFrom('extra', el, elOption, transFromProps);\n    prepareStyleTransitionFrom(el, elOption, styleOpt, transFromProps);\n  }\n  propsToSet.style = styleOpt;\n  applyPropsDirectly(el, propsToSet, clearStyle);\n  applyMiscProps(el, elOption);\n  if (hasAnimation) {\n    if (isInit) {\n      var enterFromProps_1 = {};\n      each(ELEMENT_ANIMATABLE_PROPS, function (propName) {\n        var prop = propName ? elOption[propName] : elOption;\n        if (prop && prop.enterFrom) {\n          if (propName) {\n            enterFromProps_1[propName] = enterFromProps_1[propName] || {};\n          }\n          extend(propName ? enterFromProps_1[propName] : enterFromProps_1, prop.enterFrom);\n        }\n      });\n      var config = getElementAnimationConfig('enter', el, elOption, animatableModel, dataIndex);\n      if (config.duration > 0) {\n        el.animateFrom(enterFromProps_1, config);\n      }\n    } else {\n      applyPropsTransition(el, elOption, dataIndex || 0, animatableModel, transFromProps);\n    }\n  }\n  // Store leave to be used in leave transition.\n  updateLeaveTo(el, elOption);\n  styleOpt ? el.dirty() : el.markRedraw();\n}\nexport function updateLeaveTo(el, elOption) {\n  // Try merge to previous set leaveTo\n  var leaveToProps = transitionInnerStore(el).leaveToProps;\n  for (var i = 0; i < ELEMENT_ANIMATABLE_PROPS.length; i++) {\n    var propName = ELEMENT_ANIMATABLE_PROPS[i];\n    var prop = propName ? elOption[propName] : elOption;\n    if (prop && prop.leaveTo) {\n      if (!leaveToProps) {\n        leaveToProps = transitionInnerStore(el).leaveToProps = {};\n      }\n      if (propName) {\n        leaveToProps[propName] = leaveToProps[propName] || {};\n      }\n      extend(propName ? leaveToProps[propName] : leaveToProps, prop.leaveTo);\n    }\n  }\n}\nexport function applyLeaveTransition(el, elOption, animatableModel, onRemove) {\n  if (el) {\n    var parent_1 = el.parent;\n    var leaveToProps = transitionInnerStore(el).leaveToProps;\n    if (leaveToProps) {\n      // TODO TODO use leave after leaveAnimation in series is introduced\n      // TODO Data index?\n      var config = getElementAnimationConfig('update', el, elOption, animatableModel, 0);\n      config.done = function () {\n        parent_1 && parent_1.remove(el);\n        onRemove && onRemove();\n      };\n      el.animateTo(leaveToProps, config);\n    } else {\n      parent_1 && parent_1.remove(el);\n      onRemove && onRemove();\n    }\n  }\n}\nexport function isTransitionAll(transition) {\n  return transition === 'all';\n}\nfunction applyPropsDirectly(el,\n// Can be null/undefined\nallPropsFinal, clearStyle) {\n  var styleOpt = allPropsFinal.style;\n  if (!el.isGroup && styleOpt) {\n    if (clearStyle) {\n      el.useStyle({});\n      // When style object changed, how to trade the existing animation?\n      // It is probably complicated and not needed to cover all the cases.\n      // But still need consider the case:\n      // (1) When using init animation on `style.opacity`, and before the animation\n      //     ended users triggers an update by mousewhel. At that time the init\n      //     animation should better be continued rather than terminated.\n      //     So after `useStyle` called, we should change the animation target manually\n      //     to continue the effect of the init animation.\n      // (2) PENDING: If the previous animation targeted at a `val1`, and currently we need\n      //     to update the value to `val2` and no animation declared, should be terminate\n      //     the previous animation or just modify the target of the animation?\n      //     Therotically That will happen not only on `style` but also on `shape` and\n      //     `transfrom` props. But we haven't handle this case at present yet.\n      // (3) PENDING: Is it proper to visit `animators` and `targetName`?\n      var animators = el.animators;\n      for (var i = 0; i < animators.length; i++) {\n        var animator = animators[i];\n        // targetName is the \"topKey\".\n        if (animator.targetName === 'style') {\n          animator.changeTarget(el.style);\n        }\n      }\n    }\n    el.setStyle(styleOpt);\n  }\n  if (allPropsFinal) {\n    // Not set style here.\n    allPropsFinal.style = null;\n    // Set el to the final state firstly.\n    allPropsFinal && el.attr(allPropsFinal);\n    allPropsFinal.style = styleOpt;\n  }\n}\nfunction applyPropsTransition(el, elOption, dataIndex, model,\n// Can be null/undefined\ntransFromProps) {\n  if (transFromProps) {\n    var config = getElementAnimationConfig('update', el, elOption, model, dataIndex);\n    if (config.duration > 0) {\n      el.animateFrom(transFromProps, config);\n    }\n  }\n}\nfunction applyMiscProps(el, elOption) {\n  // Merge by default.\n  hasOwn(elOption, 'silent') && (el.silent = elOption.silent);\n  hasOwn(elOption, 'ignore') && (el.ignore = elOption.ignore);\n  if (el instanceof Displayable) {\n    hasOwn(elOption, 'invisible') && (el.invisible = elOption.invisible);\n  }\n  if (el instanceof Path) {\n    hasOwn(elOption, 'autoBatch') && (el.autoBatch = elOption.autoBatch);\n  }\n}\n// Use it to avoid it be exposed to user.\nvar tmpDuringScope = {};\nvar transitionDuringAPI = {\n  // Usually other props do not need to be changed in animation during.\n  setTransform: function (key, val) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(hasOwn(TRANSFORM_PROPS_MAP, key), 'Only ' + transformPropNamesStr + ' available in `setTransform`.');\n    }\n    tmpDuringScope.el[key] = val;\n    return this;\n  },\n  getTransform: function (key) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(hasOwn(TRANSFORM_PROPS_MAP, key), 'Only ' + transformPropNamesStr + ' available in `getTransform`.');\n    }\n    return tmpDuringScope.el[key];\n  },\n  setShape: function (key, val) {\n    if (process.env.NODE_ENV !== 'production') {\n      assertNotReserved(key);\n    }\n    var el = tmpDuringScope.el;\n    var shape = el.shape || (el.shape = {});\n    shape[key] = val;\n    el.dirtyShape && el.dirtyShape();\n    return this;\n  },\n  getShape: function (key) {\n    if (process.env.NODE_ENV !== 'production') {\n      assertNotReserved(key);\n    }\n    var shape = tmpDuringScope.el.shape;\n    if (shape) {\n      return shape[key];\n    }\n  },\n  setStyle: function (key, val) {\n    if (process.env.NODE_ENV !== 'production') {\n      assertNotReserved(key);\n    }\n    var el = tmpDuringScope.el;\n    var style = el.style;\n    if (style) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (eqNaN(val)) {\n          warn('style.' + key + ' must not be assigned with NaN.');\n        }\n      }\n      style[key] = val;\n      el.dirtyStyle && el.dirtyStyle();\n    }\n    return this;\n  },\n  getStyle: function (key) {\n    if (process.env.NODE_ENV !== 'production') {\n      assertNotReserved(key);\n    }\n    var style = tmpDuringScope.el.style;\n    if (style) {\n      return style[key];\n    }\n  },\n  setExtra: function (key, val) {\n    if (process.env.NODE_ENV !== 'production') {\n      assertNotReserved(key);\n    }\n    var extra = tmpDuringScope.el.extra || (tmpDuringScope.el.extra = {});\n    extra[key] = val;\n    return this;\n  },\n  getExtra: function (key) {\n    if (process.env.NODE_ENV !== 'production') {\n      assertNotReserved(key);\n    }\n    var extra = tmpDuringScope.el.extra;\n    if (extra) {\n      return extra[key];\n    }\n  }\n};\nfunction assertNotReserved(key) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (key === 'transition' || key === 'enterFrom' || key === 'leaveTo') {\n      throw new Error('key must not be \"' + key + '\"');\n    }\n  }\n}\nfunction duringCall() {\n  // Do not provide \"percent\" until some requirements come.\n  // Because consider thies case:\n  // enterFrom: {x: 100, y: 30}, transition: 'x'.\n  // And enter duration is different from update duration.\n  // Thus it might be confused about the meaning of \"percent\" in during callback.\n  var scope = this;\n  var el = scope.el;\n  if (!el) {\n    return;\n  }\n  // If el is remove from zr by reason like legend, during still need to called,\n  // because el will be added back to zr and the prop value should not be incorrect.\n  var latestUserDuring = transitionInnerStore(el).userDuring;\n  var scopeUserDuring = scope.userDuring;\n  // Ensured a during is only called once in each animation frame.\n  // If a during is called multiple times in one frame, maybe some users' calculation logic\n  // might be wrong (not sure whether this usage exists).\n  // The case of a during might be called twice can be: by default there is a animator for\n  // 'x', 'y' when init. Before the init animation finished, call `setOption` to start\n  // another animators for 'style'/'shape'/'extra'.\n  if (latestUserDuring !== scopeUserDuring) {\n    // release\n    scope.el = scope.userDuring = null;\n    return;\n  }\n  tmpDuringScope.el = el;\n  // Give no `this` to user in \"during\" calling.\n  scopeUserDuring(transitionDuringAPI);\n  // FIXME: if in future meet the case that some prop will be both modified in `during` and `state`,\n  // consider the issue that the prop might be incorrect when return to \"normal\" state.\n}\n\nfunction prepareShapeOrExtraTransitionFrom(mainAttr, fromEl, elOption, transFromProps) {\n  var attrOpt = elOption[mainAttr];\n  if (!attrOpt) {\n    return;\n  }\n  var elPropsInAttr = fromEl[mainAttr];\n  var transFromPropsInAttr;\n  if (elPropsInAttr) {\n    var transition = elOption.transition;\n    var attrTransition = attrOpt.transition;\n    if (attrTransition) {\n      !transFromPropsInAttr && (transFromPropsInAttr = transFromProps[mainAttr] = {});\n      if (isTransitionAll(attrTransition)) {\n        extend(transFromPropsInAttr, elPropsInAttr);\n      } else {\n        var transitionKeys = normalizeToArray(attrTransition);\n        for (var i = 0; i < transitionKeys.length; i++) {\n          var key = transitionKeys[i];\n          var elVal = elPropsInAttr[key];\n          transFromPropsInAttr[key] = elVal;\n        }\n      }\n    } else if (isTransitionAll(transition) || indexOf(transition, mainAttr) >= 0) {\n      !transFromPropsInAttr && (transFromPropsInAttr = transFromProps[mainAttr] = {});\n      var elPropsInAttrKeys = keys(elPropsInAttr);\n      for (var i = 0; i < elPropsInAttrKeys.length; i++) {\n        var key = elPropsInAttrKeys[i];\n        var elVal = elPropsInAttr[key];\n        if (isNonStyleTransitionEnabled(attrOpt[key], elVal)) {\n          transFromPropsInAttr[key] = elVal;\n        }\n      }\n    }\n  }\n}\nfunction prepareShapeOrExtraAllPropsFinal(mainAttr, elOption, allProps) {\n  var attrOpt = elOption[mainAttr];\n  if (!attrOpt) {\n    return;\n  }\n  var allPropsInAttr = allProps[mainAttr] = {};\n  var keysInAttr = keys(attrOpt);\n  for (var i = 0; i < keysInAttr.length; i++) {\n    var key = keysInAttr[i];\n    // To avoid share one object with different element, and\n    // to avoid user modify the object inexpectedly, have to clone.\n    allPropsInAttr[key] = cloneValue(attrOpt[key]);\n  }\n}\nfunction prepareTransformTransitionFrom(el, elOption, transFromProps) {\n  var transition = elOption.transition;\n  var transitionKeys = isTransitionAll(transition) ? TRANSFORMABLE_PROPS : normalizeToArray(transition || []);\n  for (var i = 0; i < transitionKeys.length; i++) {\n    var key = transitionKeys[i];\n    if (key === 'style' || key === 'shape' || key === 'extra') {\n      continue;\n    }\n    var elVal = el[key];\n    if (process.env.NODE_ENV !== 'production') {\n      checkTransformPropRefer(key, 'el.transition');\n    }\n    // Do not clone, animator will perform that clone.\n    transFromProps[key] = elVal;\n  }\n}\nfunction prepareTransformAllPropsFinal(el, elOption, allProps) {\n  for (var i = 0; i < LEGACY_TRANSFORM_PROPS.length; i++) {\n    var legacyName = LEGACY_TRANSFORM_PROPS[i];\n    var xyName = LEGACY_TRANSFORM_PROPS_MAP[legacyName];\n    var legacyArr = elOption[legacyName];\n    if (legacyArr) {\n      allProps[xyName[0]] = legacyArr[0];\n      allProps[xyName[1]] = legacyArr[1];\n    }\n  }\n  for (var i = 0; i < TRANSFORMABLE_PROPS.length; i++) {\n    var key = TRANSFORMABLE_PROPS[i];\n    if (elOption[key] != null) {\n      allProps[key] = elOption[key];\n    }\n  }\n}\nfunction prepareStyleTransitionFrom(fromEl, elOption, styleOpt, transFromProps) {\n  if (!styleOpt) {\n    return;\n  }\n  var fromElStyle = fromEl.style;\n  var transFromStyleProps;\n  if (fromElStyle) {\n    var styleTransition = styleOpt.transition;\n    var elTransition = elOption.transition;\n    if (styleTransition && !isTransitionAll(styleTransition)) {\n      var transitionKeys = normalizeToArray(styleTransition);\n      !transFromStyleProps && (transFromStyleProps = transFromProps.style = {});\n      for (var i = 0; i < transitionKeys.length; i++) {\n        var key = transitionKeys[i];\n        var elVal = fromElStyle[key];\n        // Do not clone, see `checkNonStyleTansitionRefer`.\n        transFromStyleProps[key] = elVal;\n      }\n    } else if (fromEl.getAnimationStyleProps && (isTransitionAll(elTransition) || isTransitionAll(styleTransition) || indexOf(elTransition, 'style') >= 0)) {\n      var animationProps = fromEl.getAnimationStyleProps();\n      var animationStyleProps = animationProps ? animationProps.style : null;\n      if (animationStyleProps) {\n        !transFromStyleProps && (transFromStyleProps = transFromProps.style = {});\n        var styleKeys = keys(styleOpt);\n        for (var i = 0; i < styleKeys.length; i++) {\n          var key = styleKeys[i];\n          if (animationStyleProps[key]) {\n            var elVal = fromElStyle[key];\n            transFromStyleProps[key] = elVal;\n          }\n        }\n      }\n    }\n  }\n}\nfunction isNonStyleTransitionEnabled(optVal, elVal) {\n  // The same as `checkNonStyleTansitionRefer`.\n  return !isArrayLike(optVal) ? optVal != null && isFinite(optVal) : optVal !== elVal;\n}\nvar checkTransformPropRefer;\nif (process.env.NODE_ENV !== 'production') {\n  checkTransformPropRefer = function (key, usedIn) {\n    if (!hasOwn(TRANSFORM_PROPS_MAP, key)) {\n      warn('Prop `' + key + '` is not a permitted in `' + usedIn + '`. ' + 'Only `' + keys(TRANSFORM_PROPS_MAP).join('`, `') + '` are permitted.');\n    }\n  };\n}","map":{"version":3,"names":["makeInner","normalizeToArray","assert","bind","each","eqNaN","extend","hasOwn","indexOf","isArrayLike","keys","reduce","cloneValue","Displayable","getAnimationConfig","Path","warn","TRANSFORMABLE_PROPS","LEGACY_TRANSFORM_PROPS_MAP","position","scale","origin","LEGACY_TRANSFORM_PROPS","TRANSFORM_PROPS_MAP","obj","key","transformPropNamesStr","join","ELEMENT_ANIMATABLE_PROPS","transitionInnerStore","getElementAnimationConfig","animationType","el","elOption","parentModel","dataIndex","animationProp","config","userDuring","duration","during","duringCall","setToFinal","scope","applyUpdateTransition","animatableModel","opts","isInit","clearStyle","hasAnimation","isAnimationEnabled","store","styleOpt","style","transFromProps","propsToSet","prepareTransformAllPropsFinal","type","paths","shape","optionPaths","i","length","path","prepareShapeOrExtraAllPropsFinal","prepareTransformTransitionFrom","prepareShapeOrExtraTransitionFrom","prepareStyleTransitionFrom","applyPropsDirectly","applyMiscProps","enterFromProps_1","propName","prop","enterFrom","animateFrom","applyPropsTransition","updateLeaveTo","dirty","markRedraw","leaveToProps","leaveTo","applyLeaveTransition","onRemove","parent_1","parent","done","remove","animateTo","isTransitionAll","transition","allPropsFinal","isGroup","useStyle","animators","animator","targetName","changeTarget","setStyle","attr","model","silent","ignore","invisible","autoBatch","tmpDuringScope","transitionDuringAPI","setTransform","val","process","env","NODE_ENV","getTransform","setShape","assertNotReserved","dirtyShape","getShape","dirtyStyle","getStyle","setExtra","extra","getExtra","Error","latestUserDuring","scopeUserDuring","mainAttr","fromEl","attrOpt","elPropsInAttr","transFromPropsInAttr","attrTransition","transitionKeys","elVal","elPropsInAttrKeys","isNonStyleTransitionEnabled","allProps","allPropsInAttr","keysInAttr","checkTransformPropRefer","legacyName","xyName","legacyArr","fromElStyle","transFromStyleProps","styleTransition","elTransition","getAnimationStyleProps","animationProps","animationStyleProps","styleKeys","optVal","isFinite","usedIn"],"sources":["D:/code/java/program/oj/code/yuoj-frontend-master/node_modules/echarts/lib/animation/customGraphicTransition.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { makeInner, normalizeToArray } from '../util/model.js';\nimport { assert, bind, each, eqNaN, extend, hasOwn, indexOf, isArrayLike, keys, reduce } from 'zrender/lib/core/util.js';\nimport { cloneValue } from 'zrender/lib/animation/Animator.js';\nimport Displayable from 'zrender/lib/graphic/Displayable.js';\nimport { getAnimationConfig } from './basicTransition.js';\nimport { Path } from '../util/graphic.js';\nimport { warn } from '../util/log.js';\nimport { TRANSFORMABLE_PROPS } from 'zrender/lib/core/Transformable.js';\nvar LEGACY_TRANSFORM_PROPS_MAP = {\n  position: ['x', 'y'],\n  scale: ['scaleX', 'scaleY'],\n  origin: ['originX', 'originY']\n};\nvar LEGACY_TRANSFORM_PROPS = keys(LEGACY_TRANSFORM_PROPS_MAP);\nvar TRANSFORM_PROPS_MAP = reduce(TRANSFORMABLE_PROPS, function (obj, key) {\n  obj[key] = 1;\n  return obj;\n}, {});\nvar transformPropNamesStr = TRANSFORMABLE_PROPS.join(', ');\n// '' means root\nexport var ELEMENT_ANIMATABLE_PROPS = ['', 'style', 'shape', 'extra'];\n;\nvar transitionInnerStore = makeInner();\n;\nfunction getElementAnimationConfig(animationType, el, elOption, parentModel, dataIndex) {\n  var animationProp = animationType + \"Animation\";\n  var config = getAnimationConfig(animationType, parentModel, dataIndex) || {};\n  var userDuring = transitionInnerStore(el).userDuring;\n  // Only set when duration is > 0 and it's need to be animated.\n  if (config.duration > 0) {\n    // For simplicity, if during not specified, the previous during will not work any more.\n    config.during = userDuring ? bind(duringCall, {\n      el: el,\n      userDuring: userDuring\n    }) : null;\n    config.setToFinal = true;\n    config.scope = animationType;\n  }\n  extend(config, elOption[animationProp]);\n  return config;\n}\nexport function applyUpdateTransition(el, elOption, animatableModel, opts) {\n  opts = opts || {};\n  var dataIndex = opts.dataIndex,\n    isInit = opts.isInit,\n    clearStyle = opts.clearStyle;\n  var hasAnimation = animatableModel.isAnimationEnabled();\n  // Save the meta info for further morphing. Like apply on the sub morphing elements.\n  var store = transitionInnerStore(el);\n  var styleOpt = elOption.style;\n  store.userDuring = elOption.during;\n  var transFromProps = {};\n  var propsToSet = {};\n  prepareTransformAllPropsFinal(el, elOption, propsToSet);\n  if (el.type === 'compound') {\n    /**\n     * We cannot directly clone shape for compoundPath,\n     * because it makes the path to be an object instead of a Path instance,\n     * and thus missing `buildPath` method.\n     */\n    var paths = el.shape.paths;\n    var optionPaths = elOption.shape.paths;\n    for (var i = 0; i < optionPaths.length; i++) {\n      var path = optionPaths[i];\n      prepareShapeOrExtraAllPropsFinal('shape', path, paths[i]);\n    }\n  } else {\n    prepareShapeOrExtraAllPropsFinal('shape', elOption, propsToSet);\n    prepareShapeOrExtraAllPropsFinal('extra', elOption, propsToSet);\n  }\n  if (!isInit && hasAnimation) {\n    prepareTransformTransitionFrom(el, elOption, transFromProps);\n    prepareShapeOrExtraTransitionFrom('shape', el, elOption, transFromProps);\n    prepareShapeOrExtraTransitionFrom('extra', el, elOption, transFromProps);\n    prepareStyleTransitionFrom(el, elOption, styleOpt, transFromProps);\n  }\n  propsToSet.style = styleOpt;\n  applyPropsDirectly(el, propsToSet, clearStyle);\n  applyMiscProps(el, elOption);\n  if (hasAnimation) {\n    if (isInit) {\n      var enterFromProps_1 = {};\n      each(ELEMENT_ANIMATABLE_PROPS, function (propName) {\n        var prop = propName ? elOption[propName] : elOption;\n        if (prop && prop.enterFrom) {\n          if (propName) {\n            enterFromProps_1[propName] = enterFromProps_1[propName] || {};\n          }\n          extend(propName ? enterFromProps_1[propName] : enterFromProps_1, prop.enterFrom);\n        }\n      });\n      var config = getElementAnimationConfig('enter', el, elOption, animatableModel, dataIndex);\n      if (config.duration > 0) {\n        el.animateFrom(enterFromProps_1, config);\n      }\n    } else {\n      applyPropsTransition(el, elOption, dataIndex || 0, animatableModel, transFromProps);\n    }\n  }\n  // Store leave to be used in leave transition.\n  updateLeaveTo(el, elOption);\n  styleOpt ? el.dirty() : el.markRedraw();\n}\nexport function updateLeaveTo(el, elOption) {\n  // Try merge to previous set leaveTo\n  var leaveToProps = transitionInnerStore(el).leaveToProps;\n  for (var i = 0; i < ELEMENT_ANIMATABLE_PROPS.length; i++) {\n    var propName = ELEMENT_ANIMATABLE_PROPS[i];\n    var prop = propName ? elOption[propName] : elOption;\n    if (prop && prop.leaveTo) {\n      if (!leaveToProps) {\n        leaveToProps = transitionInnerStore(el).leaveToProps = {};\n      }\n      if (propName) {\n        leaveToProps[propName] = leaveToProps[propName] || {};\n      }\n      extend(propName ? leaveToProps[propName] : leaveToProps, prop.leaveTo);\n    }\n  }\n}\nexport function applyLeaveTransition(el, elOption, animatableModel, onRemove) {\n  if (el) {\n    var parent_1 = el.parent;\n    var leaveToProps = transitionInnerStore(el).leaveToProps;\n    if (leaveToProps) {\n      // TODO TODO use leave after leaveAnimation in series is introduced\n      // TODO Data index?\n      var config = getElementAnimationConfig('update', el, elOption, animatableModel, 0);\n      config.done = function () {\n        parent_1 && parent_1.remove(el);\n        onRemove && onRemove();\n      };\n      el.animateTo(leaveToProps, config);\n    } else {\n      parent_1 && parent_1.remove(el);\n      onRemove && onRemove();\n    }\n  }\n}\nexport function isTransitionAll(transition) {\n  return transition === 'all';\n}\nfunction applyPropsDirectly(el,\n// Can be null/undefined\nallPropsFinal, clearStyle) {\n  var styleOpt = allPropsFinal.style;\n  if (!el.isGroup && styleOpt) {\n    if (clearStyle) {\n      el.useStyle({});\n      // When style object changed, how to trade the existing animation?\n      // It is probably complicated and not needed to cover all the cases.\n      // But still need consider the case:\n      // (1) When using init animation on `style.opacity`, and before the animation\n      //     ended users triggers an update by mousewhel. At that time the init\n      //     animation should better be continued rather than terminated.\n      //     So after `useStyle` called, we should change the animation target manually\n      //     to continue the effect of the init animation.\n      // (2) PENDING: If the previous animation targeted at a `val1`, and currently we need\n      //     to update the value to `val2` and no animation declared, should be terminate\n      //     the previous animation or just modify the target of the animation?\n      //     Therotically That will happen not only on `style` but also on `shape` and\n      //     `transfrom` props. But we haven't handle this case at present yet.\n      // (3) PENDING: Is it proper to visit `animators` and `targetName`?\n      var animators = el.animators;\n      for (var i = 0; i < animators.length; i++) {\n        var animator = animators[i];\n        // targetName is the \"topKey\".\n        if (animator.targetName === 'style') {\n          animator.changeTarget(el.style);\n        }\n      }\n    }\n    el.setStyle(styleOpt);\n  }\n  if (allPropsFinal) {\n    // Not set style here.\n    allPropsFinal.style = null;\n    // Set el to the final state firstly.\n    allPropsFinal && el.attr(allPropsFinal);\n    allPropsFinal.style = styleOpt;\n  }\n}\nfunction applyPropsTransition(el, elOption, dataIndex, model,\n// Can be null/undefined\ntransFromProps) {\n  if (transFromProps) {\n    var config = getElementAnimationConfig('update', el, elOption, model, dataIndex);\n    if (config.duration > 0) {\n      el.animateFrom(transFromProps, config);\n    }\n  }\n}\nfunction applyMiscProps(el, elOption) {\n  // Merge by default.\n  hasOwn(elOption, 'silent') && (el.silent = elOption.silent);\n  hasOwn(elOption, 'ignore') && (el.ignore = elOption.ignore);\n  if (el instanceof Displayable) {\n    hasOwn(elOption, 'invisible') && (el.invisible = elOption.invisible);\n  }\n  if (el instanceof Path) {\n    hasOwn(elOption, 'autoBatch') && (el.autoBatch = elOption.autoBatch);\n  }\n}\n// Use it to avoid it be exposed to user.\nvar tmpDuringScope = {};\nvar transitionDuringAPI = {\n  // Usually other props do not need to be changed in animation during.\n  setTransform: function (key, val) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(hasOwn(TRANSFORM_PROPS_MAP, key), 'Only ' + transformPropNamesStr + ' available in `setTransform`.');\n    }\n    tmpDuringScope.el[key] = val;\n    return this;\n  },\n  getTransform: function (key) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(hasOwn(TRANSFORM_PROPS_MAP, key), 'Only ' + transformPropNamesStr + ' available in `getTransform`.');\n    }\n    return tmpDuringScope.el[key];\n  },\n  setShape: function (key, val) {\n    if (process.env.NODE_ENV !== 'production') {\n      assertNotReserved(key);\n    }\n    var el = tmpDuringScope.el;\n    var shape = el.shape || (el.shape = {});\n    shape[key] = val;\n    el.dirtyShape && el.dirtyShape();\n    return this;\n  },\n  getShape: function (key) {\n    if (process.env.NODE_ENV !== 'production') {\n      assertNotReserved(key);\n    }\n    var shape = tmpDuringScope.el.shape;\n    if (shape) {\n      return shape[key];\n    }\n  },\n  setStyle: function (key, val) {\n    if (process.env.NODE_ENV !== 'production') {\n      assertNotReserved(key);\n    }\n    var el = tmpDuringScope.el;\n    var style = el.style;\n    if (style) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (eqNaN(val)) {\n          warn('style.' + key + ' must not be assigned with NaN.');\n        }\n      }\n      style[key] = val;\n      el.dirtyStyle && el.dirtyStyle();\n    }\n    return this;\n  },\n  getStyle: function (key) {\n    if (process.env.NODE_ENV !== 'production') {\n      assertNotReserved(key);\n    }\n    var style = tmpDuringScope.el.style;\n    if (style) {\n      return style[key];\n    }\n  },\n  setExtra: function (key, val) {\n    if (process.env.NODE_ENV !== 'production') {\n      assertNotReserved(key);\n    }\n    var extra = tmpDuringScope.el.extra || (tmpDuringScope.el.extra = {});\n    extra[key] = val;\n    return this;\n  },\n  getExtra: function (key) {\n    if (process.env.NODE_ENV !== 'production') {\n      assertNotReserved(key);\n    }\n    var extra = tmpDuringScope.el.extra;\n    if (extra) {\n      return extra[key];\n    }\n  }\n};\nfunction assertNotReserved(key) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (key === 'transition' || key === 'enterFrom' || key === 'leaveTo') {\n      throw new Error('key must not be \"' + key + '\"');\n    }\n  }\n}\nfunction duringCall() {\n  // Do not provide \"percent\" until some requirements come.\n  // Because consider thies case:\n  // enterFrom: {x: 100, y: 30}, transition: 'x'.\n  // And enter duration is different from update duration.\n  // Thus it might be confused about the meaning of \"percent\" in during callback.\n  var scope = this;\n  var el = scope.el;\n  if (!el) {\n    return;\n  }\n  // If el is remove from zr by reason like legend, during still need to called,\n  // because el will be added back to zr and the prop value should not be incorrect.\n  var latestUserDuring = transitionInnerStore(el).userDuring;\n  var scopeUserDuring = scope.userDuring;\n  // Ensured a during is only called once in each animation frame.\n  // If a during is called multiple times in one frame, maybe some users' calculation logic\n  // might be wrong (not sure whether this usage exists).\n  // The case of a during might be called twice can be: by default there is a animator for\n  // 'x', 'y' when init. Before the init animation finished, call `setOption` to start\n  // another animators for 'style'/'shape'/'extra'.\n  if (latestUserDuring !== scopeUserDuring) {\n    // release\n    scope.el = scope.userDuring = null;\n    return;\n  }\n  tmpDuringScope.el = el;\n  // Give no `this` to user in \"during\" calling.\n  scopeUserDuring(transitionDuringAPI);\n  // FIXME: if in future meet the case that some prop will be both modified in `during` and `state`,\n  // consider the issue that the prop might be incorrect when return to \"normal\" state.\n}\nfunction prepareShapeOrExtraTransitionFrom(mainAttr, fromEl, elOption, transFromProps) {\n  var attrOpt = elOption[mainAttr];\n  if (!attrOpt) {\n    return;\n  }\n  var elPropsInAttr = fromEl[mainAttr];\n  var transFromPropsInAttr;\n  if (elPropsInAttr) {\n    var transition = elOption.transition;\n    var attrTransition = attrOpt.transition;\n    if (attrTransition) {\n      !transFromPropsInAttr && (transFromPropsInAttr = transFromProps[mainAttr] = {});\n      if (isTransitionAll(attrTransition)) {\n        extend(transFromPropsInAttr, elPropsInAttr);\n      } else {\n        var transitionKeys = normalizeToArray(attrTransition);\n        for (var i = 0; i < transitionKeys.length; i++) {\n          var key = transitionKeys[i];\n          var elVal = elPropsInAttr[key];\n          transFromPropsInAttr[key] = elVal;\n        }\n      }\n    } else if (isTransitionAll(transition) || indexOf(transition, mainAttr) >= 0) {\n      !transFromPropsInAttr && (transFromPropsInAttr = transFromProps[mainAttr] = {});\n      var elPropsInAttrKeys = keys(elPropsInAttr);\n      for (var i = 0; i < elPropsInAttrKeys.length; i++) {\n        var key = elPropsInAttrKeys[i];\n        var elVal = elPropsInAttr[key];\n        if (isNonStyleTransitionEnabled(attrOpt[key], elVal)) {\n          transFromPropsInAttr[key] = elVal;\n        }\n      }\n    }\n  }\n}\nfunction prepareShapeOrExtraAllPropsFinal(mainAttr, elOption, allProps) {\n  var attrOpt = elOption[mainAttr];\n  if (!attrOpt) {\n    return;\n  }\n  var allPropsInAttr = allProps[mainAttr] = {};\n  var keysInAttr = keys(attrOpt);\n  for (var i = 0; i < keysInAttr.length; i++) {\n    var key = keysInAttr[i];\n    // To avoid share one object with different element, and\n    // to avoid user modify the object inexpectedly, have to clone.\n    allPropsInAttr[key] = cloneValue(attrOpt[key]);\n  }\n}\nfunction prepareTransformTransitionFrom(el, elOption, transFromProps) {\n  var transition = elOption.transition;\n  var transitionKeys = isTransitionAll(transition) ? TRANSFORMABLE_PROPS : normalizeToArray(transition || []);\n  for (var i = 0; i < transitionKeys.length; i++) {\n    var key = transitionKeys[i];\n    if (key === 'style' || key === 'shape' || key === 'extra') {\n      continue;\n    }\n    var elVal = el[key];\n    if (process.env.NODE_ENV !== 'production') {\n      checkTransformPropRefer(key, 'el.transition');\n    }\n    // Do not clone, animator will perform that clone.\n    transFromProps[key] = elVal;\n  }\n}\nfunction prepareTransformAllPropsFinal(el, elOption, allProps) {\n  for (var i = 0; i < LEGACY_TRANSFORM_PROPS.length; i++) {\n    var legacyName = LEGACY_TRANSFORM_PROPS[i];\n    var xyName = LEGACY_TRANSFORM_PROPS_MAP[legacyName];\n    var legacyArr = elOption[legacyName];\n    if (legacyArr) {\n      allProps[xyName[0]] = legacyArr[0];\n      allProps[xyName[1]] = legacyArr[1];\n    }\n  }\n  for (var i = 0; i < TRANSFORMABLE_PROPS.length; i++) {\n    var key = TRANSFORMABLE_PROPS[i];\n    if (elOption[key] != null) {\n      allProps[key] = elOption[key];\n    }\n  }\n}\nfunction prepareStyleTransitionFrom(fromEl, elOption, styleOpt, transFromProps) {\n  if (!styleOpt) {\n    return;\n  }\n  var fromElStyle = fromEl.style;\n  var transFromStyleProps;\n  if (fromElStyle) {\n    var styleTransition = styleOpt.transition;\n    var elTransition = elOption.transition;\n    if (styleTransition && !isTransitionAll(styleTransition)) {\n      var transitionKeys = normalizeToArray(styleTransition);\n      !transFromStyleProps && (transFromStyleProps = transFromProps.style = {});\n      for (var i = 0; i < transitionKeys.length; i++) {\n        var key = transitionKeys[i];\n        var elVal = fromElStyle[key];\n        // Do not clone, see `checkNonStyleTansitionRefer`.\n        transFromStyleProps[key] = elVal;\n      }\n    } else if (fromEl.getAnimationStyleProps && (isTransitionAll(elTransition) || isTransitionAll(styleTransition) || indexOf(elTransition, 'style') >= 0)) {\n      var animationProps = fromEl.getAnimationStyleProps();\n      var animationStyleProps = animationProps ? animationProps.style : null;\n      if (animationStyleProps) {\n        !transFromStyleProps && (transFromStyleProps = transFromProps.style = {});\n        var styleKeys = keys(styleOpt);\n        for (var i = 0; i < styleKeys.length; i++) {\n          var key = styleKeys[i];\n          if (animationStyleProps[key]) {\n            var elVal = fromElStyle[key];\n            transFromStyleProps[key] = elVal;\n          }\n        }\n      }\n    }\n  }\n}\nfunction isNonStyleTransitionEnabled(optVal, elVal) {\n  // The same as `checkNonStyleTansitionRefer`.\n  return !isArrayLike(optVal) ? optVal != null && isFinite(optVal) : optVal !== elVal;\n}\nvar checkTransformPropRefer;\nif (process.env.NODE_ENV !== 'production') {\n  checkTransformPropRefer = function (key, usedIn) {\n    if (!hasOwn(TRANSFORM_PROPS_MAP, key)) {\n      warn('Prop `' + key + '` is not a permitted in `' + usedIn + '`. ' + 'Only `' + keys(TRANSFORM_PROPS_MAP).join('`, `') + '` are permitted.');\n    }\n  };\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
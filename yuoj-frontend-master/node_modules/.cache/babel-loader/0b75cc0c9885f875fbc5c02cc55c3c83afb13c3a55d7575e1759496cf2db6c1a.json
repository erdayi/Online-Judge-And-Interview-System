{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { normalizeArcAngles } from 'zrender/lib/core/PathProxy.js';\nimport { getCircleLayout } from '../../util/layout.js';\nvar RADIAN = Math.PI / 180;\nexport default function chordCircularLayout(ecModel, api) {\n  ecModel.eachSeriesByType('chord', function (seriesModel) {\n    chordLayout(seriesModel, api);\n  });\n}\nfunction chordLayout(seriesModel, api) {\n  var nodeData = seriesModel.getData();\n  var nodeGraph = nodeData.graph;\n  var edgeData = seriesModel.getEdgeData();\n  var edgeCount = edgeData.count();\n  if (!edgeCount) {\n    return;\n  }\n  var _a = getCircleLayout(seriesModel, api),\n    cx = _a.cx,\n    cy = _a.cy,\n    r = _a.r,\n    r0 = _a.r0;\n  var padAngle = Math.max((seriesModel.get('padAngle') || 0) * RADIAN, 0);\n  var minAngle = Math.max((seriesModel.get('minAngle') || 0) * RADIAN, 0);\n  var startAngle = -seriesModel.get('startAngle') * RADIAN;\n  var endAngle = startAngle + Math.PI * 2;\n  var clockwise = seriesModel.get('clockwise');\n  var dir = clockwise ? 1 : -1;\n  // Normalize angles\n  var angles = [startAngle, endAngle];\n  normalizeArcAngles(angles, !clockwise);\n  var normalizedStartAngle = angles[0],\n    normalizedEndAngle = angles[1];\n  var totalAngle = normalizedEndAngle - normalizedStartAngle;\n  var allZero = nodeData.getSum('value') === 0 && edgeData.getSum('value') === 0;\n  // Sum of each node's edge values\n  var nodeValues = [];\n  var renderedNodeCount = 0;\n  nodeGraph.eachEdge(function (edge) {\n    // All links use the same value 1 when allZero is true\n    var value = allZero ? 1 : edge.getValue('value');\n    if (allZero && (value > 0 || minAngle)) {\n      // When allZero is true, angle is in direct proportion to number\n      // of links both in and out of the node.\n      renderedNodeCount += 2;\n    }\n    var node1Index = edge.node1.dataIndex;\n    var node2Index = edge.node2.dataIndex;\n    nodeValues[node1Index] = (nodeValues[node1Index] || 0) + value;\n    nodeValues[node2Index] = (nodeValues[node2Index] || 0) + value;\n  });\n  // Update nodeValues with data.value if exists\n  var nodeValueSum = 0;\n  nodeGraph.eachNode(function (node) {\n    var dataValue = node.getValue('value');\n    if (!isNaN(dataValue)) {\n      nodeValues[node.dataIndex] = Math.max(dataValue, nodeValues[node.dataIndex] || 0);\n    }\n    if (!allZero && (nodeValues[node.dataIndex] > 0 || minAngle)) {\n      // When allZero is false, angle is in direct proportion to node's\n      // value\n      renderedNodeCount++;\n    }\n    nodeValueSum += nodeValues[node.dataIndex] || 0;\n  });\n  if (renderedNodeCount === 0 || nodeValueSum === 0) {\n    return;\n  }\n  if (padAngle * renderedNodeCount >= Math.abs(totalAngle)) {\n    // Not enough angle to render the pad, minAngle has higher priority, and padAngle takes the rest\n    padAngle = Math.max(0, (Math.abs(totalAngle) - minAngle * renderedNodeCount) / renderedNodeCount);\n  }\n  if ((padAngle + minAngle) * renderedNodeCount >= Math.abs(totalAngle)) {\n    // Not enough angle to render the minAngle, so ignore the minAngle\n    minAngle = (Math.abs(totalAngle) - padAngle * renderedNodeCount) / renderedNodeCount;\n  }\n  var unitAngle = (totalAngle - padAngle * renderedNodeCount * dir) / nodeValueSum;\n  var totalDeficit = 0; // sum of deficits of nodes with span < minAngle\n  var totalSurplus = 0; // sum of (spans - minAngle) of nodes with span > minAngle\n  var totalSurplusSpan = 0; // sum of spans of nodes with span > minAngle\n  var minSurplus = Infinity; // min of (spans - minAngle) of nodes with span > minAngle\n  nodeGraph.eachNode(function (node) {\n    var value = nodeValues[node.dataIndex] || 0;\n    var spanAngle = unitAngle * (nodeValueSum ? value : 1) * dir;\n    if (Math.abs(spanAngle) < minAngle) {\n      totalDeficit += minAngle - Math.abs(spanAngle);\n    } else {\n      minSurplus = Math.min(minSurplus, Math.abs(spanAngle) - minAngle);\n      totalSurplus += Math.abs(spanAngle) - minAngle;\n      totalSurplusSpan += Math.abs(spanAngle);\n    }\n    node.setLayout({\n      angle: spanAngle,\n      value: value\n    });\n  });\n  var surplusAsMuchAsPossible = false;\n  if (totalDeficit > totalSurplus) {\n    // Not enough angle to spread the nodes, scale all\n    var scale_1 = totalDeficit / totalSurplus;\n    nodeGraph.eachNode(function (node) {\n      var spanAngle = node.getLayout().angle;\n      if (Math.abs(spanAngle) >= minAngle) {\n        node.setLayout({\n          angle: spanAngle * scale_1,\n          ratio: scale_1\n        }, true);\n      } else {\n        node.setLayout({\n          angle: minAngle,\n          ratio: minAngle === 0 ? 1 : spanAngle / minAngle\n        }, true);\n      }\n    });\n  } else {\n    // For example, if totalDeficit is 60 degrees and totalSurplus is 70\n    // degrees but one of the sector can only reduced by 1 degree,\n    // if we decrease it with the ratio of value to other surplused nodes,\n    // it will have smaller angle than minAngle itself.\n    // So we need to borrow some angle from other nodes.\n    nodeGraph.eachNode(function (node) {\n      if (surplusAsMuchAsPossible) {\n        return;\n      }\n      var spanAngle = node.getLayout().angle;\n      var borrowRatio = Math.min(spanAngle / totalSurplusSpan, 1);\n      var borrowAngle = borrowRatio * totalDeficit;\n      if (spanAngle - borrowAngle < minAngle) {\n        // It will have less than minAngle after borrowing\n        surplusAsMuchAsPossible = true;\n      }\n    });\n  }\n  var restDeficit = totalDeficit;\n  nodeGraph.eachNode(function (node) {\n    if (restDeficit <= 0) {\n      return;\n    }\n    var spanAngle = node.getLayout().angle;\n    if (spanAngle > minAngle && minAngle > 0) {\n      var borrowRatio = surplusAsMuchAsPossible ? 1 : Math.min(spanAngle / totalSurplusSpan, 1);\n      var maxBorrowAngle = spanAngle - minAngle;\n      var borrowAngle = Math.min(maxBorrowAngle, Math.min(restDeficit, totalDeficit * borrowRatio));\n      restDeficit -= borrowAngle;\n      node.setLayout({\n        angle: spanAngle - borrowAngle,\n        ratio: (spanAngle - borrowAngle) / spanAngle\n      }, true);\n    } else if (minAngle > 0) {\n      node.setLayout({\n        angle: minAngle,\n        ratio: spanAngle === 0 ? 1 : minAngle / spanAngle\n      }, true);\n    }\n  });\n  var angle = normalizedStartAngle;\n  var edgeAccAngle = [];\n  nodeGraph.eachNode(function (node) {\n    var spanAngle = Math.max(node.getLayout().angle, minAngle);\n    node.setLayout({\n      cx: cx,\n      cy: cy,\n      r0: r0,\n      r: r,\n      startAngle: angle,\n      endAngle: angle + spanAngle * dir,\n      clockwise: clockwise\n    }, true);\n    edgeAccAngle[node.dataIndex] = angle;\n    angle += (spanAngle + padAngle) * dir;\n  });\n  nodeGraph.eachEdge(function (edge) {\n    var value = allZero ? 1 : edge.getValue('value');\n    var spanAngle = unitAngle * (nodeValueSum ? value : 1) * dir;\n    var node1Index = edge.node1.dataIndex;\n    var sStartAngle = edgeAccAngle[node1Index] || 0;\n    var sSpan = Math.abs((edge.node1.getLayout().ratio || 1) * spanAngle);\n    var sEndAngle = sStartAngle + sSpan * dir;\n    var s1 = [cx + r0 * Math.cos(sStartAngle), cy + r0 * Math.sin(sStartAngle)];\n    var s2 = [cx + r0 * Math.cos(sEndAngle), cy + r0 * Math.sin(sEndAngle)];\n    var node2Index = edge.node2.dataIndex;\n    var tStartAngle = edgeAccAngle[node2Index] || 0;\n    var tSpan = Math.abs((edge.node2.getLayout().ratio || 1) * spanAngle);\n    var tEndAngle = tStartAngle + tSpan * dir;\n    var t1 = [cx + r0 * Math.cos(tStartAngle), cy + r0 * Math.sin(tStartAngle)];\n    var t2 = [cx + r0 * Math.cos(tEndAngle), cy + r0 * Math.sin(tEndAngle)];\n    edge.setLayout({\n      s1: s1,\n      s2: s2,\n      sStartAngle: sStartAngle,\n      sEndAngle: sEndAngle,\n      t1: t1,\n      t2: t2,\n      tStartAngle: tStartAngle,\n      tEndAngle: tEndAngle,\n      cx: cx,\n      cy: cy,\n      r: r0,\n      value: value,\n      clockwise: clockwise\n    });\n    edgeAccAngle[node1Index] = sEndAngle;\n    edgeAccAngle[node2Index] = tEndAngle;\n  });\n}","map":{"version":3,"names":["normalizeArcAngles","getCircleLayout","RADIAN","Math","PI","chordCircularLayout","ecModel","api","eachSeriesByType","seriesModel","chordLayout","nodeData","getData","nodeGraph","graph","edgeData","getEdgeData","edgeCount","count","_a","cx","cy","r","r0","padAngle","max","get","minAngle","startAngle","endAngle","clockwise","dir","angles","normalizedStartAngle","normalizedEndAngle","totalAngle","allZero","getSum","nodeValues","renderedNodeCount","eachEdge","edge","value","getValue","node1Index","node1","dataIndex","node2Index","node2","nodeValueSum","eachNode","node","dataValue","isNaN","abs","unitAngle","totalDeficit","totalSurplus","totalSurplusSpan","minSurplus","Infinity","spanAngle","min","setLayout","angle","surplusAsMuchAsPossible","scale_1","getLayout","ratio","borrowRatio","borrowAngle","restDeficit","maxBorrowAngle","edgeAccAngle","sStartAngle","sSpan","sEndAngle","s1","cos","sin","s2","tStartAngle","tSpan","tEndAngle","t1","t2"],"sources":["D:/code/java/program/oj/code/yuoj-frontend-master/node_modules/echarts/lib/chart/chord/chordLayout.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { normalizeArcAngles } from 'zrender/lib/core/PathProxy.js';\nimport { getCircleLayout } from '../../util/layout.js';\nvar RADIAN = Math.PI / 180;\nexport default function chordCircularLayout(ecModel, api) {\n  ecModel.eachSeriesByType('chord', function (seriesModel) {\n    chordLayout(seriesModel, api);\n  });\n}\nfunction chordLayout(seriesModel, api) {\n  var nodeData = seriesModel.getData();\n  var nodeGraph = nodeData.graph;\n  var edgeData = seriesModel.getEdgeData();\n  var edgeCount = edgeData.count();\n  if (!edgeCount) {\n    return;\n  }\n  var _a = getCircleLayout(seriesModel, api),\n    cx = _a.cx,\n    cy = _a.cy,\n    r = _a.r,\n    r0 = _a.r0;\n  var padAngle = Math.max((seriesModel.get('padAngle') || 0) * RADIAN, 0);\n  var minAngle = Math.max((seriesModel.get('minAngle') || 0) * RADIAN, 0);\n  var startAngle = -seriesModel.get('startAngle') * RADIAN;\n  var endAngle = startAngle + Math.PI * 2;\n  var clockwise = seriesModel.get('clockwise');\n  var dir = clockwise ? 1 : -1;\n  // Normalize angles\n  var angles = [startAngle, endAngle];\n  normalizeArcAngles(angles, !clockwise);\n  var normalizedStartAngle = angles[0],\n    normalizedEndAngle = angles[1];\n  var totalAngle = normalizedEndAngle - normalizedStartAngle;\n  var allZero = nodeData.getSum('value') === 0 && edgeData.getSum('value') === 0;\n  // Sum of each node's edge values\n  var nodeValues = [];\n  var renderedNodeCount = 0;\n  nodeGraph.eachEdge(function (edge) {\n    // All links use the same value 1 when allZero is true\n    var value = allZero ? 1 : edge.getValue('value');\n    if (allZero && (value > 0 || minAngle)) {\n      // When allZero is true, angle is in direct proportion to number\n      // of links both in and out of the node.\n      renderedNodeCount += 2;\n    }\n    var node1Index = edge.node1.dataIndex;\n    var node2Index = edge.node2.dataIndex;\n    nodeValues[node1Index] = (nodeValues[node1Index] || 0) + value;\n    nodeValues[node2Index] = (nodeValues[node2Index] || 0) + value;\n  });\n  // Update nodeValues with data.value if exists\n  var nodeValueSum = 0;\n  nodeGraph.eachNode(function (node) {\n    var dataValue = node.getValue('value');\n    if (!isNaN(dataValue)) {\n      nodeValues[node.dataIndex] = Math.max(dataValue, nodeValues[node.dataIndex] || 0);\n    }\n    if (!allZero && (nodeValues[node.dataIndex] > 0 || minAngle)) {\n      // When allZero is false, angle is in direct proportion to node's\n      // value\n      renderedNodeCount++;\n    }\n    nodeValueSum += nodeValues[node.dataIndex] || 0;\n  });\n  if (renderedNodeCount === 0 || nodeValueSum === 0) {\n    return;\n  }\n  if (padAngle * renderedNodeCount >= Math.abs(totalAngle)) {\n    // Not enough angle to render the pad, minAngle has higher priority, and padAngle takes the rest\n    padAngle = Math.max(0, (Math.abs(totalAngle) - minAngle * renderedNodeCount) / renderedNodeCount);\n  }\n  if ((padAngle + minAngle) * renderedNodeCount >= Math.abs(totalAngle)) {\n    // Not enough angle to render the minAngle, so ignore the minAngle\n    minAngle = (Math.abs(totalAngle) - padAngle * renderedNodeCount) / renderedNodeCount;\n  }\n  var unitAngle = (totalAngle - padAngle * renderedNodeCount * dir) / nodeValueSum;\n  var totalDeficit = 0; // sum of deficits of nodes with span < minAngle\n  var totalSurplus = 0; // sum of (spans - minAngle) of nodes with span > minAngle\n  var totalSurplusSpan = 0; // sum of spans of nodes with span > minAngle\n  var minSurplus = Infinity; // min of (spans - minAngle) of nodes with span > minAngle\n  nodeGraph.eachNode(function (node) {\n    var value = nodeValues[node.dataIndex] || 0;\n    var spanAngle = unitAngle * (nodeValueSum ? value : 1) * dir;\n    if (Math.abs(spanAngle) < minAngle) {\n      totalDeficit += minAngle - Math.abs(spanAngle);\n    } else {\n      minSurplus = Math.min(minSurplus, Math.abs(spanAngle) - minAngle);\n      totalSurplus += Math.abs(spanAngle) - minAngle;\n      totalSurplusSpan += Math.abs(spanAngle);\n    }\n    node.setLayout({\n      angle: spanAngle,\n      value: value\n    });\n  });\n  var surplusAsMuchAsPossible = false;\n  if (totalDeficit > totalSurplus) {\n    // Not enough angle to spread the nodes, scale all\n    var scale_1 = totalDeficit / totalSurplus;\n    nodeGraph.eachNode(function (node) {\n      var spanAngle = node.getLayout().angle;\n      if (Math.abs(spanAngle) >= minAngle) {\n        node.setLayout({\n          angle: spanAngle * scale_1,\n          ratio: scale_1\n        }, true);\n      } else {\n        node.setLayout({\n          angle: minAngle,\n          ratio: minAngle === 0 ? 1 : spanAngle / minAngle\n        }, true);\n      }\n    });\n  } else {\n    // For example, if totalDeficit is 60 degrees and totalSurplus is 70\n    // degrees but one of the sector can only reduced by 1 degree,\n    // if we decrease it with the ratio of value to other surplused nodes,\n    // it will have smaller angle than minAngle itself.\n    // So we need to borrow some angle from other nodes.\n    nodeGraph.eachNode(function (node) {\n      if (surplusAsMuchAsPossible) {\n        return;\n      }\n      var spanAngle = node.getLayout().angle;\n      var borrowRatio = Math.min(spanAngle / totalSurplusSpan, 1);\n      var borrowAngle = borrowRatio * totalDeficit;\n      if (spanAngle - borrowAngle < minAngle) {\n        // It will have less than minAngle after borrowing\n        surplusAsMuchAsPossible = true;\n      }\n    });\n  }\n  var restDeficit = totalDeficit;\n  nodeGraph.eachNode(function (node) {\n    if (restDeficit <= 0) {\n      return;\n    }\n    var spanAngle = node.getLayout().angle;\n    if (spanAngle > minAngle && minAngle > 0) {\n      var borrowRatio = surplusAsMuchAsPossible ? 1 : Math.min(spanAngle / totalSurplusSpan, 1);\n      var maxBorrowAngle = spanAngle - minAngle;\n      var borrowAngle = Math.min(maxBorrowAngle, Math.min(restDeficit, totalDeficit * borrowRatio));\n      restDeficit -= borrowAngle;\n      node.setLayout({\n        angle: spanAngle - borrowAngle,\n        ratio: (spanAngle - borrowAngle) / spanAngle\n      }, true);\n    } else if (minAngle > 0) {\n      node.setLayout({\n        angle: minAngle,\n        ratio: spanAngle === 0 ? 1 : minAngle / spanAngle\n      }, true);\n    }\n  });\n  var angle = normalizedStartAngle;\n  var edgeAccAngle = [];\n  nodeGraph.eachNode(function (node) {\n    var spanAngle = Math.max(node.getLayout().angle, minAngle);\n    node.setLayout({\n      cx: cx,\n      cy: cy,\n      r0: r0,\n      r: r,\n      startAngle: angle,\n      endAngle: angle + spanAngle * dir,\n      clockwise: clockwise\n    }, true);\n    edgeAccAngle[node.dataIndex] = angle;\n    angle += (spanAngle + padAngle) * dir;\n  });\n  nodeGraph.eachEdge(function (edge) {\n    var value = allZero ? 1 : edge.getValue('value');\n    var spanAngle = unitAngle * (nodeValueSum ? value : 1) * dir;\n    var node1Index = edge.node1.dataIndex;\n    var sStartAngle = edgeAccAngle[node1Index] || 0;\n    var sSpan = Math.abs((edge.node1.getLayout().ratio || 1) * spanAngle);\n    var sEndAngle = sStartAngle + sSpan * dir;\n    var s1 = [cx + r0 * Math.cos(sStartAngle), cy + r0 * Math.sin(sStartAngle)];\n    var s2 = [cx + r0 * Math.cos(sEndAngle), cy + r0 * Math.sin(sEndAngle)];\n    var node2Index = edge.node2.dataIndex;\n    var tStartAngle = edgeAccAngle[node2Index] || 0;\n    var tSpan = Math.abs((edge.node2.getLayout().ratio || 1) * spanAngle);\n    var tEndAngle = tStartAngle + tSpan * dir;\n    var t1 = [cx + r0 * Math.cos(tStartAngle), cy + r0 * Math.sin(tStartAngle)];\n    var t2 = [cx + r0 * Math.cos(tEndAngle), cy + r0 * Math.sin(tEndAngle)];\n    edge.setLayout({\n      s1: s1,\n      s2: s2,\n      sStartAngle: sStartAngle,\n      sEndAngle: sEndAngle,\n      t1: t1,\n      t2: t2,\n      tStartAngle: tStartAngle,\n      tEndAngle: tEndAngle,\n      cx: cx,\n      cy: cy,\n      r: r0,\n      value: value,\n      clockwise: clockwise\n    });\n    edgeAccAngle[node1Index] = sEndAngle;\n    edgeAccAngle[node2Index] = tEndAngle;\n  });\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n/**\n * Grid is a region which contains at most 4 cartesian systems\n *\n * TODO Default cartesian\n */\nimport { isObject, each, indexOf, retrieve3, keys, assert, eqNaN, find, retrieve2 } from 'zrender/lib/core/util.js';\nimport { createBoxLayoutReference, getLayoutRect } from '../../util/layout.js';\nimport { createScaleByModel, ifAxisCrossZero, niceScaleExtent, getDataDimensionsOnAxis, isNameLocationCenter, shouldAxisShow } from '../../coord/axisHelper.js';\nimport Cartesian2D, { cartesian2DDimensions } from './Cartesian2D.js';\nimport Axis2D from './Axis2D.js';\nimport { SINGLE_REFERRING } from '../../util/model.js';\n// Depends on GridModel, AxisModel, which performs preprocess.\nimport { OUTER_BOUNDS_CLAMP_DEFAULT, OUTER_BOUNDS_DEFAULT } from './GridModel.js';\nimport { findAxisModels, createCartesianAxisViewCommonPartBuilder, updateCartesianAxisViewCommonPartBuilder, isCartesian2DInjectedAsDataCoordSys } from './cartesianAxisHelper.js';\nimport { isIntervalOrLogScale } from '../../scale/helper.js';\nimport { alignScaleTicks } from '../axisAlignTicks.js';\nimport { expandOrShrinkRect, WH, XY } from '../../util/graphic.js';\nimport { AxisBuilderSharedContext, resolveAxisNameOverlapDefault, moveIfOverlapByLinearLabels, getLabelInner } from '../../component/axis/AxisBuilder.js';\nimport { error, log } from '../../util/log.js';\nimport { AxisTickLabelComputingKind } from '../axisTickLabelBuilder.js';\nimport { injectCoordSysByOption } from '../../core/CoordinateSystem.js';\nimport { mathMax, parsePositionSizeOption } from '../../util/number.js';\n// margin is [top, right, bottom, left]\nvar XY_TO_MARGIN_IDX = [[3, 1], [0, 2] // xyIdx 1 => 'y'\n];\n\nvar Grid = /** @class */function () {\n  function Grid(gridModel, ecModel, api) {\n    // FIXME:TS where used (different from registered type 'cartesian2d')?\n    this.type = 'grid';\n    this._coordsMap = {};\n    this._coordsList = [];\n    this._axesMap = {};\n    this._axesList = [];\n    this.axisPointerEnabled = true;\n    this.dimensions = cartesian2DDimensions;\n    this._initCartesian(gridModel, ecModel, api);\n    this.model = gridModel;\n  }\n  Grid.prototype.getRect = function () {\n    return this._rect;\n  };\n  Grid.prototype.update = function (ecModel, api) {\n    var axesMap = this._axesMap;\n    this._updateScale(ecModel, this.model);\n    function updateAxisTicks(axes) {\n      var alignTo;\n      // Axis is added in order of axisIndex.\n      var axesIndices = keys(axes);\n      var len = axesIndices.length;\n      if (!len) {\n        return;\n      }\n      var axisNeedsAlign = [];\n      // Process once and calculate the ticks for those don't use alignTicks.\n      for (var i = len - 1; i >= 0; i--) {\n        var idx = +axesIndices[i]; // Convert to number.\n        var axis = axes[idx];\n        var model = axis.model;\n        var scale = axis.scale;\n        if (\n        // Only value and log axis without interval support alignTicks.\n        isIntervalOrLogScale(scale) && model.get('alignTicks') && model.get('interval') == null) {\n          axisNeedsAlign.push(axis);\n        } else {\n          niceScaleExtent(scale, model);\n          if (isIntervalOrLogScale(scale)) {\n            // Can only align to interval or log axis.\n            alignTo = axis;\n          }\n        }\n      }\n      ;\n      // All axes has set alignTicks. Pick the first one.\n      // PENDING. Should we find the axis that both set interval, min, max and align to this one?\n      if (axisNeedsAlign.length) {\n        if (!alignTo) {\n          alignTo = axisNeedsAlign.pop();\n          niceScaleExtent(alignTo.scale, alignTo.model);\n        }\n        each(axisNeedsAlign, function (axis) {\n          alignScaleTicks(axis.scale, axis.model, alignTo.scale);\n        });\n      }\n    }\n    updateAxisTicks(axesMap.x);\n    updateAxisTicks(axesMap.y);\n    // Key: axisDim_axisIndex, value: boolean, whether onZero target.\n    var onZeroRecords = {};\n    each(axesMap.x, function (xAxis) {\n      fixAxisOnZero(axesMap, 'y', xAxis, onZeroRecords);\n    });\n    each(axesMap.y, function (yAxis) {\n      fixAxisOnZero(axesMap, 'x', yAxis, onZeroRecords);\n    });\n    // Resize again if containLabel is enabled\n    // FIXME It may cause getting wrong grid size in data processing stage\n    this.resize(this.model, api);\n  };\n  /**\n   * Resize the grid.\n   *\n   * [NOTE]\n   * If both \"grid.containLabel/grid.contain\" and pixel-required-data-processing (such as, \"dataSampling\")\n   * exist, circular dependency occurs in logic.\n   * The final compromised sequence is:\n   *  1. Calculate \"axis.extent\" (pixel extent) and AffineTransform based on only \"grid layout options\".\n   *      Not accurate if \"grid.containLabel/grid.contain\" is required, but it is a compromise to avoid\n   *      circular dependency.\n   *  2. Perform \"series data processing\" (where \"dataSampling\" requires \"axis.extent\").\n   *  3. Calculate \"scale.extent\" (data extent) based on \"processed series data\".\n   *  4. Modify \"axis.extent\" for \"grid.containLabel/grid.contain\":\n   *      4.1. Calculate \"axis labels\" based on \"scale.extent\".\n   *      4.2. Modify \"axis.extent\" by the bounding rects of \"axis labels and names\".\n   */\n  Grid.prototype.resize = function (gridModel, api, beforeDataProcessing) {\n    var layoutRef = createBoxLayoutReference(gridModel, api);\n    var gridRect = this._rect = getLayoutRect(gridModel.getBoxLayoutParams(), layoutRef.refContainer);\n    // PENDING: whether to support that if the input `coord` is out of the base coord sys,\n    //  do not render anything. At present, the behavior is undefined.\n    var axesMap = this._axesMap;\n    var coordsList = this._coordsList;\n    var optionContainLabel = gridModel.get('containLabel'); // No `.get(, true)` for backward compat.\n    updateAllAxisExtentTransByGridRect(axesMap, gridRect);\n    if (!beforeDataProcessing) {\n      var axisBuilderSharedCtx = createAxisBiulders(gridRect, coordsList, axesMap, optionContainLabel, api);\n      var noPxChange = void 0;\n      if (optionContainLabel) {\n        if (legacyLayOutGridByContainLabel) {\n          // console.time('legacyLayOutGridByContainLabel');\n          legacyLayOutGridByContainLabel(this._axesList, gridRect);\n          updateAllAxisExtentTransByGridRect(axesMap, gridRect);\n          // console.timeEnd('legacyLayOutGridByContainLabel');\n        } else {\n          if (process.env.NODE_ENV !== 'production') {\n            log('Specified `grid.containLabel` but no `use(LegacyGridContainLabel)`;' + 'use `grid.outerBounds` instead.', true);\n          }\n          noPxChange = layOutGridByOuterBounds(gridRect.clone(), 'axisLabel', null, gridRect, axesMap, axisBuilderSharedCtx, layoutRef);\n        }\n      } else {\n        var _a = prepareOuterBounds(gridModel, gridRect, layoutRef),\n          outerBoundsRect = _a.outerBoundsRect,\n          parsedOuterBoundsContain = _a.parsedOuterBoundsContain,\n          outerBoundsClamp = _a.outerBoundsClamp;\n        if (outerBoundsRect) {\n          // console.time('layOutGridByOuterBounds');\n          noPxChange = layOutGridByOuterBounds(outerBoundsRect, parsedOuterBoundsContain, outerBoundsClamp, gridRect, axesMap, axisBuilderSharedCtx, layoutRef);\n          // console.timeEnd('layOutGridByOuterBounds');\n        }\n      }\n      // console.time('buildAxesView_determine');\n      createOrUpdateAxesView(gridRect, axesMap, AxisTickLabelComputingKind.determine, null, noPxChange, layoutRef);\n      // console.timeEnd('buildAxesView_determine');\n    } // End of beforeDataProcessing\n    each(this._coordsList, function (coord) {\n      // Calculate affine matrix to accelerate the data to point transform.\n      // If all the axes scales are time or value.\n      coord.calcAffineTransform();\n    });\n  };\n  Grid.prototype.getAxis = function (dim, axisIndex) {\n    var axesMapOnDim = this._axesMap[dim];\n    if (axesMapOnDim != null) {\n      return axesMapOnDim[axisIndex || 0];\n    }\n  };\n  Grid.prototype.getAxes = function () {\n    return this._axesList.slice();\n  };\n  Grid.prototype.getCartesian = function (xAxisIndex, yAxisIndex) {\n    if (xAxisIndex != null && yAxisIndex != null) {\n      var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n      return this._coordsMap[key];\n    }\n    if (isObject(xAxisIndex)) {\n      yAxisIndex = xAxisIndex.yAxisIndex;\n      xAxisIndex = xAxisIndex.xAxisIndex;\n    }\n    for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {\n      if (coordList[i].getAxis('x').index === xAxisIndex || coordList[i].getAxis('y').index === yAxisIndex) {\n        return coordList[i];\n      }\n    }\n  };\n  Grid.prototype.getCartesians = function () {\n    return this._coordsList.slice();\n  };\n  /**\n   * @implements\n   */\n  Grid.prototype.convertToPixel = function (ecModel, finder, value) {\n    var target = this._findConvertTarget(finder);\n    return target.cartesian ? target.cartesian.dataToPoint(value) : target.axis ? target.axis.toGlobalCoord(target.axis.dataToCoord(value)) : null;\n  };\n  /**\n   * @implements\n   */\n  Grid.prototype.convertFromPixel = function (ecModel, finder, value) {\n    var target = this._findConvertTarget(finder);\n    return target.cartesian ? target.cartesian.pointToData(value) : target.axis ? target.axis.coordToData(target.axis.toLocalCoord(value)) : null;\n  };\n  Grid.prototype._findConvertTarget = function (finder) {\n    var seriesModel = finder.seriesModel;\n    var xAxisModel = finder.xAxisModel || seriesModel && seriesModel.getReferringComponents('xAxis', SINGLE_REFERRING).models[0];\n    var yAxisModel = finder.yAxisModel || seriesModel && seriesModel.getReferringComponents('yAxis', SINGLE_REFERRING).models[0];\n    var gridModel = finder.gridModel;\n    var coordsList = this._coordsList;\n    var cartesian;\n    var axis;\n    if (seriesModel) {\n      cartesian = seriesModel.coordinateSystem;\n      indexOf(coordsList, cartesian) < 0 && (cartesian = null);\n    } else if (xAxisModel && yAxisModel) {\n      cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n    } else if (xAxisModel) {\n      axis = this.getAxis('x', xAxisModel.componentIndex);\n    } else if (yAxisModel) {\n      axis = this.getAxis('y', yAxisModel.componentIndex);\n    }\n    // Lowest priority.\n    else if (gridModel) {\n      var grid = gridModel.coordinateSystem;\n      if (grid === this) {\n        cartesian = this._coordsList[0];\n      }\n    }\n    return {\n      cartesian: cartesian,\n      axis: axis\n    };\n  };\n  /**\n   * @implements\n   */\n  Grid.prototype.containPoint = function (point) {\n    var coord = this._coordsList[0];\n    if (coord) {\n      return coord.containPoint(point);\n    }\n  };\n  /**\n   * Initialize cartesian coordinate systems\n   */\n  Grid.prototype._initCartesian = function (gridModel, ecModel, api) {\n    var _this = this;\n    var grid = this;\n    var axisPositionUsed = {\n      left: false,\n      right: false,\n      top: false,\n      bottom: false\n    };\n    var axesMap = {\n      x: {},\n      y: {}\n    };\n    var axesCount = {\n      x: 0,\n      y: 0\n    };\n    // Create axis\n    ecModel.eachComponent('xAxis', createAxisCreator('x'), this);\n    ecModel.eachComponent('yAxis', createAxisCreator('y'), this);\n    if (!axesCount.x || !axesCount.y) {\n      // Roll back when there no either x or y axis\n      this._axesMap = {};\n      this._axesList = [];\n      return;\n    }\n    this._axesMap = axesMap;\n    // Create cartesian2d\n    each(axesMap.x, function (xAxis, xAxisIndex) {\n      each(axesMap.y, function (yAxis, yAxisIndex) {\n        var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n        var cartesian = new Cartesian2D(key);\n        cartesian.master = _this;\n        cartesian.model = gridModel;\n        _this._coordsMap[key] = cartesian;\n        _this._coordsList.push(cartesian);\n        cartesian.addAxis(xAxis);\n        cartesian.addAxis(yAxis);\n      });\n    });\n    function createAxisCreator(dimName) {\n      return function (axisModel, idx) {\n        if (!isAxisUsedInTheGrid(axisModel, gridModel)) {\n          return;\n        }\n        var axisPosition = axisModel.get('position');\n        if (dimName === 'x') {\n          // Fix position\n          if (axisPosition !== 'top' && axisPosition !== 'bottom') {\n            // Default bottom of X\n            axisPosition = axisPositionUsed.bottom ? 'top' : 'bottom';\n          }\n        } else {\n          // Fix position\n          if (axisPosition !== 'left' && axisPosition !== 'right') {\n            // Default left of Y\n            axisPosition = axisPositionUsed.left ? 'right' : 'left';\n          }\n        }\n        axisPositionUsed[axisPosition] = true;\n        var axis = new Axis2D(dimName, createScaleByModel(axisModel), [0, 0], axisModel.get('type'), axisPosition);\n        var isCategory = axis.type === 'category';\n        axis.onBand = isCategory && axisModel.get('boundaryGap');\n        axis.inverse = axisModel.get('inverse');\n        // Inject axis into axisModel\n        axisModel.axis = axis;\n        // Inject axisModel into axis\n        axis.model = axisModel;\n        // Inject grid info axis\n        axis.grid = grid;\n        // Index of axis, can be used as key\n        axis.index = idx;\n        grid._axesList.push(axis);\n        axesMap[dimName][idx] = axis;\n        axesCount[dimName]++;\n      };\n    }\n  };\n  /**\n   * Update cartesian properties from series.\n   */\n  Grid.prototype._updateScale = function (ecModel, gridModel) {\n    // Reset scale\n    each(this._axesList, function (axis) {\n      axis.scale.setExtent(Infinity, -Infinity);\n      if (axis.type === 'category') {\n        var categorySortInfo = axis.model.get('categorySortInfo');\n        axis.scale.setSortInfo(categorySortInfo);\n      }\n    });\n    ecModel.eachSeries(function (seriesModel) {\n      // If pie (or other similar series) use cartesian2d, the unionExtent logic below is\n      // wrong, therefore skip it temporarily. See also in `defaultAxisExtentFromData.ts`.\n      // TODO: support union extent in this case.\n      if (isCartesian2DInjectedAsDataCoordSys(seriesModel)) {\n        var axesModelMap = findAxisModels(seriesModel);\n        var xAxisModel = axesModelMap.xAxisModel;\n        var yAxisModel = axesModelMap.yAxisModel;\n        if (!isAxisUsedInTheGrid(xAxisModel, gridModel) || !isAxisUsedInTheGrid(yAxisModel, gridModel)) {\n          return;\n        }\n        var cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n        var data = seriesModel.getData();\n        var xAxis = cartesian.getAxis('x');\n        var yAxis = cartesian.getAxis('y');\n        unionExtent(data, xAxis);\n        unionExtent(data, yAxis);\n      }\n    }, this);\n    function unionExtent(data, axis) {\n      each(getDataDimensionsOnAxis(data, axis.dim), function (dim) {\n        axis.scale.unionExtentFromData(data, dim);\n      });\n    }\n  };\n  /**\n   * @param dim 'x' or 'y' or 'auto' or null/undefined\n   */\n  Grid.prototype.getTooltipAxes = function (dim) {\n    var baseAxes = [];\n    var otherAxes = [];\n    each(this.getCartesians(), function (cartesian) {\n      var baseAxis = dim != null && dim !== 'auto' ? cartesian.getAxis(dim) : cartesian.getBaseAxis();\n      var otherAxis = cartesian.getOtherAxis(baseAxis);\n      indexOf(baseAxes, baseAxis) < 0 && baseAxes.push(baseAxis);\n      indexOf(otherAxes, otherAxis) < 0 && otherAxes.push(otherAxis);\n    });\n    return {\n      baseAxes: baseAxes,\n      otherAxes: otherAxes\n    };\n  };\n  Grid.create = function (ecModel, api) {\n    var grids = [];\n    ecModel.eachComponent('grid', function (gridModel, idx) {\n      var grid = new Grid(gridModel, ecModel, api);\n      grid.name = 'grid_' + idx;\n      // dataSampling requires axis extent, so resize\n      // should be performed in create stage.\n      grid.resize(gridModel, api, true);\n      gridModel.coordinateSystem = grid;\n      grids.push(grid);\n    });\n    // Inject the coordinateSystems into seriesModel\n    ecModel.eachSeries(function (seriesModel) {\n      injectCoordSysByOption({\n        targetModel: seriesModel,\n        coordSysType: 'cartesian2d',\n        coordSysProvider: coordSysProvider\n      });\n      function coordSysProvider() {\n        var axesModelMap = findAxisModels(seriesModel);\n        var xAxisModel = axesModelMap.xAxisModel;\n        var yAxisModel = axesModelMap.yAxisModel;\n        var gridModel = xAxisModel.getCoordSysModel();\n        if (process.env.NODE_ENV !== 'production') {\n          if (!gridModel) {\n            throw new Error('Grid \"' + retrieve3(xAxisModel.get('gridIndex'), xAxisModel.get('gridId'), 0) + '\" not found');\n          }\n          if (xAxisModel.getCoordSysModel() !== yAxisModel.getCoordSysModel()) {\n            throw new Error('xAxis and yAxis must use the same grid');\n          }\n        }\n        var grid = gridModel.coordinateSystem;\n        return grid.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n      }\n    });\n    return grids;\n  };\n  // For deciding which dimensions to use when creating list data\n  Grid.dimensions = cartesian2DDimensions;\n  return Grid;\n}();\n/**\n * Check if the axis is used in the specified grid.\n */\nfunction isAxisUsedInTheGrid(axisModel, gridModel) {\n  return axisModel.getCoordSysModel() === gridModel;\n}\nfunction fixAxisOnZero(axesMap, otherAxisDim, axis,\n// Key: see `getOnZeroRecordKey`\nonZeroRecords) {\n  axis.getAxesOnZeroOf = function () {\n    // TODO: onZero of multiple axes.\n    return otherAxisOnZeroOf ? [otherAxisOnZeroOf] : [];\n  };\n  // onZero can not be enabled in these two situations:\n  // 1. When any other axis is a category axis.\n  // 2. When no axis is cross 0 point.\n  var otherAxes = axesMap[otherAxisDim];\n  var otherAxisOnZeroOf;\n  var axisModel = axis.model;\n  var onZero = axisModel.get(['axisLine', 'onZero']);\n  var onZeroAxisIndex = axisModel.get(['axisLine', 'onZeroAxisIndex']);\n  if (!onZero) {\n    return;\n  }\n  // If target axis is specified.\n  if (onZeroAxisIndex != null) {\n    if (canOnZeroToAxis(otherAxes[onZeroAxisIndex])) {\n      otherAxisOnZeroOf = otherAxes[onZeroAxisIndex];\n    }\n  } else {\n    // Find the first available other axis.\n    for (var idx in otherAxes) {\n      if (otherAxes.hasOwnProperty(idx) && canOnZeroToAxis(otherAxes[idx])\n      // Consider that two Y axes on one value axis,\n      // if both onZero, the two Y axes overlap.\n      && !onZeroRecords[getOnZeroRecordKey(otherAxes[idx])]) {\n        otherAxisOnZeroOf = otherAxes[idx];\n        break;\n      }\n    }\n  }\n  if (otherAxisOnZeroOf) {\n    onZeroRecords[getOnZeroRecordKey(otherAxisOnZeroOf)] = true;\n  }\n  function getOnZeroRecordKey(axis) {\n    return axis.dim + '_' + axis.index;\n  }\n}\nfunction canOnZeroToAxis(axis) {\n  return axis && axis.type !== 'category' && axis.type !== 'time' && ifAxisCrossZero(axis);\n}\nfunction updateAxisTransform(axis, coordBase) {\n  var axisExtent = axis.getExtent();\n  var axisExtentSum = axisExtent[0] + axisExtent[1];\n  // Fast transform\n  axis.toGlobalCoord = axis.dim === 'x' ? function (coord) {\n    return coord + coordBase;\n  } : function (coord) {\n    return axisExtentSum - coord + coordBase;\n  };\n  axis.toLocalCoord = axis.dim === 'x' ? function (coord) {\n    return coord - coordBase;\n  } : function (coord) {\n    return axisExtentSum - coord + coordBase;\n  };\n}\nfunction updateAllAxisExtentTransByGridRect(axesMap, gridRect) {\n  each(axesMap.x, function (axis) {\n    return updateAxisExtentTransByGridRect(axis, gridRect.x, gridRect.width);\n  });\n  each(axesMap.y, function (axis) {\n    return updateAxisExtentTransByGridRect(axis, gridRect.y, gridRect.height);\n  });\n}\nfunction updateAxisExtentTransByGridRect(axis, gridXY, gridWH) {\n  var extent = [0, gridWH];\n  var idx = axis.inverse ? 1 : 0;\n  axis.setExtent(extent[idx], extent[1 - idx]);\n  updateAxisTransform(axis, gridXY);\n}\nvar legacyLayOutGridByContainLabel;\nexport function registerLegacyGridContainLabelImpl(impl) {\n  legacyLayOutGridByContainLabel = impl;\n}\n// Return noPxChange.\nfunction layOutGridByOuterBounds(outerBoundsRect, outerBoundsContain, outerBoundsClamp, gridRect, axesMap, axisBuilderSharedCtx, layoutRef) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert(outerBoundsContain === 'all' || outerBoundsContain === 'axisLabel');\n  }\n  // Assume `updateAllAxisExtentTransByGridRect` has been performed once before this call.\n  // [NOTE]:\n  // - The bounding rect of the axis elements might be sensitve to variations in `axis.extent` due to strategies\n  //  like hideOverlap/moveOverlap. @see the comment in `LabelLayoutBase['suggestIgnore']`.\n  // - The final `gridRect` might be slightly smaller than the ideally expected result if labels are giant and\n  //  get hidden due to overlapping. More iterations could improve precision, but not performant. We consider\n  //  the current result acceptable, since no alignment among charts can be guaranteed when using this feature.\n  createOrUpdateAxesView(gridRect, axesMap, AxisTickLabelComputingKind.estimate, outerBoundsContain, false, layoutRef);\n  var margin = [0, 0, 0, 0];\n  fillLabelNameOverflowOnOneDimension(0);\n  fillLabelNameOverflowOnOneDimension(1);\n  // If axis is blank, no label can be used to detect overflow.\n  // gridRect itself should not overflow.\n  fillMarginOnOneDimension(gridRect, 0, NaN);\n  fillMarginOnOneDimension(gridRect, 1, NaN);\n  var noPxChange = find(margin, function (item) {\n    return item > 0;\n  }) == null;\n  expandOrShrinkRect(gridRect, margin, true, true, outerBoundsClamp);\n  updateAllAxisExtentTransByGridRect(axesMap, gridRect);\n  return noPxChange;\n  function fillLabelNameOverflowOnOneDimension(xyIdx) {\n    each(axesMap[XY[xyIdx]], function (axis) {\n      if (!shouldAxisShow(axis.model)) {\n        return;\n      }\n      // FIXME: zr Group.union may wrongly union (0, 0, 0, 0) and not performant.\n      // unionRect.union(axis.axisBuilder.group.getBoundingRect());\n      // If ussing Group.getBoundingRect to calculate shrink space, it is not strictly accurate when\n      // the outermost label is ignored and the secondary label is very long and contribute to the\n      // union extension:\n      //      -|---|---|---|\n      //         1,000,000,000\n      // Therefore we calculate them one by one.\n      // Also considered axis may be blank or no labels.\n      var sharedRecord = axisBuilderSharedCtx.ensureRecord(axis.model);\n      var labelInfoList = sharedRecord.labelInfoList;\n      if (labelInfoList) {\n        for (var idx = 0; idx < labelInfoList.length; idx++) {\n          var labelInfo = labelInfoList[idx];\n          var proportion = axis.scale.normalize(getLabelInner(labelInfo.label).tickValue);\n          proportion = xyIdx === 1 ? 1 - proportion : proportion;\n          // xAxis use proportion on x, yAxis use proprotion on y, otherwise not.\n          fillMarginOnOneDimension(labelInfo.rect, xyIdx, proportion);\n          fillMarginOnOneDimension(labelInfo.rect, 1 - xyIdx, NaN);\n        }\n      }\n      var nameLayout = sharedRecord.nameLayout;\n      if (nameLayout) {\n        var proportion = isNameLocationCenter(sharedRecord.nameLocation) ? 0.5 : NaN;\n        fillMarginOnOneDimension(nameLayout.rect, xyIdx, proportion);\n        fillMarginOnOneDimension(nameLayout.rect, 1 - xyIdx, NaN);\n      }\n    });\n  }\n  function fillMarginOnOneDimension(itemRect, xyIdx, proportion // NaN mean no use proportion\n  ) {\n    var overflow1 = outerBoundsRect[XY[xyIdx]] - itemRect[XY[xyIdx]];\n    var overflow2 = itemRect[WH[xyIdx]] + itemRect[XY[xyIdx]] - (outerBoundsRect[WH[xyIdx]] + outerBoundsRect[XY[xyIdx]]);\n    overflow1 = applyProportion(overflow1, 1 - proportion);\n    overflow2 = applyProportion(overflow2, proportion);\n    var minIdx = XY_TO_MARGIN_IDX[xyIdx][0];\n    var maxIdx = XY_TO_MARGIN_IDX[xyIdx][1];\n    margin[minIdx] = mathMax(margin[minIdx], overflow1);\n    margin[maxIdx] = mathMax(margin[maxIdx], overflow2);\n  }\n  function applyProportion(overflow, proportion) {\n    // proportion is not likely to near zero. If so, give up shrink\n    if (overflow > 0 && !eqNaN(proportion) && proportion > 1e-4) {\n      overflow /= proportion;\n    }\n    return overflow;\n  }\n}\nfunction createAxisBiulders(gridRect, cartesians, axesMap, optionContainLabel, api) {\n  var axisBuilderSharedCtx = new AxisBuilderSharedContext(resolveAxisNameOverlapForGrid);\n  each(axesMap, function (axisList) {\n    return each(axisList, function (axis) {\n      if (shouldAxisShow(axis.model)) {\n        // See `AxisBaseOptionCommon['nameMoveOverlap']`.\n        var defaultNameMoveOverlap = !optionContainLabel;\n        axis.axisBuilder = createCartesianAxisViewCommonPartBuilder(gridRect, cartesians, axis.model, api, axisBuilderSharedCtx, defaultNameMoveOverlap);\n      }\n    });\n  });\n  return axisBuilderSharedCtx;\n}\n/**\n * Promote the axis-elements-building from \"view render\" stage to \"coordinate system resize\" stage.\n * This is aimed to resovle overlap across multiple axes, since currently it's hard to reconcile\n * multiple axes in \"view render\" stage.\n *\n * [CAUTION] But this promotion assumes that the subsequent \"visual mapping\" stage does not affect\n * this axis-elements-building; otherwise we have to refactor it again.\n */\nfunction createOrUpdateAxesView(gridRect, axesMap, kind, outerBoundsContain, noPxChange, layoutRef) {\n  var isDetermine = kind === AxisTickLabelComputingKind.determine;\n  each(axesMap, function (axisList) {\n    return each(axisList, function (axis) {\n      if (shouldAxisShow(axis.model)) {\n        updateCartesianAxisViewCommonPartBuilder(axis.axisBuilder, gridRect, axis.model);\n        axis.axisBuilder.build(isDetermine ? {\n          axisTickLabelDetermine: true\n        } : {\n          axisTickLabelEstimate: true\n        }, {\n          noPxChange: noPxChange\n        });\n      }\n    });\n  });\n  var nameMarginLevelMap = {\n    x: 0,\n    y: 0\n  };\n  calcNameMarginLevel(0);\n  calcNameMarginLevel(1);\n  function calcNameMarginLevel(xyIdx) {\n    nameMarginLevelMap[XY[1 - xyIdx]] = gridRect[WH[xyIdx]] <= layoutRef.refContainer[WH[xyIdx]] * 0.5 ? 0 : 1 - xyIdx === 1 ? 2 : 1;\n  }\n  each(axesMap, function (axisList, xy) {\n    return each(axisList, function (axis) {\n      if (shouldAxisShow(axis.model)) {\n        if (outerBoundsContain === 'all' || isDetermine) {\n          // To resolve overlap, `axisName` layout depends on `axisTickLabel` layout result\n          // (all of the axes of the same `grid`; consider multiple x or y axes).\n          axis.axisBuilder.build({\n            axisName: true\n          }, {\n            nameMarginLevel: nameMarginLevelMap[xy]\n          });\n        }\n        if (isDetermine) {\n          axis.axisBuilder.build({\n            axisLine: true\n          });\n        }\n      }\n    });\n  });\n}\nfunction prepareOuterBounds(gridModel, rawRridRect, layoutRef) {\n  var outerBoundsRect;\n  var optionOuterBoundsMode = gridModel.get('outerBoundsMode', true);\n  if (optionOuterBoundsMode === 'same') {\n    outerBoundsRect = rawRridRect.clone();\n  } else if (optionOuterBoundsMode == null || optionOuterBoundsMode === 'auto') {\n    outerBoundsRect = getLayoutRect(gridModel.get('outerBounds', true) || OUTER_BOUNDS_DEFAULT, layoutRef.refContainer);\n  } else if (optionOuterBoundsMode !== 'none') {\n    if (process.env.NODE_ENV !== 'production') {\n      error(\"Invalid grid[\" + gridModel.componentIndex + \"].outerBoundsMode.\");\n    }\n  }\n  var optionOuterBoundsContain = gridModel.get('outerBoundsContain', true);\n  var parsedOuterBoundsContain;\n  if (optionOuterBoundsContain == null || optionOuterBoundsContain === 'auto') {\n    parsedOuterBoundsContain = 'all';\n  } else if (indexOf(['all', 'axisLabel'], optionOuterBoundsContain) < 0) {\n    if (process.env.NODE_ENV !== 'production') {\n      error(\"Invalid grid[\" + gridModel.componentIndex + \"].outerBoundsContain.\");\n    }\n    parsedOuterBoundsContain = 'all';\n  } else {\n    parsedOuterBoundsContain = optionOuterBoundsContain;\n  }\n  var outerBoundsClamp = [parsePositionSizeOption(retrieve2(gridModel.get('outerBoundsClampWidth', true), OUTER_BOUNDS_CLAMP_DEFAULT[0]), rawRridRect.width), parsePositionSizeOption(retrieve2(gridModel.get('outerBoundsClampHeight', true), OUTER_BOUNDS_CLAMP_DEFAULT[1]), rawRridRect.height)];\n  return {\n    outerBoundsRect: outerBoundsRect,\n    parsedOuterBoundsContain: parsedOuterBoundsContain,\n    outerBoundsClamp: outerBoundsClamp\n  };\n}\nvar resolveAxisNameOverlapForGrid = function (cfg, ctx, axisModel, nameLayoutInfo, nameMoveDirVec, thisRecord) {\n  var perpendicularDim = axisModel.axis.dim === 'x' ? 'y' : 'x';\n  resolveAxisNameOverlapDefault(cfg, ctx, axisModel, nameLayoutInfo, nameMoveDirVec, thisRecord);\n  // If nameLocation 'center', and there are multiple axes parallel to this axis, do not adjust by\n  //  other axes, because the axis name should be close to its axis line as much as possible even\n  //  if overlapping; otherwise it might cause misleading.\n  // If nameLocation 'center', do not adjust by perpendicular axes, since they are not likely to overlap.\n  // If nameLocation 'start'/'end', move name within the same direction to escape overlap with the\n  //  perpendicular axes.\n  if (!isNameLocationCenter(cfg.nameLocation)) {\n    each(ctx.recordMap[perpendicularDim], function (perpenRecord) {\n      // perpendicular axis may be no name.\n      if (perpenRecord && perpenRecord.labelInfoList && perpenRecord.dirVec) {\n        moveIfOverlapByLinearLabels(perpenRecord.labelInfoList, perpenRecord.dirVec, nameLayoutInfo, nameMoveDirVec);\n      }\n    });\n  }\n};\nexport default Grid;","map":{"version":3,"names":["isObject","each","indexOf","retrieve3","keys","assert","eqNaN","find","retrieve2","createBoxLayoutReference","getLayoutRect","createScaleByModel","ifAxisCrossZero","niceScaleExtent","getDataDimensionsOnAxis","isNameLocationCenter","shouldAxisShow","Cartesian2D","cartesian2DDimensions","Axis2D","SINGLE_REFERRING","OUTER_BOUNDS_CLAMP_DEFAULT","OUTER_BOUNDS_DEFAULT","findAxisModels","createCartesianAxisViewCommonPartBuilder","updateCartesianAxisViewCommonPartBuilder","isCartesian2DInjectedAsDataCoordSys","isIntervalOrLogScale","alignScaleTicks","expandOrShrinkRect","WH","XY","AxisBuilderSharedContext","resolveAxisNameOverlapDefault","moveIfOverlapByLinearLabels","getLabelInner","error","log","AxisTickLabelComputingKind","injectCoordSysByOption","mathMax","parsePositionSizeOption","XY_TO_MARGIN_IDX","Grid","gridModel","ecModel","api","type","_coordsMap","_coordsList","_axesMap","_axesList","axisPointerEnabled","dimensions","_initCartesian","model","prototype","getRect","_rect","update","axesMap","_updateScale","updateAxisTicks","axes","alignTo","axesIndices","len","length","axisNeedsAlign","i","idx","axis","scale","get","push","pop","x","y","onZeroRecords","xAxis","fixAxisOnZero","yAxis","resize","beforeDataProcessing","layoutRef","gridRect","getBoxLayoutParams","refContainer","coordsList","optionContainLabel","updateAllAxisExtentTransByGridRect","axisBuilderSharedCtx","createAxisBiulders","noPxChange","legacyLayOutGridByContainLabel","process","env","NODE_ENV","layOutGridByOuterBounds","clone","_a","prepareOuterBounds","outerBoundsRect","parsedOuterBoundsContain","outerBoundsClamp","createOrUpdateAxesView","determine","coord","calcAffineTransform","getAxis","dim","axisIndex","axesMapOnDim","getAxes","slice","getCartesian","xAxisIndex","yAxisIndex","key","coordList","index","getCartesians","convertToPixel","finder","value","target","_findConvertTarget","cartesian","dataToPoint","toGlobalCoord","dataToCoord","convertFromPixel","pointToData","coordToData","toLocalCoord","seriesModel","xAxisModel","getReferringComponents","models","yAxisModel","coordinateSystem","componentIndex","grid","containPoint","point","_this","axisPositionUsed","left","right","top","bottom","axesCount","eachComponent","createAxisCreator","master","addAxis","dimName","axisModel","isAxisUsedInTheGrid","axisPosition","isCategory","onBand","inverse","setExtent","Infinity","categorySortInfo","setSortInfo","eachSeries","axesModelMap","data","getData","unionExtent","unionExtentFromData","getTooltipAxes","baseAxes","otherAxes","baseAxis","getBaseAxis","otherAxis","getOtherAxis","create","grids","name","targetModel","coordSysType","coordSysProvider","getCoordSysModel","Error","otherAxisDim","getAxesOnZeroOf","otherAxisOnZeroOf","onZero","onZeroAxisIndex","canOnZeroToAxis","hasOwnProperty","getOnZeroRecordKey","updateAxisTransform","coordBase","axisExtent","getExtent","axisExtentSum","updateAxisExtentTransByGridRect","width","height","gridXY","gridWH","extent","registerLegacyGridContainLabelImpl","impl","outerBoundsContain","estimate","margin","fillLabelNameOverflowOnOneDimension","fillMarginOnOneDimension","NaN","item","xyIdx","sharedRecord","ensureRecord","labelInfoList","labelInfo","proportion","normalize","label","tickValue","rect","nameLayout","nameLocation","itemRect","overflow1","overflow2","applyProportion","minIdx","maxIdx","overflow","cartesians","resolveAxisNameOverlapForGrid","axisList","defaultNameMoveOverlap","axisBuilder","kind","isDetermine","build","axisTickLabelDetermine","axisTickLabelEstimate","nameMarginLevelMap","calcNameMarginLevel","xy","axisName","nameMarginLevel","axisLine","rawRridRect","optionOuterBoundsMode","optionOuterBoundsContain","cfg","ctx","nameLayoutInfo","nameMoveDirVec","thisRecord","perpendicularDim","recordMap","perpenRecord","dirVec"],"sources":["D:/code/java/program/oj/code/yuoj-frontend-master/node_modules/echarts/lib/coord/cartesian/Grid.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n/**\n * Grid is a region which contains at most 4 cartesian systems\n *\n * TODO Default cartesian\n */\nimport { isObject, each, indexOf, retrieve3, keys, assert, eqNaN, find, retrieve2 } from 'zrender/lib/core/util.js';\nimport { createBoxLayoutReference, getLayoutRect } from '../../util/layout.js';\nimport { createScaleByModel, ifAxisCrossZero, niceScaleExtent, getDataDimensionsOnAxis, isNameLocationCenter, shouldAxisShow } from '../../coord/axisHelper.js';\nimport Cartesian2D, { cartesian2DDimensions } from './Cartesian2D.js';\nimport Axis2D from './Axis2D.js';\nimport { SINGLE_REFERRING } from '../../util/model.js';\n// Depends on GridModel, AxisModel, which performs preprocess.\nimport { OUTER_BOUNDS_CLAMP_DEFAULT, OUTER_BOUNDS_DEFAULT } from './GridModel.js';\nimport { findAxisModels, createCartesianAxisViewCommonPartBuilder, updateCartesianAxisViewCommonPartBuilder, isCartesian2DInjectedAsDataCoordSys } from './cartesianAxisHelper.js';\nimport { isIntervalOrLogScale } from '../../scale/helper.js';\nimport { alignScaleTicks } from '../axisAlignTicks.js';\nimport { expandOrShrinkRect, WH, XY } from '../../util/graphic.js';\nimport { AxisBuilderSharedContext, resolveAxisNameOverlapDefault, moveIfOverlapByLinearLabels, getLabelInner } from '../../component/axis/AxisBuilder.js';\nimport { error, log } from '../../util/log.js';\nimport { AxisTickLabelComputingKind } from '../axisTickLabelBuilder.js';\nimport { injectCoordSysByOption } from '../../core/CoordinateSystem.js';\nimport { mathMax, parsePositionSizeOption } from '../../util/number.js';\n// margin is [top, right, bottom, left]\nvar XY_TO_MARGIN_IDX = [[3, 1], [0, 2] // xyIdx 1 => 'y'\n];\nvar Grid = /** @class */function () {\n  function Grid(gridModel, ecModel, api) {\n    // FIXME:TS where used (different from registered type 'cartesian2d')?\n    this.type = 'grid';\n    this._coordsMap = {};\n    this._coordsList = [];\n    this._axesMap = {};\n    this._axesList = [];\n    this.axisPointerEnabled = true;\n    this.dimensions = cartesian2DDimensions;\n    this._initCartesian(gridModel, ecModel, api);\n    this.model = gridModel;\n  }\n  Grid.prototype.getRect = function () {\n    return this._rect;\n  };\n  Grid.prototype.update = function (ecModel, api) {\n    var axesMap = this._axesMap;\n    this._updateScale(ecModel, this.model);\n    function updateAxisTicks(axes) {\n      var alignTo;\n      // Axis is added in order of axisIndex.\n      var axesIndices = keys(axes);\n      var len = axesIndices.length;\n      if (!len) {\n        return;\n      }\n      var axisNeedsAlign = [];\n      // Process once and calculate the ticks for those don't use alignTicks.\n      for (var i = len - 1; i >= 0; i--) {\n        var idx = +axesIndices[i]; // Convert to number.\n        var axis = axes[idx];\n        var model = axis.model;\n        var scale = axis.scale;\n        if (\n        // Only value and log axis without interval support alignTicks.\n        isIntervalOrLogScale(scale) && model.get('alignTicks') && model.get('interval') == null) {\n          axisNeedsAlign.push(axis);\n        } else {\n          niceScaleExtent(scale, model);\n          if (isIntervalOrLogScale(scale)) {\n            // Can only align to interval or log axis.\n            alignTo = axis;\n          }\n        }\n      }\n      ;\n      // All axes has set alignTicks. Pick the first one.\n      // PENDING. Should we find the axis that both set interval, min, max and align to this one?\n      if (axisNeedsAlign.length) {\n        if (!alignTo) {\n          alignTo = axisNeedsAlign.pop();\n          niceScaleExtent(alignTo.scale, alignTo.model);\n        }\n        each(axisNeedsAlign, function (axis) {\n          alignScaleTicks(axis.scale, axis.model, alignTo.scale);\n        });\n      }\n    }\n    updateAxisTicks(axesMap.x);\n    updateAxisTicks(axesMap.y);\n    // Key: axisDim_axisIndex, value: boolean, whether onZero target.\n    var onZeroRecords = {};\n    each(axesMap.x, function (xAxis) {\n      fixAxisOnZero(axesMap, 'y', xAxis, onZeroRecords);\n    });\n    each(axesMap.y, function (yAxis) {\n      fixAxisOnZero(axesMap, 'x', yAxis, onZeroRecords);\n    });\n    // Resize again if containLabel is enabled\n    // FIXME It may cause getting wrong grid size in data processing stage\n    this.resize(this.model, api);\n  };\n  /**\n   * Resize the grid.\n   *\n   * [NOTE]\n   * If both \"grid.containLabel/grid.contain\" and pixel-required-data-processing (such as, \"dataSampling\")\n   * exist, circular dependency occurs in logic.\n   * The final compromised sequence is:\n   *  1. Calculate \"axis.extent\" (pixel extent) and AffineTransform based on only \"grid layout options\".\n   *      Not accurate if \"grid.containLabel/grid.contain\" is required, but it is a compromise to avoid\n   *      circular dependency.\n   *  2. Perform \"series data processing\" (where \"dataSampling\" requires \"axis.extent\").\n   *  3. Calculate \"scale.extent\" (data extent) based on \"processed series data\".\n   *  4. Modify \"axis.extent\" for \"grid.containLabel/grid.contain\":\n   *      4.1. Calculate \"axis labels\" based on \"scale.extent\".\n   *      4.2. Modify \"axis.extent\" by the bounding rects of \"axis labels and names\".\n   */\n  Grid.prototype.resize = function (gridModel, api, beforeDataProcessing) {\n    var layoutRef = createBoxLayoutReference(gridModel, api);\n    var gridRect = this._rect = getLayoutRect(gridModel.getBoxLayoutParams(), layoutRef.refContainer);\n    // PENDING: whether to support that if the input `coord` is out of the base coord sys,\n    //  do not render anything. At present, the behavior is undefined.\n    var axesMap = this._axesMap;\n    var coordsList = this._coordsList;\n    var optionContainLabel = gridModel.get('containLabel'); // No `.get(, true)` for backward compat.\n    updateAllAxisExtentTransByGridRect(axesMap, gridRect);\n    if (!beforeDataProcessing) {\n      var axisBuilderSharedCtx = createAxisBiulders(gridRect, coordsList, axesMap, optionContainLabel, api);\n      var noPxChange = void 0;\n      if (optionContainLabel) {\n        if (legacyLayOutGridByContainLabel) {\n          // console.time('legacyLayOutGridByContainLabel');\n          legacyLayOutGridByContainLabel(this._axesList, gridRect);\n          updateAllAxisExtentTransByGridRect(axesMap, gridRect);\n          // console.timeEnd('legacyLayOutGridByContainLabel');\n        } else {\n          if (process.env.NODE_ENV !== 'production') {\n            log('Specified `grid.containLabel` but no `use(LegacyGridContainLabel)`;' + 'use `grid.outerBounds` instead.', true);\n          }\n          noPxChange = layOutGridByOuterBounds(gridRect.clone(), 'axisLabel', null, gridRect, axesMap, axisBuilderSharedCtx, layoutRef);\n        }\n      } else {\n        var _a = prepareOuterBounds(gridModel, gridRect, layoutRef),\n          outerBoundsRect = _a.outerBoundsRect,\n          parsedOuterBoundsContain = _a.parsedOuterBoundsContain,\n          outerBoundsClamp = _a.outerBoundsClamp;\n        if (outerBoundsRect) {\n          // console.time('layOutGridByOuterBounds');\n          noPxChange = layOutGridByOuterBounds(outerBoundsRect, parsedOuterBoundsContain, outerBoundsClamp, gridRect, axesMap, axisBuilderSharedCtx, layoutRef);\n          // console.timeEnd('layOutGridByOuterBounds');\n        }\n      }\n      // console.time('buildAxesView_determine');\n      createOrUpdateAxesView(gridRect, axesMap, AxisTickLabelComputingKind.determine, null, noPxChange, layoutRef);\n      // console.timeEnd('buildAxesView_determine');\n    } // End of beforeDataProcessing\n    each(this._coordsList, function (coord) {\n      // Calculate affine matrix to accelerate the data to point transform.\n      // If all the axes scales are time or value.\n      coord.calcAffineTransform();\n    });\n  };\n  Grid.prototype.getAxis = function (dim, axisIndex) {\n    var axesMapOnDim = this._axesMap[dim];\n    if (axesMapOnDim != null) {\n      return axesMapOnDim[axisIndex || 0];\n    }\n  };\n  Grid.prototype.getAxes = function () {\n    return this._axesList.slice();\n  };\n  Grid.prototype.getCartesian = function (xAxisIndex, yAxisIndex) {\n    if (xAxisIndex != null && yAxisIndex != null) {\n      var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n      return this._coordsMap[key];\n    }\n    if (isObject(xAxisIndex)) {\n      yAxisIndex = xAxisIndex.yAxisIndex;\n      xAxisIndex = xAxisIndex.xAxisIndex;\n    }\n    for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {\n      if (coordList[i].getAxis('x').index === xAxisIndex || coordList[i].getAxis('y').index === yAxisIndex) {\n        return coordList[i];\n      }\n    }\n  };\n  Grid.prototype.getCartesians = function () {\n    return this._coordsList.slice();\n  };\n  /**\n   * @implements\n   */\n  Grid.prototype.convertToPixel = function (ecModel, finder, value) {\n    var target = this._findConvertTarget(finder);\n    return target.cartesian ? target.cartesian.dataToPoint(value) : target.axis ? target.axis.toGlobalCoord(target.axis.dataToCoord(value)) : null;\n  };\n  /**\n   * @implements\n   */\n  Grid.prototype.convertFromPixel = function (ecModel, finder, value) {\n    var target = this._findConvertTarget(finder);\n    return target.cartesian ? target.cartesian.pointToData(value) : target.axis ? target.axis.coordToData(target.axis.toLocalCoord(value)) : null;\n  };\n  Grid.prototype._findConvertTarget = function (finder) {\n    var seriesModel = finder.seriesModel;\n    var xAxisModel = finder.xAxisModel || seriesModel && seriesModel.getReferringComponents('xAxis', SINGLE_REFERRING).models[0];\n    var yAxisModel = finder.yAxisModel || seriesModel && seriesModel.getReferringComponents('yAxis', SINGLE_REFERRING).models[0];\n    var gridModel = finder.gridModel;\n    var coordsList = this._coordsList;\n    var cartesian;\n    var axis;\n    if (seriesModel) {\n      cartesian = seriesModel.coordinateSystem;\n      indexOf(coordsList, cartesian) < 0 && (cartesian = null);\n    } else if (xAxisModel && yAxisModel) {\n      cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n    } else if (xAxisModel) {\n      axis = this.getAxis('x', xAxisModel.componentIndex);\n    } else if (yAxisModel) {\n      axis = this.getAxis('y', yAxisModel.componentIndex);\n    }\n    // Lowest priority.\n    else if (gridModel) {\n      var grid = gridModel.coordinateSystem;\n      if (grid === this) {\n        cartesian = this._coordsList[0];\n      }\n    }\n    return {\n      cartesian: cartesian,\n      axis: axis\n    };\n  };\n  /**\n   * @implements\n   */\n  Grid.prototype.containPoint = function (point) {\n    var coord = this._coordsList[0];\n    if (coord) {\n      return coord.containPoint(point);\n    }\n  };\n  /**\n   * Initialize cartesian coordinate systems\n   */\n  Grid.prototype._initCartesian = function (gridModel, ecModel, api) {\n    var _this = this;\n    var grid = this;\n    var axisPositionUsed = {\n      left: false,\n      right: false,\n      top: false,\n      bottom: false\n    };\n    var axesMap = {\n      x: {},\n      y: {}\n    };\n    var axesCount = {\n      x: 0,\n      y: 0\n    };\n    // Create axis\n    ecModel.eachComponent('xAxis', createAxisCreator('x'), this);\n    ecModel.eachComponent('yAxis', createAxisCreator('y'), this);\n    if (!axesCount.x || !axesCount.y) {\n      // Roll back when there no either x or y axis\n      this._axesMap = {};\n      this._axesList = [];\n      return;\n    }\n    this._axesMap = axesMap;\n    // Create cartesian2d\n    each(axesMap.x, function (xAxis, xAxisIndex) {\n      each(axesMap.y, function (yAxis, yAxisIndex) {\n        var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n        var cartesian = new Cartesian2D(key);\n        cartesian.master = _this;\n        cartesian.model = gridModel;\n        _this._coordsMap[key] = cartesian;\n        _this._coordsList.push(cartesian);\n        cartesian.addAxis(xAxis);\n        cartesian.addAxis(yAxis);\n      });\n    });\n    function createAxisCreator(dimName) {\n      return function (axisModel, idx) {\n        if (!isAxisUsedInTheGrid(axisModel, gridModel)) {\n          return;\n        }\n        var axisPosition = axisModel.get('position');\n        if (dimName === 'x') {\n          // Fix position\n          if (axisPosition !== 'top' && axisPosition !== 'bottom') {\n            // Default bottom of X\n            axisPosition = axisPositionUsed.bottom ? 'top' : 'bottom';\n          }\n        } else {\n          // Fix position\n          if (axisPosition !== 'left' && axisPosition !== 'right') {\n            // Default left of Y\n            axisPosition = axisPositionUsed.left ? 'right' : 'left';\n          }\n        }\n        axisPositionUsed[axisPosition] = true;\n        var axis = new Axis2D(dimName, createScaleByModel(axisModel), [0, 0], axisModel.get('type'), axisPosition);\n        var isCategory = axis.type === 'category';\n        axis.onBand = isCategory && axisModel.get('boundaryGap');\n        axis.inverse = axisModel.get('inverse');\n        // Inject axis into axisModel\n        axisModel.axis = axis;\n        // Inject axisModel into axis\n        axis.model = axisModel;\n        // Inject grid info axis\n        axis.grid = grid;\n        // Index of axis, can be used as key\n        axis.index = idx;\n        grid._axesList.push(axis);\n        axesMap[dimName][idx] = axis;\n        axesCount[dimName]++;\n      };\n    }\n  };\n  /**\n   * Update cartesian properties from series.\n   */\n  Grid.prototype._updateScale = function (ecModel, gridModel) {\n    // Reset scale\n    each(this._axesList, function (axis) {\n      axis.scale.setExtent(Infinity, -Infinity);\n      if (axis.type === 'category') {\n        var categorySortInfo = axis.model.get('categorySortInfo');\n        axis.scale.setSortInfo(categorySortInfo);\n      }\n    });\n    ecModel.eachSeries(function (seriesModel) {\n      // If pie (or other similar series) use cartesian2d, the unionExtent logic below is\n      // wrong, therefore skip it temporarily. See also in `defaultAxisExtentFromData.ts`.\n      // TODO: support union extent in this case.\n      if (isCartesian2DInjectedAsDataCoordSys(seriesModel)) {\n        var axesModelMap = findAxisModels(seriesModel);\n        var xAxisModel = axesModelMap.xAxisModel;\n        var yAxisModel = axesModelMap.yAxisModel;\n        if (!isAxisUsedInTheGrid(xAxisModel, gridModel) || !isAxisUsedInTheGrid(yAxisModel, gridModel)) {\n          return;\n        }\n        var cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n        var data = seriesModel.getData();\n        var xAxis = cartesian.getAxis('x');\n        var yAxis = cartesian.getAxis('y');\n        unionExtent(data, xAxis);\n        unionExtent(data, yAxis);\n      }\n    }, this);\n    function unionExtent(data, axis) {\n      each(getDataDimensionsOnAxis(data, axis.dim), function (dim) {\n        axis.scale.unionExtentFromData(data, dim);\n      });\n    }\n  };\n  /**\n   * @param dim 'x' or 'y' or 'auto' or null/undefined\n   */\n  Grid.prototype.getTooltipAxes = function (dim) {\n    var baseAxes = [];\n    var otherAxes = [];\n    each(this.getCartesians(), function (cartesian) {\n      var baseAxis = dim != null && dim !== 'auto' ? cartesian.getAxis(dim) : cartesian.getBaseAxis();\n      var otherAxis = cartesian.getOtherAxis(baseAxis);\n      indexOf(baseAxes, baseAxis) < 0 && baseAxes.push(baseAxis);\n      indexOf(otherAxes, otherAxis) < 0 && otherAxes.push(otherAxis);\n    });\n    return {\n      baseAxes: baseAxes,\n      otherAxes: otherAxes\n    };\n  };\n  Grid.create = function (ecModel, api) {\n    var grids = [];\n    ecModel.eachComponent('grid', function (gridModel, idx) {\n      var grid = new Grid(gridModel, ecModel, api);\n      grid.name = 'grid_' + idx;\n      // dataSampling requires axis extent, so resize\n      // should be performed in create stage.\n      grid.resize(gridModel, api, true);\n      gridModel.coordinateSystem = grid;\n      grids.push(grid);\n    });\n    // Inject the coordinateSystems into seriesModel\n    ecModel.eachSeries(function (seriesModel) {\n      injectCoordSysByOption({\n        targetModel: seriesModel,\n        coordSysType: 'cartesian2d',\n        coordSysProvider: coordSysProvider\n      });\n      function coordSysProvider() {\n        var axesModelMap = findAxisModels(seriesModel);\n        var xAxisModel = axesModelMap.xAxisModel;\n        var yAxisModel = axesModelMap.yAxisModel;\n        var gridModel = xAxisModel.getCoordSysModel();\n        if (process.env.NODE_ENV !== 'production') {\n          if (!gridModel) {\n            throw new Error('Grid \"' + retrieve3(xAxisModel.get('gridIndex'), xAxisModel.get('gridId'), 0) + '\" not found');\n          }\n          if (xAxisModel.getCoordSysModel() !== yAxisModel.getCoordSysModel()) {\n            throw new Error('xAxis and yAxis must use the same grid');\n          }\n        }\n        var grid = gridModel.coordinateSystem;\n        return grid.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n      }\n    });\n    return grids;\n  };\n  // For deciding which dimensions to use when creating list data\n  Grid.dimensions = cartesian2DDimensions;\n  return Grid;\n}();\n/**\n * Check if the axis is used in the specified grid.\n */\nfunction isAxisUsedInTheGrid(axisModel, gridModel) {\n  return axisModel.getCoordSysModel() === gridModel;\n}\nfunction fixAxisOnZero(axesMap, otherAxisDim, axis,\n// Key: see `getOnZeroRecordKey`\nonZeroRecords) {\n  axis.getAxesOnZeroOf = function () {\n    // TODO: onZero of multiple axes.\n    return otherAxisOnZeroOf ? [otherAxisOnZeroOf] : [];\n  };\n  // onZero can not be enabled in these two situations:\n  // 1. When any other axis is a category axis.\n  // 2. When no axis is cross 0 point.\n  var otherAxes = axesMap[otherAxisDim];\n  var otherAxisOnZeroOf;\n  var axisModel = axis.model;\n  var onZero = axisModel.get(['axisLine', 'onZero']);\n  var onZeroAxisIndex = axisModel.get(['axisLine', 'onZeroAxisIndex']);\n  if (!onZero) {\n    return;\n  }\n  // If target axis is specified.\n  if (onZeroAxisIndex != null) {\n    if (canOnZeroToAxis(otherAxes[onZeroAxisIndex])) {\n      otherAxisOnZeroOf = otherAxes[onZeroAxisIndex];\n    }\n  } else {\n    // Find the first available other axis.\n    for (var idx in otherAxes) {\n      if (otherAxes.hasOwnProperty(idx) && canOnZeroToAxis(otherAxes[idx])\n      // Consider that two Y axes on one value axis,\n      // if both onZero, the two Y axes overlap.\n      && !onZeroRecords[getOnZeroRecordKey(otherAxes[idx])]) {\n        otherAxisOnZeroOf = otherAxes[idx];\n        break;\n      }\n    }\n  }\n  if (otherAxisOnZeroOf) {\n    onZeroRecords[getOnZeroRecordKey(otherAxisOnZeroOf)] = true;\n  }\n  function getOnZeroRecordKey(axis) {\n    return axis.dim + '_' + axis.index;\n  }\n}\nfunction canOnZeroToAxis(axis) {\n  return axis && axis.type !== 'category' && axis.type !== 'time' && ifAxisCrossZero(axis);\n}\nfunction updateAxisTransform(axis, coordBase) {\n  var axisExtent = axis.getExtent();\n  var axisExtentSum = axisExtent[0] + axisExtent[1];\n  // Fast transform\n  axis.toGlobalCoord = axis.dim === 'x' ? function (coord) {\n    return coord + coordBase;\n  } : function (coord) {\n    return axisExtentSum - coord + coordBase;\n  };\n  axis.toLocalCoord = axis.dim === 'x' ? function (coord) {\n    return coord - coordBase;\n  } : function (coord) {\n    return axisExtentSum - coord + coordBase;\n  };\n}\nfunction updateAllAxisExtentTransByGridRect(axesMap, gridRect) {\n  each(axesMap.x, function (axis) {\n    return updateAxisExtentTransByGridRect(axis, gridRect.x, gridRect.width);\n  });\n  each(axesMap.y, function (axis) {\n    return updateAxisExtentTransByGridRect(axis, gridRect.y, gridRect.height);\n  });\n}\nfunction updateAxisExtentTransByGridRect(axis, gridXY, gridWH) {\n  var extent = [0, gridWH];\n  var idx = axis.inverse ? 1 : 0;\n  axis.setExtent(extent[idx], extent[1 - idx]);\n  updateAxisTransform(axis, gridXY);\n}\nvar legacyLayOutGridByContainLabel;\nexport function registerLegacyGridContainLabelImpl(impl) {\n  legacyLayOutGridByContainLabel = impl;\n}\n// Return noPxChange.\nfunction layOutGridByOuterBounds(outerBoundsRect, outerBoundsContain, outerBoundsClamp, gridRect, axesMap, axisBuilderSharedCtx, layoutRef) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert(outerBoundsContain === 'all' || outerBoundsContain === 'axisLabel');\n  }\n  // Assume `updateAllAxisExtentTransByGridRect` has been performed once before this call.\n  // [NOTE]:\n  // - The bounding rect of the axis elements might be sensitve to variations in `axis.extent` due to strategies\n  //  like hideOverlap/moveOverlap. @see the comment in `LabelLayoutBase['suggestIgnore']`.\n  // - The final `gridRect` might be slightly smaller than the ideally expected result if labels are giant and\n  //  get hidden due to overlapping. More iterations could improve precision, but not performant. We consider\n  //  the current result acceptable, since no alignment among charts can be guaranteed when using this feature.\n  createOrUpdateAxesView(gridRect, axesMap, AxisTickLabelComputingKind.estimate, outerBoundsContain, false, layoutRef);\n  var margin = [0, 0, 0, 0];\n  fillLabelNameOverflowOnOneDimension(0);\n  fillLabelNameOverflowOnOneDimension(1);\n  // If axis is blank, no label can be used to detect overflow.\n  // gridRect itself should not overflow.\n  fillMarginOnOneDimension(gridRect, 0, NaN);\n  fillMarginOnOneDimension(gridRect, 1, NaN);\n  var noPxChange = find(margin, function (item) {\n    return item > 0;\n  }) == null;\n  expandOrShrinkRect(gridRect, margin, true, true, outerBoundsClamp);\n  updateAllAxisExtentTransByGridRect(axesMap, gridRect);\n  return noPxChange;\n  function fillLabelNameOverflowOnOneDimension(xyIdx) {\n    each(axesMap[XY[xyIdx]], function (axis) {\n      if (!shouldAxisShow(axis.model)) {\n        return;\n      }\n      // FIXME: zr Group.union may wrongly union (0, 0, 0, 0) and not performant.\n      // unionRect.union(axis.axisBuilder.group.getBoundingRect());\n      // If ussing Group.getBoundingRect to calculate shrink space, it is not strictly accurate when\n      // the outermost label is ignored and the secondary label is very long and contribute to the\n      // union extension:\n      //      -|---|---|---|\n      //         1,000,000,000\n      // Therefore we calculate them one by one.\n      // Also considered axis may be blank or no labels.\n      var sharedRecord = axisBuilderSharedCtx.ensureRecord(axis.model);\n      var labelInfoList = sharedRecord.labelInfoList;\n      if (labelInfoList) {\n        for (var idx = 0; idx < labelInfoList.length; idx++) {\n          var labelInfo = labelInfoList[idx];\n          var proportion = axis.scale.normalize(getLabelInner(labelInfo.label).tickValue);\n          proportion = xyIdx === 1 ? 1 - proportion : proportion;\n          // xAxis use proportion on x, yAxis use proprotion on y, otherwise not.\n          fillMarginOnOneDimension(labelInfo.rect, xyIdx, proportion);\n          fillMarginOnOneDimension(labelInfo.rect, 1 - xyIdx, NaN);\n        }\n      }\n      var nameLayout = sharedRecord.nameLayout;\n      if (nameLayout) {\n        var proportion = isNameLocationCenter(sharedRecord.nameLocation) ? 0.5 : NaN;\n        fillMarginOnOneDimension(nameLayout.rect, xyIdx, proportion);\n        fillMarginOnOneDimension(nameLayout.rect, 1 - xyIdx, NaN);\n      }\n    });\n  }\n  function fillMarginOnOneDimension(itemRect, xyIdx, proportion // NaN mean no use proportion\n  ) {\n    var overflow1 = outerBoundsRect[XY[xyIdx]] - itemRect[XY[xyIdx]];\n    var overflow2 = itemRect[WH[xyIdx]] + itemRect[XY[xyIdx]] - (outerBoundsRect[WH[xyIdx]] + outerBoundsRect[XY[xyIdx]]);\n    overflow1 = applyProportion(overflow1, 1 - proportion);\n    overflow2 = applyProportion(overflow2, proportion);\n    var minIdx = XY_TO_MARGIN_IDX[xyIdx][0];\n    var maxIdx = XY_TO_MARGIN_IDX[xyIdx][1];\n    margin[minIdx] = mathMax(margin[minIdx], overflow1);\n    margin[maxIdx] = mathMax(margin[maxIdx], overflow2);\n  }\n  function applyProportion(overflow, proportion) {\n    // proportion is not likely to near zero. If so, give up shrink\n    if (overflow > 0 && !eqNaN(proportion) && proportion > 1e-4) {\n      overflow /= proportion;\n    }\n    return overflow;\n  }\n}\nfunction createAxisBiulders(gridRect, cartesians, axesMap, optionContainLabel, api) {\n  var axisBuilderSharedCtx = new AxisBuilderSharedContext(resolveAxisNameOverlapForGrid);\n  each(axesMap, function (axisList) {\n    return each(axisList, function (axis) {\n      if (shouldAxisShow(axis.model)) {\n        // See `AxisBaseOptionCommon['nameMoveOverlap']`.\n        var defaultNameMoveOverlap = !optionContainLabel;\n        axis.axisBuilder = createCartesianAxisViewCommonPartBuilder(gridRect, cartesians, axis.model, api, axisBuilderSharedCtx, defaultNameMoveOverlap);\n      }\n    });\n  });\n  return axisBuilderSharedCtx;\n}\n/**\n * Promote the axis-elements-building from \"view render\" stage to \"coordinate system resize\" stage.\n * This is aimed to resovle overlap across multiple axes, since currently it's hard to reconcile\n * multiple axes in \"view render\" stage.\n *\n * [CAUTION] But this promotion assumes that the subsequent \"visual mapping\" stage does not affect\n * this axis-elements-building; otherwise we have to refactor it again.\n */\nfunction createOrUpdateAxesView(gridRect, axesMap, kind, outerBoundsContain, noPxChange, layoutRef) {\n  var isDetermine = kind === AxisTickLabelComputingKind.determine;\n  each(axesMap, function (axisList) {\n    return each(axisList, function (axis) {\n      if (shouldAxisShow(axis.model)) {\n        updateCartesianAxisViewCommonPartBuilder(axis.axisBuilder, gridRect, axis.model);\n        axis.axisBuilder.build(isDetermine ? {\n          axisTickLabelDetermine: true\n        } : {\n          axisTickLabelEstimate: true\n        }, {\n          noPxChange: noPxChange\n        });\n      }\n    });\n  });\n  var nameMarginLevelMap = {\n    x: 0,\n    y: 0\n  };\n  calcNameMarginLevel(0);\n  calcNameMarginLevel(1);\n  function calcNameMarginLevel(xyIdx) {\n    nameMarginLevelMap[XY[1 - xyIdx]] = gridRect[WH[xyIdx]] <= layoutRef.refContainer[WH[xyIdx]] * 0.5 ? 0 : 1 - xyIdx === 1 ? 2 : 1;\n  }\n  each(axesMap, function (axisList, xy) {\n    return each(axisList, function (axis) {\n      if (shouldAxisShow(axis.model)) {\n        if (outerBoundsContain === 'all' || isDetermine) {\n          // To resolve overlap, `axisName` layout depends on `axisTickLabel` layout result\n          // (all of the axes of the same `grid`; consider multiple x or y axes).\n          axis.axisBuilder.build({\n            axisName: true\n          }, {\n            nameMarginLevel: nameMarginLevelMap[xy]\n          });\n        }\n        if (isDetermine) {\n          axis.axisBuilder.build({\n            axisLine: true\n          });\n        }\n      }\n    });\n  });\n}\nfunction prepareOuterBounds(gridModel, rawRridRect, layoutRef) {\n  var outerBoundsRect;\n  var optionOuterBoundsMode = gridModel.get('outerBoundsMode', true);\n  if (optionOuterBoundsMode === 'same') {\n    outerBoundsRect = rawRridRect.clone();\n  } else if (optionOuterBoundsMode == null || optionOuterBoundsMode === 'auto') {\n    outerBoundsRect = getLayoutRect(gridModel.get('outerBounds', true) || OUTER_BOUNDS_DEFAULT, layoutRef.refContainer);\n  } else if (optionOuterBoundsMode !== 'none') {\n    if (process.env.NODE_ENV !== 'production') {\n      error(\"Invalid grid[\" + gridModel.componentIndex + \"].outerBoundsMode.\");\n    }\n  }\n  var optionOuterBoundsContain = gridModel.get('outerBoundsContain', true);\n  var parsedOuterBoundsContain;\n  if (optionOuterBoundsContain == null || optionOuterBoundsContain === 'auto') {\n    parsedOuterBoundsContain = 'all';\n  } else if (indexOf(['all', 'axisLabel'], optionOuterBoundsContain) < 0) {\n    if (process.env.NODE_ENV !== 'production') {\n      error(\"Invalid grid[\" + gridModel.componentIndex + \"].outerBoundsContain.\");\n    }\n    parsedOuterBoundsContain = 'all';\n  } else {\n    parsedOuterBoundsContain = optionOuterBoundsContain;\n  }\n  var outerBoundsClamp = [parsePositionSizeOption(retrieve2(gridModel.get('outerBoundsClampWidth', true), OUTER_BOUNDS_CLAMP_DEFAULT[0]), rawRridRect.width), parsePositionSizeOption(retrieve2(gridModel.get('outerBoundsClampHeight', true), OUTER_BOUNDS_CLAMP_DEFAULT[1]), rawRridRect.height)];\n  return {\n    outerBoundsRect: outerBoundsRect,\n    parsedOuterBoundsContain: parsedOuterBoundsContain,\n    outerBoundsClamp: outerBoundsClamp\n  };\n}\nvar resolveAxisNameOverlapForGrid = function (cfg, ctx, axisModel, nameLayoutInfo, nameMoveDirVec, thisRecord) {\n  var perpendicularDim = axisModel.axis.dim === 'x' ? 'y' : 'x';\n  resolveAxisNameOverlapDefault(cfg, ctx, axisModel, nameLayoutInfo, nameMoveDirVec, thisRecord);\n  // If nameLocation 'center', and there are multiple axes parallel to this axis, do not adjust by\n  //  other axes, because the axis name should be close to its axis line as much as possible even\n  //  if overlapping; otherwise it might cause misleading.\n  // If nameLocation 'center', do not adjust by perpendicular axes, since they are not likely to overlap.\n  // If nameLocation 'start'/'end', move name within the same direction to escape overlap with the\n  //  perpendicular axes.\n  if (!isNameLocationCenter(cfg.nameLocation)) {\n    each(ctx.recordMap[perpendicularDim], function (perpenRecord) {\n      // perpendicular axis may be no name.\n      if (perpenRecord && perpenRecord.labelInfoList && perpenRecord.dirVec) {\n        moveIfOverlapByLinearLabels(perpenRecord.labelInfoList, perpenRecord.dirVec, nameLayoutInfo, nameMoveDirVec);\n      }\n    });\n  }\n};\nexport default Grid;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
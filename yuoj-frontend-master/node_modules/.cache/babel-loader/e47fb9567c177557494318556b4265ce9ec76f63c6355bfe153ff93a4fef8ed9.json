{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { OffsetRange } from '../../core/offsetRange.js';\nimport { SequenceDiff } from './diffAlgorithm.js';\nexport function optimizeSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\n  let result = sequenceDiffs;\n  result = joinSequenceDiffs(sequence1, sequence2, result);\n  result = shiftSequenceDiffs(sequence1, sequence2, result);\n  return result;\n}\nexport function smoothenSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\n  const result = [];\n  for (const s of sequenceDiffs) {\n    const last = result[result.length - 1];\n    if (!last) {\n      result.push(s);\n      continue;\n    }\n    if (s.seq1Range.start - last.seq1Range.endExclusive <= 2 || s.seq2Range.start - last.seq2Range.endExclusive <= 2) {\n      result[result.length - 1] = new SequenceDiff(last.seq1Range.join(s.seq1Range), last.seq2Range.join(s.seq2Range));\n    } else {\n      result.push(s);\n    }\n  }\n  return result;\n}\nexport function removeRandomMatches(sequence1, sequence2, sequenceDiffs) {\n  let diffs = sequenceDiffs;\n  if (diffs.length === 0) {\n    return diffs;\n  }\n  let counter = 0;\n  let shouldRepeat;\n  do {\n    shouldRepeat = false;\n    const result = [diffs[0]];\n    for (let i = 1; i < diffs.length; i++) {\n      const cur = diffs[i];\n      const lastResult = result[result.length - 1];\n      function shouldJoinDiffs(before, after) {\n        const unchangedRange = new OffsetRange(lastResult.seq1Range.endExclusive, cur.seq1Range.start);\n        const unchangedLineCount = sequence1.countLinesIn(unchangedRange);\n        if (unchangedLineCount > 5 || unchangedRange.length > 500) {\n          return false;\n        }\n        const unchangedText = sequence1.getText(unchangedRange).trim();\n        if (unchangedText.length > 20 || unchangedText.split(/\\r\\n|\\r|\\n/).length > 1) {\n          return false;\n        }\n        const beforeLineCount1 = sequence1.countLinesIn(before.seq1Range);\n        const beforeSeq1Length = before.seq1Range.length;\n        const beforeLineCount2 = sequence2.countLinesIn(before.seq2Range);\n        const beforeSeq2Length = before.seq2Range.length;\n        const afterLineCount1 = sequence1.countLinesIn(after.seq1Range);\n        const afterSeq1Length = after.seq1Range.length;\n        const afterLineCount2 = sequence2.countLinesIn(after.seq2Range);\n        const afterSeq2Length = after.seq2Range.length;\n        // TODO: Maybe a neural net can be used to derive the result from these numbers\n        const max = 2 * 40 + 50;\n        function cap(v) {\n          return Math.min(v, max);\n        }\n        if (Math.pow(Math.pow(cap(beforeLineCount1 * 40 + beforeSeq1Length), 1.5) + Math.pow(cap(beforeLineCount2 * 40 + beforeSeq2Length), 1.5), 1.5) + Math.pow(Math.pow(cap(afterLineCount1 * 40 + afterSeq1Length), 1.5) + Math.pow(cap(afterLineCount2 * 40 + afterSeq2Length), 1.5), 1.5) > Math.pow(Math.pow(max, 1.5), 1.5) * 1.3) {\n          return true;\n        }\n        return false;\n      }\n      const shouldJoin = shouldJoinDiffs(lastResult, cur);\n      if (shouldJoin) {\n        shouldRepeat = true;\n        result[result.length - 1] = result[result.length - 1].join(cur);\n      } else {\n        result.push(cur);\n      }\n    }\n    diffs = result;\n  } while (counter++ < 10 && shouldRepeat);\n  return diffs;\n}\n/**\n * This function fixes issues like this:\n * ```\n * import { Baz, Bar } from \"foo\";\n * ```\n * <->\n * ```\n * import { Baz, Bar, Foo } from \"foo\";\n * ```\n * Computed diff: [ {Add \",\" after Bar}, {Add \"Foo \" after space} }\n * Improved diff: [{Add \", Foo\" after Bar}]\n */\nexport function joinSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\n  if (sequenceDiffs.length === 0) {\n    return sequenceDiffs;\n  }\n  const result = [];\n  result.push(sequenceDiffs[0]);\n  // First move them all to the left as much as possible and join them if possible\n  for (let i = 1; i < sequenceDiffs.length; i++) {\n    const prevResult = result[result.length - 1];\n    let cur = sequenceDiffs[i];\n    if (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {\n      const length = cur.seq1Range.start - prevResult.seq1Range.endExclusive;\n      let d;\n      for (d = 1; d <= length; d++) {\n        if (sequence1.getElement(cur.seq1Range.start - d) !== sequence1.getElement(cur.seq1Range.endExclusive - d) || sequence2.getElement(cur.seq2Range.start - d) !== sequence2.getElement(cur.seq2Range.endExclusive - d)) {\n          break;\n        }\n      }\n      d--;\n      if (d === length) {\n        // Merge previous and current diff\n        result[result.length - 1] = new SequenceDiff(new OffsetRange(prevResult.seq1Range.start, cur.seq1Range.endExclusive - length), new OffsetRange(prevResult.seq2Range.start, cur.seq2Range.endExclusive - length));\n        continue;\n      }\n      cur = cur.delta(-d);\n    }\n    result.push(cur);\n  }\n  const result2 = [];\n  // Then move them all to the right and join them again if possible\n  for (let i = 0; i < result.length - 1; i++) {\n    const nextResult = result[i + 1];\n    let cur = result[i];\n    if (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {\n      const length = nextResult.seq1Range.start - cur.seq1Range.endExclusive;\n      let d;\n      for (d = 0; d < length; d++) {\n        if (sequence1.getElement(cur.seq1Range.start + d) !== sequence1.getElement(cur.seq1Range.endExclusive + d) || sequence2.getElement(cur.seq2Range.start + d) !== sequence2.getElement(cur.seq2Range.endExclusive + d)) {\n          break;\n        }\n      }\n      if (d === length) {\n        // Merge previous and current diff, write to result!\n        result[i + 1] = new SequenceDiff(new OffsetRange(cur.seq1Range.start + length, nextResult.seq1Range.endExclusive), new OffsetRange(cur.seq2Range.start + length, nextResult.seq2Range.endExclusive));\n        continue;\n      }\n      if (d > 0) {\n        cur = cur.delta(d);\n      }\n    }\n    result2.push(cur);\n  }\n  if (result.length > 0) {\n    result2.push(result[result.length - 1]);\n  }\n  return result2;\n}\n// align character level diffs at whitespace characters\n// import { IBar } from \"foo\";\n// import { I[Arr, I]Bar } from \"foo\";\n// ->\n// import { [IArr, ]IBar } from \"foo\";\n// import { ITransaction, observableValue, transaction } from 'vs/base/common/observable';\n// import { ITransaction, observable[FromEvent, observable]Value, transaction } from 'vs/base/common/observable';\n// ->\n// import { ITransaction, [observableFromEvent, ]observableValue, transaction } from 'vs/base/common/observable';\n// collectBrackets(level + 1, levelPerBracketType);\n// collectBrackets(level + 1, levelPerBracket[ + 1, levelPerBracket]Type);\n// ->\n// collectBrackets(level + 1, [levelPerBracket + 1, ]levelPerBracketType);\nexport function shiftSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\n  if (!sequence1.getBoundaryScore || !sequence2.getBoundaryScore) {\n    return sequenceDiffs;\n  }\n  for (let i = 0; i < sequenceDiffs.length; i++) {\n    const prevDiff = i > 0 ? sequenceDiffs[i - 1] : undefined;\n    const diff = sequenceDiffs[i];\n    const nextDiff = i + 1 < sequenceDiffs.length ? sequenceDiffs[i + 1] : undefined;\n    const seq1ValidRange = new OffsetRange(prevDiff ? prevDiff.seq1Range.start + 1 : 0, nextDiff ? nextDiff.seq1Range.endExclusive - 1 : sequence1.length);\n    const seq2ValidRange = new OffsetRange(prevDiff ? prevDiff.seq2Range.start + 1 : 0, nextDiff ? nextDiff.seq2Range.endExclusive - 1 : sequence2.length);\n    if (diff.seq1Range.isEmpty) {\n      sequenceDiffs[i] = shiftDiffToBetterPosition(diff, sequence1, sequence2, seq1ValidRange, seq2ValidRange);\n    } else if (diff.seq2Range.isEmpty) {\n      sequenceDiffs[i] = shiftDiffToBetterPosition(diff.reverse(), sequence2, sequence1, seq2ValidRange, seq1ValidRange).reverse();\n    }\n  }\n  return sequenceDiffs;\n}\nfunction shiftDiffToBetterPosition(diff, sequence1, sequence2, seq1ValidRange, seq2ValidRange) {\n  const maxShiftLimit = 100; // To prevent performance issues\n  // don't touch previous or next!\n  let deltaBefore = 1;\n  while (diff.seq1Range.start - deltaBefore >= seq1ValidRange.start && diff.seq2Range.start - deltaBefore >= seq2ValidRange.start && sequence2.getElement(diff.seq2Range.start - deltaBefore) === sequence2.getElement(diff.seq2Range.endExclusive - deltaBefore) && deltaBefore < maxShiftLimit) {\n    deltaBefore++;\n  }\n  deltaBefore--;\n  let deltaAfter = 0;\n  while (diff.seq1Range.start + deltaAfter < seq1ValidRange.endExclusive && diff.seq2Range.endExclusive + deltaAfter < seq2ValidRange.endExclusive && sequence2.getElement(diff.seq2Range.start + deltaAfter) === sequence2.getElement(diff.seq2Range.endExclusive + deltaAfter) && deltaAfter < maxShiftLimit) {\n    deltaAfter++;\n  }\n  if (deltaBefore === 0 && deltaAfter === 0) {\n    return diff;\n  }\n  // Visualize `[sequence1.text, diff.seq1Range.start + deltaAfter]`\n  // and `[sequence2.text, diff.seq2Range.start + deltaAfter, diff.seq2Range.endExclusive + deltaAfter]`\n  let bestDelta = 0;\n  let bestScore = -1;\n  // find best scored delta\n  for (let delta = -deltaBefore; delta <= deltaAfter; delta++) {\n    const seq2OffsetStart = diff.seq2Range.start + delta;\n    const seq2OffsetEndExclusive = diff.seq2Range.endExclusive + delta;\n    const seq1Offset = diff.seq1Range.start + delta;\n    const score = sequence1.getBoundaryScore(seq1Offset) + sequence2.getBoundaryScore(seq2OffsetStart) + sequence2.getBoundaryScore(seq2OffsetEndExclusive);\n    if (score > bestScore) {\n      bestScore = score;\n      bestDelta = delta;\n    }\n  }\n  return diff.delta(bestDelta);\n}","map":{"version":3,"names":["OffsetRange","SequenceDiff","optimizeSequenceDiffs","sequence1","sequence2","sequenceDiffs","result","joinSequenceDiffs","shiftSequenceDiffs","smoothenSequenceDiffs","s","last","length","push","seq1Range","start","endExclusive","seq2Range","join","removeRandomMatches","diffs","counter","shouldRepeat","i","cur","lastResult","shouldJoinDiffs","before","after","unchangedRange","unchangedLineCount","countLinesIn","unchangedText","getText","trim","split","beforeLineCount1","beforeSeq1Length","beforeLineCount2","beforeSeq2Length","afterLineCount1","afterSeq1Length","afterLineCount2","afterSeq2Length","max","cap","v","Math","min","pow","shouldJoin","prevResult","isEmpty","d","getElement","delta","result2","nextResult","getBoundaryScore","prevDiff","undefined","diff","nextDiff","seq1ValidRange","seq2ValidRange","shiftDiffToBetterPosition","reverse","maxShiftLimit","deltaBefore","deltaAfter","bestDelta","bestScore","seq2OffsetStart","seq2OffsetEndExclusive","seq1Offset","score"],"sources":["D:/code/java/program/oj/code/yuoj-frontend-master/node_modules/monaco-editor/esm/vs/editor/common/diff/algorithms/joinSequenceDiffs.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { OffsetRange } from '../../core/offsetRange.js';\nimport { SequenceDiff } from './diffAlgorithm.js';\nexport function optimizeSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\n    let result = sequenceDiffs;\n    result = joinSequenceDiffs(sequence1, sequence2, result);\n    result = shiftSequenceDiffs(sequence1, sequence2, result);\n    return result;\n}\nexport function smoothenSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\n    const result = [];\n    for (const s of sequenceDiffs) {\n        const last = result[result.length - 1];\n        if (!last) {\n            result.push(s);\n            continue;\n        }\n        if (s.seq1Range.start - last.seq1Range.endExclusive <= 2 || s.seq2Range.start - last.seq2Range.endExclusive <= 2) {\n            result[result.length - 1] = new SequenceDiff(last.seq1Range.join(s.seq1Range), last.seq2Range.join(s.seq2Range));\n        }\n        else {\n            result.push(s);\n        }\n    }\n    return result;\n}\nexport function removeRandomMatches(sequence1, sequence2, sequenceDiffs) {\n    let diffs = sequenceDiffs;\n    if (diffs.length === 0) {\n        return diffs;\n    }\n    let counter = 0;\n    let shouldRepeat;\n    do {\n        shouldRepeat = false;\n        const result = [\n            diffs[0]\n        ];\n        for (let i = 1; i < diffs.length; i++) {\n            const cur = diffs[i];\n            const lastResult = result[result.length - 1];\n            function shouldJoinDiffs(before, after) {\n                const unchangedRange = new OffsetRange(lastResult.seq1Range.endExclusive, cur.seq1Range.start);\n                const unchangedLineCount = sequence1.countLinesIn(unchangedRange);\n                if (unchangedLineCount > 5 || unchangedRange.length > 500) {\n                    return false;\n                }\n                const unchangedText = sequence1.getText(unchangedRange).trim();\n                if (unchangedText.length > 20 || unchangedText.split(/\\r\\n|\\r|\\n/).length > 1) {\n                    return false;\n                }\n                const beforeLineCount1 = sequence1.countLinesIn(before.seq1Range);\n                const beforeSeq1Length = before.seq1Range.length;\n                const beforeLineCount2 = sequence2.countLinesIn(before.seq2Range);\n                const beforeSeq2Length = before.seq2Range.length;\n                const afterLineCount1 = sequence1.countLinesIn(after.seq1Range);\n                const afterSeq1Length = after.seq1Range.length;\n                const afterLineCount2 = sequence2.countLinesIn(after.seq2Range);\n                const afterSeq2Length = after.seq2Range.length;\n                // TODO: Maybe a neural net can be used to derive the result from these numbers\n                const max = 2 * 40 + 50;\n                function cap(v) {\n                    return Math.min(v, max);\n                }\n                if (Math.pow(Math.pow(cap(beforeLineCount1 * 40 + beforeSeq1Length), 1.5) + Math.pow(cap(beforeLineCount2 * 40 + beforeSeq2Length), 1.5), 1.5)\n                    + Math.pow(Math.pow(cap(afterLineCount1 * 40 + afterSeq1Length), 1.5) + Math.pow(cap(afterLineCount2 * 40 + afterSeq2Length), 1.5), 1.5) > (Math.pow((Math.pow(max, 1.5)), 1.5)) * 1.3) {\n                    return true;\n                }\n                return false;\n            }\n            const shouldJoin = shouldJoinDiffs(lastResult, cur);\n            if (shouldJoin) {\n                shouldRepeat = true;\n                result[result.length - 1] = result[result.length - 1].join(cur);\n            }\n            else {\n                result.push(cur);\n            }\n        }\n        diffs = result;\n    } while (counter++ < 10 && shouldRepeat);\n    return diffs;\n}\n/**\n * This function fixes issues like this:\n * ```\n * import { Baz, Bar } from \"foo\";\n * ```\n * <->\n * ```\n * import { Baz, Bar, Foo } from \"foo\";\n * ```\n * Computed diff: [ {Add \",\" after Bar}, {Add \"Foo \" after space} }\n * Improved diff: [{Add \", Foo\" after Bar}]\n */\nexport function joinSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\n    if (sequenceDiffs.length === 0) {\n        return sequenceDiffs;\n    }\n    const result = [];\n    result.push(sequenceDiffs[0]);\n    // First move them all to the left as much as possible and join them if possible\n    for (let i = 1; i < sequenceDiffs.length; i++) {\n        const prevResult = result[result.length - 1];\n        let cur = sequenceDiffs[i];\n        if (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {\n            const length = cur.seq1Range.start - prevResult.seq1Range.endExclusive;\n            let d;\n            for (d = 1; d <= length; d++) {\n                if (sequence1.getElement(cur.seq1Range.start - d) !== sequence1.getElement(cur.seq1Range.endExclusive - d) ||\n                    sequence2.getElement(cur.seq2Range.start - d) !== sequence2.getElement(cur.seq2Range.endExclusive - d)) {\n                    break;\n                }\n            }\n            d--;\n            if (d === length) {\n                // Merge previous and current diff\n                result[result.length - 1] = new SequenceDiff(new OffsetRange(prevResult.seq1Range.start, cur.seq1Range.endExclusive - length), new OffsetRange(prevResult.seq2Range.start, cur.seq2Range.endExclusive - length));\n                continue;\n            }\n            cur = cur.delta(-d);\n        }\n        result.push(cur);\n    }\n    const result2 = [];\n    // Then move them all to the right and join them again if possible\n    for (let i = 0; i < result.length - 1; i++) {\n        const nextResult = result[i + 1];\n        let cur = result[i];\n        if (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {\n            const length = nextResult.seq1Range.start - cur.seq1Range.endExclusive;\n            let d;\n            for (d = 0; d < length; d++) {\n                if (sequence1.getElement(cur.seq1Range.start + d) !== sequence1.getElement(cur.seq1Range.endExclusive + d) ||\n                    sequence2.getElement(cur.seq2Range.start + d) !== sequence2.getElement(cur.seq2Range.endExclusive + d)) {\n                    break;\n                }\n            }\n            if (d === length) {\n                // Merge previous and current diff, write to result!\n                result[i + 1] = new SequenceDiff(new OffsetRange(cur.seq1Range.start + length, nextResult.seq1Range.endExclusive), new OffsetRange(cur.seq2Range.start + length, nextResult.seq2Range.endExclusive));\n                continue;\n            }\n            if (d > 0) {\n                cur = cur.delta(d);\n            }\n        }\n        result2.push(cur);\n    }\n    if (result.length > 0) {\n        result2.push(result[result.length - 1]);\n    }\n    return result2;\n}\n// align character level diffs at whitespace characters\n// import { IBar } from \"foo\";\n// import { I[Arr, I]Bar } from \"foo\";\n// ->\n// import { [IArr, ]IBar } from \"foo\";\n// import { ITransaction, observableValue, transaction } from 'vs/base/common/observable';\n// import { ITransaction, observable[FromEvent, observable]Value, transaction } from 'vs/base/common/observable';\n// ->\n// import { ITransaction, [observableFromEvent, ]observableValue, transaction } from 'vs/base/common/observable';\n// collectBrackets(level + 1, levelPerBracketType);\n// collectBrackets(level + 1, levelPerBracket[ + 1, levelPerBracket]Type);\n// ->\n// collectBrackets(level + 1, [levelPerBracket + 1, ]levelPerBracketType);\nexport function shiftSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\n    if (!sequence1.getBoundaryScore || !sequence2.getBoundaryScore) {\n        return sequenceDiffs;\n    }\n    for (let i = 0; i < sequenceDiffs.length; i++) {\n        const prevDiff = (i > 0 ? sequenceDiffs[i - 1] : undefined);\n        const diff = sequenceDiffs[i];\n        const nextDiff = (i + 1 < sequenceDiffs.length ? sequenceDiffs[i + 1] : undefined);\n        const seq1ValidRange = new OffsetRange(prevDiff ? prevDiff.seq1Range.start + 1 : 0, nextDiff ? nextDiff.seq1Range.endExclusive - 1 : sequence1.length);\n        const seq2ValidRange = new OffsetRange(prevDiff ? prevDiff.seq2Range.start + 1 : 0, nextDiff ? nextDiff.seq2Range.endExclusive - 1 : sequence2.length);\n        if (diff.seq1Range.isEmpty) {\n            sequenceDiffs[i] = shiftDiffToBetterPosition(diff, sequence1, sequence2, seq1ValidRange, seq2ValidRange);\n        }\n        else if (diff.seq2Range.isEmpty) {\n            sequenceDiffs[i] = shiftDiffToBetterPosition(diff.reverse(), sequence2, sequence1, seq2ValidRange, seq1ValidRange).reverse();\n        }\n    }\n    return sequenceDiffs;\n}\nfunction shiftDiffToBetterPosition(diff, sequence1, sequence2, seq1ValidRange, seq2ValidRange) {\n    const maxShiftLimit = 100; // To prevent performance issues\n    // don't touch previous or next!\n    let deltaBefore = 1;\n    while (diff.seq1Range.start - deltaBefore >= seq1ValidRange.start &&\n        diff.seq2Range.start - deltaBefore >= seq2ValidRange.start &&\n        sequence2.getElement(diff.seq2Range.start - deltaBefore) ===\n            sequence2.getElement(diff.seq2Range.endExclusive - deltaBefore) && deltaBefore < maxShiftLimit) {\n        deltaBefore++;\n    }\n    deltaBefore--;\n    let deltaAfter = 0;\n    while (diff.seq1Range.start + deltaAfter < seq1ValidRange.endExclusive &&\n        diff.seq2Range.endExclusive + deltaAfter < seq2ValidRange.endExclusive &&\n        sequence2.getElement(diff.seq2Range.start + deltaAfter) ===\n            sequence2.getElement(diff.seq2Range.endExclusive + deltaAfter) && deltaAfter < maxShiftLimit) {\n        deltaAfter++;\n    }\n    if (deltaBefore === 0 && deltaAfter === 0) {\n        return diff;\n    }\n    // Visualize `[sequence1.text, diff.seq1Range.start + deltaAfter]`\n    // and `[sequence2.text, diff.seq2Range.start + deltaAfter, diff.seq2Range.endExclusive + deltaAfter]`\n    let bestDelta = 0;\n    let bestScore = -1;\n    // find best scored delta\n    for (let delta = -deltaBefore; delta <= deltaAfter; delta++) {\n        const seq2OffsetStart = diff.seq2Range.start + delta;\n        const seq2OffsetEndExclusive = diff.seq2Range.endExclusive + delta;\n        const seq1Offset = diff.seq1Range.start + delta;\n        const score = sequence1.getBoundaryScore(seq1Offset) + sequence2.getBoundaryScore(seq2OffsetStart) + sequence2.getBoundaryScore(seq2OffsetEndExclusive);\n        if (score > bestScore) {\n            bestScore = score;\n            bestDelta = delta;\n        }\n    }\n    return diff.delta(bestDelta);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
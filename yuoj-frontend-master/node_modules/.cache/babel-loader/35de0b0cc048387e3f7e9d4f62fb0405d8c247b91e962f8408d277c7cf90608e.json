{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { makeInner } from '../../util/model.js';\nimport { assert, each, extend, find, map } from 'zrender/lib/core/util.js';\nimport { getScaleBreakHelper } from '../../scale/break.js';\nimport { subPixelOptimizeLine } from 'zrender/lib/graphic/helper/subPixelOptimize.js';\nimport { applyTransform } from 'zrender/lib/core/vector.js';\nimport * as matrixUtil from 'zrender/lib/core/matrix.js';\nimport { AXIS_BREAK_COLLAPSE_ACTION_TYPE, AXIS_BREAK_EXPAND_ACTION_TYPE, AXIS_BREAK_TOGGLE_ACTION_TYPE } from './axisAction.js';\nimport { labelIntersect, labelLayoutApplyTranslation } from '../../label/labelLayoutHelper.js';\nimport { registerAxisBreakHelperImpl } from './axisBreakHelper.js';\nimport { warn } from '../../util/log.js';\nimport { Group, Line, Point, Polygon, Polyline, WH, XY } from '../../util/graphic.js';\n/**\n * @caution\n *  Must not export anything except `installAxisBreakHelper`\n */\n/**\n * The zigzag shapes for axis breaks are generated according to some random\n * factors. It should persist as much as possible to avoid constantly\n * changing by every user operation.\n */\nvar viewCache = makeInner();\nfunction ensureVisualInCache(visualList, targetBreak) {\n  var visual = find(visualList, function (item) {\n    return getScaleBreakHelper().identifyAxisBreak(item.parsedBreak.breakOption, targetBreak.breakOption);\n  });\n  if (!visual) {\n    visualList.push(visual = {\n      zigzagRandomList: [],\n      parsedBreak: targetBreak,\n      shouldRemove: false\n    });\n  }\n  return visual;\n}\nfunction resetCacheVisualRemoveFlag(visualList) {\n  each(visualList, function (item) {\n    return item.shouldRemove = true;\n  });\n}\nfunction removeUnusedCacheVisual(visualList) {\n  for (var i = visualList.length - 1; i >= 0; i--) {\n    if (visualList[i].shouldRemove) {\n      visualList.splice(i, 1);\n    }\n  }\n}\nfunction rectCoordBuildBreakAxis(axisGroup, axisView, axisModel, coordSysRect, api) {\n  var axis = axisModel.axis;\n  if (axis.scale.isBlank() || !getScaleBreakHelper()) {\n    return;\n  }\n  var breakPairs = getScaleBreakHelper().retrieveAxisBreakPairs(axis.scale.getTicks({\n    breakTicks: 'only_break'\n  }), function (tick) {\n    return tick[\"break\"];\n  }, false);\n  if (!breakPairs.length) {\n    return;\n  }\n  var breakAreaModel = axisModel.getModel('breakArea');\n  var zigzagAmplitude = breakAreaModel.get('zigzagAmplitude');\n  var zigzagMinSpan = breakAreaModel.get('zigzagMinSpan');\n  var zigzagMaxSpan = breakAreaModel.get('zigzagMaxSpan');\n  // Use arbitrary value to avoid dead loop if user gives inappropriate settings.\n  zigzagMinSpan = Math.max(2, zigzagMinSpan || 0);\n  zigzagMaxSpan = Math.max(zigzagMinSpan, zigzagMaxSpan || 0);\n  var expandOnClick = breakAreaModel.get('expandOnClick');\n  var zigzagZ = breakAreaModel.get('zigzagZ');\n  var itemStyleModel = breakAreaModel.getModel('itemStyle');\n  var itemStyle = itemStyleModel.getItemStyle();\n  var borderColor = itemStyle.stroke;\n  var borderWidth = itemStyle.lineWidth;\n  var borderType = itemStyle.lineDash;\n  var color = itemStyle.fill;\n  var group = new Group({\n    ignoreModelZ: true\n  });\n  var isAxisHorizontal = axis.isHorizontal();\n  var cachedVisualList = viewCache(axisView).visualList || (viewCache(axisView).visualList = []);\n  resetCacheVisualRemoveFlag(cachedVisualList);\n  var _loop_1 = function (i) {\n    var parsedBreak = breakPairs[i][0][\"break\"].parsedBreak;\n    // Even if brk.gap is 0, we should also draw the breakArea because\n    // border is sometimes required to be visible (as a line)\n    var coords = [];\n    coords[0] = axis.toGlobalCoord(axis.dataToCoord(parsedBreak.vmin, true));\n    coords[1] = axis.toGlobalCoord(axis.dataToCoord(parsedBreak.vmax, true));\n    if (coords[1] < coords[0]) {\n      coords.reverse();\n    }\n    var cachedVisual = ensureVisualInCache(cachedVisualList, parsedBreak);\n    cachedVisual.shouldRemove = false;\n    var breakGroup = new Group();\n    addZigzagShapes(cachedVisual.zigzagRandomList, breakGroup, coords[0], coords[1], isAxisHorizontal, parsedBreak);\n    if (expandOnClick) {\n      breakGroup.on('click', function () {\n        var payload = {\n          type: AXIS_BREAK_EXPAND_ACTION_TYPE,\n          breaks: [{\n            start: parsedBreak.breakOption.start,\n            end: parsedBreak.breakOption.end\n          }]\n        };\n        payload[axis.dim + \"AxisIndex\"] = axisModel.componentIndex;\n        api.dispatchAction(payload);\n      });\n    }\n    breakGroup.silent = !expandOnClick;\n    group.add(breakGroup);\n  };\n  for (var i = 0; i < breakPairs.length; i++) {\n    _loop_1(i);\n  }\n  axisGroup.add(group);\n  removeUnusedCacheVisual(cachedVisualList);\n  function addZigzagShapes(zigzagRandomList, breakGroup, startCoord, endCoord, isAxisHorizontal, trimmedBreak) {\n    var polylineStyle = {\n      stroke: borderColor,\n      lineWidth: borderWidth,\n      lineDash: borderType,\n      fill: 'none'\n    };\n    var dimBrk = isAxisHorizontal ? 0 : 1;\n    var dimZigzag = 1 - dimBrk;\n    var zigzagCoordMax = coordSysRect[XY[dimZigzag]] + coordSysRect[WH[dimZigzag]];\n    // Apply `subPixelOptimizeLine` for alignning with break ticks.\n    function subPixelOpt(brkCoord) {\n      var pBrk = [];\n      var dummyP = [];\n      pBrk[dimBrk] = dummyP[dimBrk] = brkCoord;\n      pBrk[dimZigzag] = coordSysRect[XY[dimZigzag]];\n      dummyP[dimZigzag] = zigzagCoordMax;\n      var dummyShape = {\n        x1: pBrk[0],\n        y1: pBrk[1],\n        x2: dummyP[0],\n        y2: dummyP[1]\n      };\n      subPixelOptimizeLine(dummyShape, dummyShape, {\n        lineWidth: 1\n      });\n      pBrk[0] = dummyShape.x1;\n      pBrk[1] = dummyShape.y1;\n      return pBrk[dimBrk];\n    }\n    startCoord = subPixelOpt(startCoord);\n    endCoord = subPixelOpt(endCoord);\n    var pointsA = [];\n    var pointsB = [];\n    var isSwap = true;\n    var current = coordSysRect[XY[dimZigzag]];\n    for (var idx = 0;; idx++) {\n      // Use `isFirstPoint` `isLastPoint` to ensure the intersections between zigzag\n      // and axis are precise, thus it can join its axis tick correctly.\n      var isFirstPoint = current === coordSysRect[XY[dimZigzag]];\n      var isLastPoint = current >= zigzagCoordMax;\n      if (isLastPoint) {\n        current = zigzagCoordMax;\n      }\n      var pA = [];\n      var pB = [];\n      pA[dimBrk] = startCoord;\n      pB[dimBrk] = endCoord;\n      if (!isFirstPoint && !isLastPoint) {\n        pA[dimBrk] += isSwap ? -zigzagAmplitude : zigzagAmplitude;\n        pB[dimBrk] -= !isSwap ? -zigzagAmplitude : zigzagAmplitude;\n      }\n      pA[dimZigzag] = current;\n      pB[dimZigzag] = current;\n      pointsA.push(pA);\n      pointsB.push(pB);\n      var randomVal = void 0;\n      if (idx < zigzagRandomList.length) {\n        randomVal = zigzagRandomList[idx];\n      } else {\n        randomVal = Math.random();\n        zigzagRandomList.push(randomVal);\n      }\n      current += randomVal * (zigzagMaxSpan - zigzagMinSpan) + zigzagMinSpan;\n      isSwap = !isSwap;\n      if (isLastPoint) {\n        break;\n      }\n    }\n    var anidSuffix = getScaleBreakHelper().serializeAxisBreakIdentifier(trimmedBreak.breakOption);\n    // Create two polylines and add them to the breakGroup\n    breakGroup.add(new Polyline({\n      anid: \"break_a_\" + anidSuffix,\n      shape: {\n        points: pointsA\n      },\n      style: polylineStyle,\n      z: zigzagZ\n    }));\n    /* Add the second polyline and a polygon only if the gap is not zero\n     * Otherwise if the polyline is with dashed line or being opaque,\n     * it may not be constant with breaks with non-zero gaps. */\n    if (trimmedBreak.gapReal !== 0) {\n      breakGroup.add(new Polyline({\n        anid: \"break_b_\" + anidSuffix,\n        shape: {\n          // Not reverse to keep the dash stable when dragging resizing.\n          points: pointsB\n        },\n        style: polylineStyle,\n        z: zigzagZ\n      }));\n      // Creating the polygon that fills the area between the polylines\n      // From end to start for polygon.\n      var pointsB2 = pointsB.slice();\n      pointsB2.reverse();\n      var polygonPoints = pointsA.concat(pointsB2);\n      breakGroup.add(new Polygon({\n        anid: \"break_c_\" + anidSuffix,\n        shape: {\n          points: polygonPoints\n        },\n        style: {\n          fill: color,\n          opacity: itemStyle.opacity\n        },\n        z: zigzagZ\n      }));\n    }\n  }\n}\nfunction buildAxisBreakLine(axisModel, group, transformGroup, pathBaseProp) {\n  var axis = axisModel.axis;\n  var transform = transformGroup.transform;\n  assert(pathBaseProp.style);\n  var extent = axis.getExtent();\n  if (axis.inverse) {\n    extent = extent.slice();\n    extent.reverse();\n  }\n  var breakPairs = getScaleBreakHelper().retrieveAxisBreakPairs(axis.scale.getTicks({\n    breakTicks: 'only_break'\n  }), function (tick) {\n    return tick[\"break\"];\n  }, false);\n  var brkLayoutList = map(breakPairs, function (breakPair) {\n    var parsedBreak = breakPair[0][\"break\"].parsedBreak;\n    var coordPair = [axis.dataToCoord(parsedBreak.vmin, true), axis.dataToCoord(parsedBreak.vmax, true)];\n    coordPair[0] > coordPair[1] && coordPair.reverse();\n    return {\n      coordPair: coordPair,\n      brkId: getScaleBreakHelper().serializeAxisBreakIdentifier(parsedBreak.breakOption)\n    };\n  });\n  brkLayoutList.sort(function (layout1, layout2) {\n    return layout1.coordPair[0] - layout2.coordPair[0];\n  });\n  var ySegMin = extent[0];\n  var lastLayout = null;\n  for (var idx = 0; idx < brkLayoutList.length; idx++) {\n    var layout = brkLayoutList[idx];\n    var brkTirmmedMin = Math.max(layout.coordPair[0], extent[0]);\n    var brkTirmmedMax = Math.min(layout.coordPair[1], extent[1]);\n    if (ySegMin <= brkTirmmedMin) {\n      addSeg(ySegMin, brkTirmmedMin, lastLayout, layout);\n    }\n    ySegMin = brkTirmmedMax;\n    lastLayout = layout;\n  }\n  if (ySegMin <= extent[1]) {\n    addSeg(ySegMin, extent[1], lastLayout, null);\n  }\n  function addSeg(min, max, layout1, layout2) {\n    function trans(p1, p2) {\n      if (transform) {\n        applyTransform(p1, p1, transform);\n        applyTransform(p2, p2, transform);\n      }\n    }\n    function subPixelOptimizePP(p1, p2) {\n      var shape = {\n        x1: p1[0],\n        y1: p1[1],\n        x2: p2[0],\n        y2: p2[1]\n      };\n      subPixelOptimizeLine(shape, shape, pathBaseProp.style);\n      p1[0] = shape.x1;\n      p1[1] = shape.y1;\n      p2[0] = shape.x2;\n      p2[1] = shape.y2;\n    }\n    var lineP1 = [min, 0];\n    var lineP2 = [max, 0];\n    // dummy tick is used to align the line segment ends with axis ticks\n    // after `subPixelOptimizeLine` being applied.\n    var dummyTickEnd1 = [min, 5];\n    var dummyTickEnd2 = [max, 5];\n    trans(lineP1, dummyTickEnd1);\n    subPixelOptimizePP(lineP1, dummyTickEnd1);\n    trans(lineP2, dummyTickEnd2);\n    subPixelOptimizePP(lineP2, dummyTickEnd2);\n    // Apply it keeping the same as the normal axis line.\n    subPixelOptimizePP(lineP1, lineP2);\n    var seg = new Line(extend({\n      shape: {\n        x1: lineP1[0],\n        y1: lineP1[1],\n        x2: lineP2[0],\n        y2: lineP2[1]\n      }\n    }, pathBaseProp));\n    group.add(seg);\n    // Animation should be precise to be consistent with tick and split line animation.\n    seg.anid = \"breakLine_\" + (layout1 ? layout1.brkId : '\\0') + \"_\\0_\" + (layout2 ? layout2.brkId : '\\0');\n  }\n}\n/**\n * Resolve the overlap of a pair of labels.\n *\n * [CAUTION] Only label.x/y are allowed to change.\n */\nfunction adjustBreakLabelPair(axisInverse, axisRotation, layoutPair) {\n  if (find(layoutPair, function (item) {\n    return !item;\n  })) {\n    return;\n  }\n  var mtv = new Point();\n  if (!labelIntersect(layoutPair[0], layoutPair[1], mtv, {\n    // Assert `labelPair` is `[break_min, break_max]`.\n    // `axis.inverse: true` means a smaller scale value corresponds to a bigger value in axis.extent.\n    // The axisRotation indicates mtv direction of OBB intersecting.\n    direction: -(axisInverse ? axisRotation + Math.PI : axisRotation),\n    touchThreshold: 0,\n    // If need to resovle intersection align axis by moving labels according to MTV,\n    // the direction must not be opposite, otherwise cause misleading.\n    bidirectional: false\n  })) {\n    return;\n  }\n  // Rotate axis back to (1, 0) direction, to be a standard axis.\n  var axisStTrans = matrixUtil.create();\n  matrixUtil.rotate(axisStTrans, axisStTrans, -axisRotation);\n  var labelPairStTrans = map(layoutPair, function (layout) {\n    return layout.transform ? matrixUtil.mul(matrixUtil.create(), axisStTrans, layout.transform) : axisStTrans;\n  });\n  function isParallelToAxis(whIdx) {\n    // Assert label[0] and label[1] has the same rotation, so only use [0].\n    var localRect = layoutPair[0].localRect;\n    var labelVec0 = new Point(localRect[WH[whIdx]] * labelPairStTrans[0][0], localRect[WH[whIdx]] * labelPairStTrans[0][1]);\n    return Math.abs(labelVec0.y) < 1e-5;\n  }\n  // If overlapping, move pair[0] pair[1] apart a little. We need to calculate a ratio k to\n  // distribute mtv to pair[0] and pair[1]. This is to place the text gap as close as possible\n  // to the center of the break ticks, otherwise it might looks weird or misleading.\n  // - When labels' width/height are not parallel to axis (usually by rotation),\n  //  we can simply treat the k as `0.5`.\n  var k = 0.5;\n  // - When labels' width/height are parallel to axis, the width/height need to be considered,\n  //  since they may differ significantly. In this case we keep textAlign as 'center' rather\n  //  than 'left'/'right', due to considerations of space utilization for wide break.gap.\n  //  A sample case: break on xAxis(no inverse) is [200, 300000].\n  //  We calculate k based on the formula below:\n  //      Rotated axis and labels to the direction of (1, 0).\n  //      uval = ( (pair[0].insidePt - mtv*k) + (pair[1].insidePt + mtv*(1-k)) ) / 2 - brkCenter\n  //      0 <= k <= 1\n  //      |uval| should be as small as possible.\n  //  Derived as follows:\n  //      qval = (pair[0].insidePt + pair[1].insidePt + mtv) / 2 - brkCenter\n  //      k = (qval - uval) / mtv\n  //      min(qval, qval-mtv) <= uval <= max(qval, qval-mtv)\n  if (isParallelToAxis(0) || isParallelToAxis(1)) {\n    var rectSt = map(layoutPair, function (layout, idx) {\n      var rect = layout.localRect.clone();\n      rect.applyTransform(labelPairStTrans[idx]);\n      return rect;\n    });\n    var brkCenterSt = new Point();\n    brkCenterSt.copy(layoutPair[0].label).add(layoutPair[1].label).scale(0.5);\n    brkCenterSt.transform(axisStTrans);\n    var mtvSt = mtv.clone().transform(axisStTrans);\n    var insidePtSum = rectSt[0].x + rectSt[1].x + (mtvSt.x >= 0 ? rectSt[0].width : rectSt[1].width);\n    var qval = (insidePtSum + mtvSt.x) / 2 - brkCenterSt.x;\n    var uvalMin = Math.min(qval, qval - mtvSt.x);\n    var uvalMax = Math.max(qval, qval - mtvSt.x);\n    var uval = uvalMax < 0 ? uvalMax : uvalMin > 0 ? uvalMin : 0;\n    k = (qval - uval) / mtvSt.x;\n  }\n  var delta0 = new Point();\n  var delta1 = new Point();\n  Point.scale(delta0, mtv, -k);\n  Point.scale(delta1, mtv, 1 - k);\n  labelLayoutApplyTranslation(layoutPair[0], delta0);\n  labelLayoutApplyTranslation(layoutPair[1], delta1);\n}\nfunction updateModelAxisBreak(model, payload) {\n  var result = {\n    breaks: []\n  };\n  each(payload.breaks, function (inputBrk) {\n    if (!inputBrk) {\n      return;\n    }\n    var breakOption = find(model.get('breaks', true), function (brkOption) {\n      return getScaleBreakHelper().identifyAxisBreak(brkOption, inputBrk);\n    });\n    if (!breakOption) {\n      if (process.env.NODE_ENV !== 'production') {\n        warn(\"Can not find axis break by start: \" + inputBrk.start + \", end: \" + inputBrk.end);\n      }\n      return;\n    }\n    var actionType = payload.type;\n    var old = {\n      isExpanded: !!breakOption.isExpanded\n    };\n    breakOption.isExpanded = actionType === AXIS_BREAK_EXPAND_ACTION_TYPE ? true : actionType === AXIS_BREAK_COLLAPSE_ACTION_TYPE ? false : actionType === AXIS_BREAK_TOGGLE_ACTION_TYPE ? !breakOption.isExpanded : breakOption.isExpanded;\n    result.breaks.push({\n      start: breakOption.start,\n      end: breakOption.end,\n      isExpanded: !!breakOption.isExpanded,\n      old: old\n    });\n  });\n  return result;\n}\nexport function installAxisBreakHelper() {\n  registerAxisBreakHelperImpl({\n    adjustBreakLabelPair: adjustBreakLabelPair,\n    buildAxisBreakLine: buildAxisBreakLine,\n    rectCoordBuildBreakAxis: rectCoordBuildBreakAxis,\n    updateModelAxisBreak: updateModelAxisBreak\n  });\n}","map":{"version":3,"names":["makeInner","assert","each","extend","find","map","getScaleBreakHelper","subPixelOptimizeLine","applyTransform","matrixUtil","AXIS_BREAK_COLLAPSE_ACTION_TYPE","AXIS_BREAK_EXPAND_ACTION_TYPE","AXIS_BREAK_TOGGLE_ACTION_TYPE","labelIntersect","labelLayoutApplyTranslation","registerAxisBreakHelperImpl","warn","Group","Line","Point","Polygon","Polyline","WH","XY","viewCache","ensureVisualInCache","visualList","targetBreak","visual","item","identifyAxisBreak","parsedBreak","breakOption","push","zigzagRandomList","shouldRemove","resetCacheVisualRemoveFlag","removeUnusedCacheVisual","i","length","splice","rectCoordBuildBreakAxis","axisGroup","axisView","axisModel","coordSysRect","api","axis","scale","isBlank","breakPairs","retrieveAxisBreakPairs","getTicks","breakTicks","tick","breakAreaModel","getModel","zigzagAmplitude","get","zigzagMinSpan","zigzagMaxSpan","Math","max","expandOnClick","zigzagZ","itemStyleModel","itemStyle","getItemStyle","borderColor","stroke","borderWidth","lineWidth","borderType","lineDash","color","fill","group","ignoreModelZ","isAxisHorizontal","isHorizontal","cachedVisualList","_loop_1","coords","toGlobalCoord","dataToCoord","vmin","vmax","reverse","cachedVisual","breakGroup","addZigzagShapes","on","payload","type","breaks","start","end","dim","componentIndex","dispatchAction","silent","add","startCoord","endCoord","trimmedBreak","polylineStyle","dimBrk","dimZigzag","zigzagCoordMax","subPixelOpt","brkCoord","pBrk","dummyP","dummyShape","x1","y1","x2","y2","pointsA","pointsB","isSwap","current","idx","isFirstPoint","isLastPoint","pA","pB","randomVal","random","anidSuffix","serializeAxisBreakIdentifier","anid","shape","points","style","z","gapReal","pointsB2","slice","polygonPoints","concat","opacity","buildAxisBreakLine","transformGroup","pathBaseProp","transform","extent","getExtent","inverse","brkLayoutList","breakPair","coordPair","brkId","sort","layout1","layout2","ySegMin","lastLayout","layout","brkTirmmedMin","brkTirmmedMax","min","addSeg","trans","p1","p2","subPixelOptimizePP","lineP1","lineP2","dummyTickEnd1","dummyTickEnd2","seg","adjustBreakLabelPair","axisInverse","axisRotation","layoutPair","mtv","direction","PI","touchThreshold","bidirectional","axisStTrans","create","rotate","labelPairStTrans","mul","isParallelToAxis","whIdx","localRect","labelVec0","abs","y","k","rectSt","rect","clone","brkCenterSt","copy","label","mtvSt","insidePtSum","x","width","qval","uvalMin","uvalMax","uval","delta0","delta1","updateModelAxisBreak","model","result","inputBrk","brkOption","process","env","NODE_ENV","actionType","old","isExpanded","installAxisBreakHelper"],"sources":["D:/code/java/program/oj/code/yuoj-frontend-master/node_modules/echarts/lib/component/axis/axisBreakHelperImpl.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { makeInner } from '../../util/model.js';\nimport { assert, each, extend, find, map } from 'zrender/lib/core/util.js';\nimport { getScaleBreakHelper } from '../../scale/break.js';\nimport { subPixelOptimizeLine } from 'zrender/lib/graphic/helper/subPixelOptimize.js';\nimport { applyTransform } from 'zrender/lib/core/vector.js';\nimport * as matrixUtil from 'zrender/lib/core/matrix.js';\nimport { AXIS_BREAK_COLLAPSE_ACTION_TYPE, AXIS_BREAK_EXPAND_ACTION_TYPE, AXIS_BREAK_TOGGLE_ACTION_TYPE } from './axisAction.js';\nimport { labelIntersect, labelLayoutApplyTranslation } from '../../label/labelLayoutHelper.js';\nimport { registerAxisBreakHelperImpl } from './axisBreakHelper.js';\nimport { warn } from '../../util/log.js';\nimport { Group, Line, Point, Polygon, Polyline, WH, XY } from '../../util/graphic.js';\n/**\n * @caution\n *  Must not export anything except `installAxisBreakHelper`\n */\n/**\n * The zigzag shapes for axis breaks are generated according to some random\n * factors. It should persist as much as possible to avoid constantly\n * changing by every user operation.\n */\nvar viewCache = makeInner();\nfunction ensureVisualInCache(visualList, targetBreak) {\n  var visual = find(visualList, function (item) {\n    return getScaleBreakHelper().identifyAxisBreak(item.parsedBreak.breakOption, targetBreak.breakOption);\n  });\n  if (!visual) {\n    visualList.push(visual = {\n      zigzagRandomList: [],\n      parsedBreak: targetBreak,\n      shouldRemove: false\n    });\n  }\n  return visual;\n}\nfunction resetCacheVisualRemoveFlag(visualList) {\n  each(visualList, function (item) {\n    return item.shouldRemove = true;\n  });\n}\nfunction removeUnusedCacheVisual(visualList) {\n  for (var i = visualList.length - 1; i >= 0; i--) {\n    if (visualList[i].shouldRemove) {\n      visualList.splice(i, 1);\n    }\n  }\n}\nfunction rectCoordBuildBreakAxis(axisGroup, axisView, axisModel, coordSysRect, api) {\n  var axis = axisModel.axis;\n  if (axis.scale.isBlank() || !getScaleBreakHelper()) {\n    return;\n  }\n  var breakPairs = getScaleBreakHelper().retrieveAxisBreakPairs(axis.scale.getTicks({\n    breakTicks: 'only_break'\n  }), function (tick) {\n    return tick[\"break\"];\n  }, false);\n  if (!breakPairs.length) {\n    return;\n  }\n  var breakAreaModel = axisModel.getModel('breakArea');\n  var zigzagAmplitude = breakAreaModel.get('zigzagAmplitude');\n  var zigzagMinSpan = breakAreaModel.get('zigzagMinSpan');\n  var zigzagMaxSpan = breakAreaModel.get('zigzagMaxSpan');\n  // Use arbitrary value to avoid dead loop if user gives inappropriate settings.\n  zigzagMinSpan = Math.max(2, zigzagMinSpan || 0);\n  zigzagMaxSpan = Math.max(zigzagMinSpan, zigzagMaxSpan || 0);\n  var expandOnClick = breakAreaModel.get('expandOnClick');\n  var zigzagZ = breakAreaModel.get('zigzagZ');\n  var itemStyleModel = breakAreaModel.getModel('itemStyle');\n  var itemStyle = itemStyleModel.getItemStyle();\n  var borderColor = itemStyle.stroke;\n  var borderWidth = itemStyle.lineWidth;\n  var borderType = itemStyle.lineDash;\n  var color = itemStyle.fill;\n  var group = new Group({\n    ignoreModelZ: true\n  });\n  var isAxisHorizontal = axis.isHorizontal();\n  var cachedVisualList = viewCache(axisView).visualList || (viewCache(axisView).visualList = []);\n  resetCacheVisualRemoveFlag(cachedVisualList);\n  var _loop_1 = function (i) {\n    var parsedBreak = breakPairs[i][0][\"break\"].parsedBreak;\n    // Even if brk.gap is 0, we should also draw the breakArea because\n    // border is sometimes required to be visible (as a line)\n    var coords = [];\n    coords[0] = axis.toGlobalCoord(axis.dataToCoord(parsedBreak.vmin, true));\n    coords[1] = axis.toGlobalCoord(axis.dataToCoord(parsedBreak.vmax, true));\n    if (coords[1] < coords[0]) {\n      coords.reverse();\n    }\n    var cachedVisual = ensureVisualInCache(cachedVisualList, parsedBreak);\n    cachedVisual.shouldRemove = false;\n    var breakGroup = new Group();\n    addZigzagShapes(cachedVisual.zigzagRandomList, breakGroup, coords[0], coords[1], isAxisHorizontal, parsedBreak);\n    if (expandOnClick) {\n      breakGroup.on('click', function () {\n        var payload = {\n          type: AXIS_BREAK_EXPAND_ACTION_TYPE,\n          breaks: [{\n            start: parsedBreak.breakOption.start,\n            end: parsedBreak.breakOption.end\n          }]\n        };\n        payload[axis.dim + \"AxisIndex\"] = axisModel.componentIndex;\n        api.dispatchAction(payload);\n      });\n    }\n    breakGroup.silent = !expandOnClick;\n    group.add(breakGroup);\n  };\n  for (var i = 0; i < breakPairs.length; i++) {\n    _loop_1(i);\n  }\n  axisGroup.add(group);\n  removeUnusedCacheVisual(cachedVisualList);\n  function addZigzagShapes(zigzagRandomList, breakGroup, startCoord, endCoord, isAxisHorizontal, trimmedBreak) {\n    var polylineStyle = {\n      stroke: borderColor,\n      lineWidth: borderWidth,\n      lineDash: borderType,\n      fill: 'none'\n    };\n    var dimBrk = isAxisHorizontal ? 0 : 1;\n    var dimZigzag = 1 - dimBrk;\n    var zigzagCoordMax = coordSysRect[XY[dimZigzag]] + coordSysRect[WH[dimZigzag]];\n    // Apply `subPixelOptimizeLine` for alignning with break ticks.\n    function subPixelOpt(brkCoord) {\n      var pBrk = [];\n      var dummyP = [];\n      pBrk[dimBrk] = dummyP[dimBrk] = brkCoord;\n      pBrk[dimZigzag] = coordSysRect[XY[dimZigzag]];\n      dummyP[dimZigzag] = zigzagCoordMax;\n      var dummyShape = {\n        x1: pBrk[0],\n        y1: pBrk[1],\n        x2: dummyP[0],\n        y2: dummyP[1]\n      };\n      subPixelOptimizeLine(dummyShape, dummyShape, {\n        lineWidth: 1\n      });\n      pBrk[0] = dummyShape.x1;\n      pBrk[1] = dummyShape.y1;\n      return pBrk[dimBrk];\n    }\n    startCoord = subPixelOpt(startCoord);\n    endCoord = subPixelOpt(endCoord);\n    var pointsA = [];\n    var pointsB = [];\n    var isSwap = true;\n    var current = coordSysRect[XY[dimZigzag]];\n    for (var idx = 0;; idx++) {\n      // Use `isFirstPoint` `isLastPoint` to ensure the intersections between zigzag\n      // and axis are precise, thus it can join its axis tick correctly.\n      var isFirstPoint = current === coordSysRect[XY[dimZigzag]];\n      var isLastPoint = current >= zigzagCoordMax;\n      if (isLastPoint) {\n        current = zigzagCoordMax;\n      }\n      var pA = [];\n      var pB = [];\n      pA[dimBrk] = startCoord;\n      pB[dimBrk] = endCoord;\n      if (!isFirstPoint && !isLastPoint) {\n        pA[dimBrk] += isSwap ? -zigzagAmplitude : zigzagAmplitude;\n        pB[dimBrk] -= !isSwap ? -zigzagAmplitude : zigzagAmplitude;\n      }\n      pA[dimZigzag] = current;\n      pB[dimZigzag] = current;\n      pointsA.push(pA);\n      pointsB.push(pB);\n      var randomVal = void 0;\n      if (idx < zigzagRandomList.length) {\n        randomVal = zigzagRandomList[idx];\n      } else {\n        randomVal = Math.random();\n        zigzagRandomList.push(randomVal);\n      }\n      current += randomVal * (zigzagMaxSpan - zigzagMinSpan) + zigzagMinSpan;\n      isSwap = !isSwap;\n      if (isLastPoint) {\n        break;\n      }\n    }\n    var anidSuffix = getScaleBreakHelper().serializeAxisBreakIdentifier(trimmedBreak.breakOption);\n    // Create two polylines and add them to the breakGroup\n    breakGroup.add(new Polyline({\n      anid: \"break_a_\" + anidSuffix,\n      shape: {\n        points: pointsA\n      },\n      style: polylineStyle,\n      z: zigzagZ\n    }));\n    /* Add the second polyline and a polygon only if the gap is not zero\n     * Otherwise if the polyline is with dashed line or being opaque,\n     * it may not be constant with breaks with non-zero gaps. */\n    if (trimmedBreak.gapReal !== 0) {\n      breakGroup.add(new Polyline({\n        anid: \"break_b_\" + anidSuffix,\n        shape: {\n          // Not reverse to keep the dash stable when dragging resizing.\n          points: pointsB\n        },\n        style: polylineStyle,\n        z: zigzagZ\n      }));\n      // Creating the polygon that fills the area between the polylines\n      // From end to start for polygon.\n      var pointsB2 = pointsB.slice();\n      pointsB2.reverse();\n      var polygonPoints = pointsA.concat(pointsB2);\n      breakGroup.add(new Polygon({\n        anid: \"break_c_\" + anidSuffix,\n        shape: {\n          points: polygonPoints\n        },\n        style: {\n          fill: color,\n          opacity: itemStyle.opacity\n        },\n        z: zigzagZ\n      }));\n    }\n  }\n}\nfunction buildAxisBreakLine(axisModel, group, transformGroup, pathBaseProp) {\n  var axis = axisModel.axis;\n  var transform = transformGroup.transform;\n  assert(pathBaseProp.style);\n  var extent = axis.getExtent();\n  if (axis.inverse) {\n    extent = extent.slice();\n    extent.reverse();\n  }\n  var breakPairs = getScaleBreakHelper().retrieveAxisBreakPairs(axis.scale.getTicks({\n    breakTicks: 'only_break'\n  }), function (tick) {\n    return tick[\"break\"];\n  }, false);\n  var brkLayoutList = map(breakPairs, function (breakPair) {\n    var parsedBreak = breakPair[0][\"break\"].parsedBreak;\n    var coordPair = [axis.dataToCoord(parsedBreak.vmin, true), axis.dataToCoord(parsedBreak.vmax, true)];\n    coordPair[0] > coordPair[1] && coordPair.reverse();\n    return {\n      coordPair: coordPair,\n      brkId: getScaleBreakHelper().serializeAxisBreakIdentifier(parsedBreak.breakOption)\n    };\n  });\n  brkLayoutList.sort(function (layout1, layout2) {\n    return layout1.coordPair[0] - layout2.coordPair[0];\n  });\n  var ySegMin = extent[0];\n  var lastLayout = null;\n  for (var idx = 0; idx < brkLayoutList.length; idx++) {\n    var layout = brkLayoutList[idx];\n    var brkTirmmedMin = Math.max(layout.coordPair[0], extent[0]);\n    var brkTirmmedMax = Math.min(layout.coordPair[1], extent[1]);\n    if (ySegMin <= brkTirmmedMin) {\n      addSeg(ySegMin, brkTirmmedMin, lastLayout, layout);\n    }\n    ySegMin = brkTirmmedMax;\n    lastLayout = layout;\n  }\n  if (ySegMin <= extent[1]) {\n    addSeg(ySegMin, extent[1], lastLayout, null);\n  }\n  function addSeg(min, max, layout1, layout2) {\n    function trans(p1, p2) {\n      if (transform) {\n        applyTransform(p1, p1, transform);\n        applyTransform(p2, p2, transform);\n      }\n    }\n    function subPixelOptimizePP(p1, p2) {\n      var shape = {\n        x1: p1[0],\n        y1: p1[1],\n        x2: p2[0],\n        y2: p2[1]\n      };\n      subPixelOptimizeLine(shape, shape, pathBaseProp.style);\n      p1[0] = shape.x1;\n      p1[1] = shape.y1;\n      p2[0] = shape.x2;\n      p2[1] = shape.y2;\n    }\n    var lineP1 = [min, 0];\n    var lineP2 = [max, 0];\n    // dummy tick is used to align the line segment ends with axis ticks\n    // after `subPixelOptimizeLine` being applied.\n    var dummyTickEnd1 = [min, 5];\n    var dummyTickEnd2 = [max, 5];\n    trans(lineP1, dummyTickEnd1);\n    subPixelOptimizePP(lineP1, dummyTickEnd1);\n    trans(lineP2, dummyTickEnd2);\n    subPixelOptimizePP(lineP2, dummyTickEnd2);\n    // Apply it keeping the same as the normal axis line.\n    subPixelOptimizePP(lineP1, lineP2);\n    var seg = new Line(extend({\n      shape: {\n        x1: lineP1[0],\n        y1: lineP1[1],\n        x2: lineP2[0],\n        y2: lineP2[1]\n      }\n    }, pathBaseProp));\n    group.add(seg);\n    // Animation should be precise to be consistent with tick and split line animation.\n    seg.anid = \"breakLine_\" + (layout1 ? layout1.brkId : '\\0') + \"_\\0_\" + (layout2 ? layout2.brkId : '\\0');\n  }\n}\n/**\n * Resolve the overlap of a pair of labels.\n *\n * [CAUTION] Only label.x/y are allowed to change.\n */\nfunction adjustBreakLabelPair(axisInverse, axisRotation, layoutPair) {\n  if (find(layoutPair, function (item) {\n    return !item;\n  })) {\n    return;\n  }\n  var mtv = new Point();\n  if (!labelIntersect(layoutPair[0], layoutPair[1], mtv, {\n    // Assert `labelPair` is `[break_min, break_max]`.\n    // `axis.inverse: true` means a smaller scale value corresponds to a bigger value in axis.extent.\n    // The axisRotation indicates mtv direction of OBB intersecting.\n    direction: -(axisInverse ? axisRotation + Math.PI : axisRotation),\n    touchThreshold: 0,\n    // If need to resovle intersection align axis by moving labels according to MTV,\n    // the direction must not be opposite, otherwise cause misleading.\n    bidirectional: false\n  })) {\n    return;\n  }\n  // Rotate axis back to (1, 0) direction, to be a standard axis.\n  var axisStTrans = matrixUtil.create();\n  matrixUtil.rotate(axisStTrans, axisStTrans, -axisRotation);\n  var labelPairStTrans = map(layoutPair, function (layout) {\n    return layout.transform ? matrixUtil.mul(matrixUtil.create(), axisStTrans, layout.transform) : axisStTrans;\n  });\n  function isParallelToAxis(whIdx) {\n    // Assert label[0] and label[1] has the same rotation, so only use [0].\n    var localRect = layoutPair[0].localRect;\n    var labelVec0 = new Point(localRect[WH[whIdx]] * labelPairStTrans[0][0], localRect[WH[whIdx]] * labelPairStTrans[0][1]);\n    return Math.abs(labelVec0.y) < 1e-5;\n  }\n  // If overlapping, move pair[0] pair[1] apart a little. We need to calculate a ratio k to\n  // distribute mtv to pair[0] and pair[1]. This is to place the text gap as close as possible\n  // to the center of the break ticks, otherwise it might looks weird or misleading.\n  // - When labels' width/height are not parallel to axis (usually by rotation),\n  //  we can simply treat the k as `0.5`.\n  var k = 0.5;\n  // - When labels' width/height are parallel to axis, the width/height need to be considered,\n  //  since they may differ significantly. In this case we keep textAlign as 'center' rather\n  //  than 'left'/'right', due to considerations of space utilization for wide break.gap.\n  //  A sample case: break on xAxis(no inverse) is [200, 300000].\n  //  We calculate k based on the formula below:\n  //      Rotated axis and labels to the direction of (1, 0).\n  //      uval = ( (pair[0].insidePt - mtv*k) + (pair[1].insidePt + mtv*(1-k)) ) / 2 - brkCenter\n  //      0 <= k <= 1\n  //      |uval| should be as small as possible.\n  //  Derived as follows:\n  //      qval = (pair[0].insidePt + pair[1].insidePt + mtv) / 2 - brkCenter\n  //      k = (qval - uval) / mtv\n  //      min(qval, qval-mtv) <= uval <= max(qval, qval-mtv)\n  if (isParallelToAxis(0) || isParallelToAxis(1)) {\n    var rectSt = map(layoutPair, function (layout, idx) {\n      var rect = layout.localRect.clone();\n      rect.applyTransform(labelPairStTrans[idx]);\n      return rect;\n    });\n    var brkCenterSt = new Point();\n    brkCenterSt.copy(layoutPair[0].label).add(layoutPair[1].label).scale(0.5);\n    brkCenterSt.transform(axisStTrans);\n    var mtvSt = mtv.clone().transform(axisStTrans);\n    var insidePtSum = rectSt[0].x + rectSt[1].x + (mtvSt.x >= 0 ? rectSt[0].width : rectSt[1].width);\n    var qval = (insidePtSum + mtvSt.x) / 2 - brkCenterSt.x;\n    var uvalMin = Math.min(qval, qval - mtvSt.x);\n    var uvalMax = Math.max(qval, qval - mtvSt.x);\n    var uval = uvalMax < 0 ? uvalMax : uvalMin > 0 ? uvalMin : 0;\n    k = (qval - uval) / mtvSt.x;\n  }\n  var delta0 = new Point();\n  var delta1 = new Point();\n  Point.scale(delta0, mtv, -k);\n  Point.scale(delta1, mtv, 1 - k);\n  labelLayoutApplyTranslation(layoutPair[0], delta0);\n  labelLayoutApplyTranslation(layoutPair[1], delta1);\n}\nfunction updateModelAxisBreak(model, payload) {\n  var result = {\n    breaks: []\n  };\n  each(payload.breaks, function (inputBrk) {\n    if (!inputBrk) {\n      return;\n    }\n    var breakOption = find(model.get('breaks', true), function (brkOption) {\n      return getScaleBreakHelper().identifyAxisBreak(brkOption, inputBrk);\n    });\n    if (!breakOption) {\n      if (process.env.NODE_ENV !== 'production') {\n        warn(\"Can not find axis break by start: \" + inputBrk.start + \", end: \" + inputBrk.end);\n      }\n      return;\n    }\n    var actionType = payload.type;\n    var old = {\n      isExpanded: !!breakOption.isExpanded\n    };\n    breakOption.isExpanded = actionType === AXIS_BREAK_EXPAND_ACTION_TYPE ? true : actionType === AXIS_BREAK_COLLAPSE_ACTION_TYPE ? false : actionType === AXIS_BREAK_TOGGLE_ACTION_TYPE ? !breakOption.isExpanded : breakOption.isExpanded;\n    result.breaks.push({\n      start: breakOption.start,\n      end: breakOption.end,\n      isExpanded: !!breakOption.isExpanded,\n      old: old\n    });\n  });\n  return result;\n}\nexport function installAxisBreakHelper() {\n  registerAxisBreakHelperImpl({\n    adjustBreakLabelPair: adjustBreakLabelPair,\n    buildAxisBreakLine: buildAxisBreakLine,\n    rectCoordBuildBreakAxis: rectCoordBuildBreakAxis,\n    updateModelAxisBreak: updateModelAxisBreak\n  });\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
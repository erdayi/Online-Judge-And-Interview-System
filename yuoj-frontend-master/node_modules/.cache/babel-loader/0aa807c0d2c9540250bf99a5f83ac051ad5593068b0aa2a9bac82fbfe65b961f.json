{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { BugIndicatingError } from '../../../base/common/errors.js';\n/**\n * A range of offsets (0-based).\n*/\nexport class OffsetRange {\n  static addRange(range, sortedRanges) {\n    let i = 0;\n    while (i < sortedRanges.length && sortedRanges[i].endExclusive < range.start) {\n      i++;\n    }\n    let j = i;\n    while (j < sortedRanges.length && sortedRanges[j].start <= range.endExclusive) {\n      j++;\n    }\n    if (i === j) {\n      sortedRanges.splice(i, 0, range);\n    } else {\n      const start = Math.min(range.start, sortedRanges[i].start);\n      const end = Math.max(range.endExclusive, sortedRanges[j - 1].endExclusive);\n      sortedRanges.splice(i, j - i, new OffsetRange(start, end));\n    }\n  }\n  static tryCreate(start, endExclusive) {\n    if (start > endExclusive) {\n      return undefined;\n    }\n    return new OffsetRange(start, endExclusive);\n  }\n  constructor(start, endExclusive) {\n    this.start = start;\n    this.endExclusive = endExclusive;\n    if (start > endExclusive) {\n      throw new BugIndicatingError(`Invalid range: ${this.toString()}`);\n    }\n  }\n  get isEmpty() {\n    return this.start === this.endExclusive;\n  }\n  delta(offset) {\n    return new OffsetRange(this.start + offset, this.endExclusive + offset);\n  }\n  get length() {\n    return this.endExclusive - this.start;\n  }\n  toString() {\n    return `[${this.start}, ${this.endExclusive})`;\n  }\n  equals(other) {\n    return this.start === other.start && this.endExclusive === other.endExclusive;\n  }\n  containsRange(other) {\n    return this.start <= other.start && other.endExclusive <= this.endExclusive;\n  }\n  contains(offset) {\n    return this.start <= offset && offset < this.endExclusive;\n  }\n  /**\n   * for all numbers n: range1.contains(n) or range2.contains(n) => range1.join(range2).contains(n)\n   * The joined range is the smallest range that contains both ranges.\n   */\n  join(other) {\n    return new OffsetRange(Math.min(this.start, other.start), Math.max(this.endExclusive, other.endExclusive));\n  }\n  /**\n   * for all numbers n: range1.contains(n) and range2.contains(n) <=> range1.intersect(range2).contains(n)\n   *\n   * The resulting range is empty if the ranges do not intersect, but touch.\n   * If the ranges don't even touch, the result is undefined.\n   */\n  intersect(other) {\n    const start = Math.max(this.start, other.start);\n    const end = Math.min(this.endExclusive, other.endExclusive);\n    if (start <= end) {\n      return new OffsetRange(start, end);\n    }\n    return undefined;\n  }\n}","map":{"version":3,"names":["BugIndicatingError","OffsetRange","addRange","range","sortedRanges","i","length","endExclusive","start","j","splice","Math","min","end","max","tryCreate","undefined","constructor","toString","isEmpty","delta","offset","equals","other","containsRange","contains","join","intersect"],"sources":["D:/code/java/program/oj/code/yuoj-frontend-master/node_modules/monaco-editor/esm/vs/editor/common/core/offsetRange.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { BugIndicatingError } from '../../../base/common/errors.js';\n/**\n * A range of offsets (0-based).\n*/\nexport class OffsetRange {\n    static addRange(range, sortedRanges) {\n        let i = 0;\n        while (i < sortedRanges.length && sortedRanges[i].endExclusive < range.start) {\n            i++;\n        }\n        let j = i;\n        while (j < sortedRanges.length && sortedRanges[j].start <= range.endExclusive) {\n            j++;\n        }\n        if (i === j) {\n            sortedRanges.splice(i, 0, range);\n        }\n        else {\n            const start = Math.min(range.start, sortedRanges[i].start);\n            const end = Math.max(range.endExclusive, sortedRanges[j - 1].endExclusive);\n            sortedRanges.splice(i, j - i, new OffsetRange(start, end));\n        }\n    }\n    static tryCreate(start, endExclusive) {\n        if (start > endExclusive) {\n            return undefined;\n        }\n        return new OffsetRange(start, endExclusive);\n    }\n    constructor(start, endExclusive) {\n        this.start = start;\n        this.endExclusive = endExclusive;\n        if (start > endExclusive) {\n            throw new BugIndicatingError(`Invalid range: ${this.toString()}`);\n        }\n    }\n    get isEmpty() {\n        return this.start === this.endExclusive;\n    }\n    delta(offset) {\n        return new OffsetRange(this.start + offset, this.endExclusive + offset);\n    }\n    get length() {\n        return this.endExclusive - this.start;\n    }\n    toString() {\n        return `[${this.start}, ${this.endExclusive})`;\n    }\n    equals(other) {\n        return this.start === other.start && this.endExclusive === other.endExclusive;\n    }\n    containsRange(other) {\n        return this.start <= other.start && other.endExclusive <= this.endExclusive;\n    }\n    contains(offset) {\n        return this.start <= offset && offset < this.endExclusive;\n    }\n    /**\n     * for all numbers n: range1.contains(n) or range2.contains(n) => range1.join(range2).contains(n)\n     * The joined range is the smallest range that contains both ranges.\n     */\n    join(other) {\n        return new OffsetRange(Math.min(this.start, other.start), Math.max(this.endExclusive, other.endExclusive));\n    }\n    /**\n     * for all numbers n: range1.contains(n) and range2.contains(n) <=> range1.intersect(range2).contains(n)\n     *\n     * The resulting range is empty if the ranges do not intersect, but touch.\n     * If the ranges don't even touch, the result is undefined.\n     */\n    intersect(other) {\n        const start = Math.max(this.start, other.start);\n        const end = Math.min(this.endExclusive, other.endExclusive);\n        if (start <= end) {\n            return new OffsetRange(start, end);\n        }\n        return undefined;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
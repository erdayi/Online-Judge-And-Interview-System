{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { onUnexpectedError } from './errors.js';\nimport { once as onceFn } from './functional.js';\nimport { combinedDisposable, Disposable, DisposableStore, toDisposable } from './lifecycle.js';\nimport { LinkedList } from './linkedList.js';\nimport { StopWatch } from './stopwatch.js';\n// -----------------------------------------------------------------------------------------------------------------------\n// Uncomment the next line to print warnings whenever an emitter with listeners is disposed. That is a sign of code smell.\n// -----------------------------------------------------------------------------------------------------------------------\nconst _enableDisposeWithListenerWarning = false;\n// _enableDisposeWithListenerWarning = Boolean(\"TRUE\"); // causes a linter warning so that it cannot be pushed\n// -----------------------------------------------------------------------------------------------------------------------\n// Uncomment the next line to print warnings whenever a snapshotted event is used repeatedly without cleanup.\n// See https://github.com/microsoft/vscode/issues/142851\n// -----------------------------------------------------------------------------------------------------------------------\nconst _enableSnapshotPotentialLeakWarning = false;\nexport var Event;\n(function (Event) {\n  Event.None = () => Disposable.None;\n  function _addLeakageTraceLogic(options) {\n    if (_enableSnapshotPotentialLeakWarning) {\n      const {\n        onDidAddListener: origListenerDidAdd\n      } = options;\n      const stack = Stacktrace.create();\n      let count = 0;\n      options.onDidAddListener = () => {\n        if (++count === 2) {\n          console.warn('snapshotted emitter LIKELY used public and SHOULD HAVE BEEN created with DisposableStore. snapshotted here');\n          stack.print();\n        }\n        origListenerDidAdd === null || origListenerDidAdd === void 0 ? void 0 : origListenerDidAdd();\n      };\n    }\n  }\n  /**\n   * Given an event, returns another event which debounces calls and defers the listeners to a later task via a shared\n   * `setTimeout`. The event is converted into a signal (`Event<void>`) to avoid additional object creation as a\n   * result of merging events and to try prevent race conditions that could arise when using related deferred and\n   * non-deferred events.\n   *\n   * This is useful for deferring non-critical work (eg. general UI updates) to ensure it does not block critical work\n   * (eg. latency of keypress to text rendered).\n   *\n   * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n   * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n   * returned event causes this utility to leak a listener on the original event.\n   *\n   * @param event The event source for the new event.\n   * @param disposable A disposable store to add the new EventEmitter to.\n   */\n  function defer(event, disposable) {\n    return debounce(event, () => void 0, 0, undefined, true, undefined, disposable);\n  }\n  Event.defer = defer;\n  /**\n   * Given an event, returns another event which only fires once.\n   *\n   * @param event The event source for the new event.\n   */\n  function once(event) {\n    return (listener, thisArgs = null, disposables) => {\n      // we need this, in case the event fires during the listener call\n      let didFire = false;\n      let result = undefined;\n      result = event(e => {\n        if (didFire) {\n          return;\n        } else if (result) {\n          result.dispose();\n        } else {\n          didFire = true;\n        }\n        return listener.call(thisArgs, e);\n      }, null, disposables);\n      if (didFire) {\n        result.dispose();\n      }\n      return result;\n    };\n  }\n  Event.once = once;\n  /**\n   * Maps an event of one type into an event of another type using a mapping function, similar to how\n   * `Array.prototype.map` works.\n   *\n   * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n   * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n   * returned event causes this utility to leak a listener on the original event.\n   *\n   * @param event The event source for the new event.\n   * @param map The mapping function.\n   * @param disposable A disposable store to add the new EventEmitter to.\n   */\n  function map(event, map, disposable) {\n    return snapshot((listener, thisArgs = null, disposables) => event(i => listener.call(thisArgs, map(i)), null, disposables), disposable);\n  }\n  Event.map = map;\n  /**\n   * Wraps an event in another event that performs some function on the event object before firing.\n   *\n   * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n   * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n   * returned event causes this utility to leak a listener on the original event.\n   *\n   * @param event The event source for the new event.\n   * @param each The function to perform on the event object.\n   * @param disposable A disposable store to add the new EventEmitter to.\n   */\n  function forEach(event, each, disposable) {\n    return snapshot((listener, thisArgs = null, disposables) => event(i => {\n      each(i);\n      listener.call(thisArgs, i);\n    }, null, disposables), disposable);\n  }\n  Event.forEach = forEach;\n  function filter(event, filter, disposable) {\n    return snapshot((listener, thisArgs = null, disposables) => event(e => filter(e) && listener.call(thisArgs, e), null, disposables), disposable);\n  }\n  Event.filter = filter;\n  /**\n   * Given an event, returns the same event but typed as `Event<void>`.\n   */\n  function signal(event) {\n    return event;\n  }\n  Event.signal = signal;\n  function any(...events) {\n    return (listener, thisArgs = null, disposables) => combinedDisposable(...events.map(event => event(e => listener.call(thisArgs, e), null, disposables)));\n  }\n  Event.any = any;\n  /**\n   * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n   * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n   * returned event causes this utility to leak a listener on the original event.\n   */\n  function reduce(event, merge, initial, disposable) {\n    let output = initial;\n    return map(event, e => {\n      output = merge(output, e);\n      return output;\n    }, disposable);\n  }\n  Event.reduce = reduce;\n  function snapshot(event, disposable) {\n    let listener;\n    const options = {\n      onWillAddFirstListener() {\n        listener = event(emitter.fire, emitter);\n      },\n      onDidRemoveLastListener() {\n        listener === null || listener === void 0 ? void 0 : listener.dispose();\n      }\n    };\n    if (!disposable) {\n      _addLeakageTraceLogic(options);\n    }\n    const emitter = new Emitter(options);\n    disposable === null || disposable === void 0 ? void 0 : disposable.add(emitter);\n    return emitter.event;\n  }\n  function debounce(event, merge, delay = 100, leading = false, flushOnListenerRemove = false, leakWarningThreshold, disposable) {\n    let subscription;\n    let output = undefined;\n    let handle = undefined;\n    let numDebouncedCalls = 0;\n    let doFire;\n    const options = {\n      leakWarningThreshold,\n      onWillAddFirstListener() {\n        subscription = event(cur => {\n          numDebouncedCalls++;\n          output = merge(output, cur);\n          if (leading && !handle) {\n            emitter.fire(output);\n            output = undefined;\n          }\n          doFire = () => {\n            const _output = output;\n            output = undefined;\n            handle = undefined;\n            if (!leading || numDebouncedCalls > 1) {\n              emitter.fire(_output);\n            }\n            numDebouncedCalls = 0;\n          };\n          if (typeof delay === 'number') {\n            clearTimeout(handle);\n            handle = setTimeout(doFire, delay);\n          } else {\n            if (handle === undefined) {\n              handle = 0;\n              queueMicrotask(doFire);\n            }\n          }\n        });\n      },\n      onWillRemoveListener() {\n        if (flushOnListenerRemove && numDebouncedCalls > 0) {\n          doFire === null || doFire === void 0 ? void 0 : doFire();\n        }\n      },\n      onDidRemoveLastListener() {\n        doFire = undefined;\n        subscription.dispose();\n      }\n    };\n    if (!disposable) {\n      _addLeakageTraceLogic(options);\n    }\n    const emitter = new Emitter(options);\n    disposable === null || disposable === void 0 ? void 0 : disposable.add(emitter);\n    return emitter.event;\n  }\n  Event.debounce = debounce;\n  /**\n   * Debounces an event, firing after some delay (default=0) with an array of all event original objects.\n   *\n   * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n   * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n   * returned event causes this utility to leak a listener on the original event.\n   */\n  function accumulate(event, delay = 0, disposable) {\n    return Event.debounce(event, (last, e) => {\n      if (!last) {\n        return [e];\n      }\n      last.push(e);\n      return last;\n    }, delay, undefined, true, undefined, disposable);\n  }\n  Event.accumulate = accumulate;\n  /**\n   * Filters an event such that some condition is _not_ met more than once in a row, effectively ensuring duplicate\n   * event objects from different sources do not fire the same event object.\n   *\n   * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n   * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n   * returned event causes this utility to leak a listener on the original event.\n   *\n   * @param event The event source for the new event.\n   * @param equals The equality condition.\n   * @param disposable A disposable store to add the new EventEmitter to.\n   *\n   * @example\n   * ```\n   * // Fire only one time when a single window is opened or focused\n   * Event.latch(Event.any(onDidOpenWindow, onDidFocusWindow))\n   * ```\n   */\n  function latch(event, equals = (a, b) => a === b, disposable) {\n    let firstCall = true;\n    let cache;\n    return filter(event, value => {\n      const shouldEmit = firstCall || !equals(value, cache);\n      firstCall = false;\n      cache = value;\n      return shouldEmit;\n    }, disposable);\n  }\n  Event.latch = latch;\n  /**\n   * Splits an event whose parameter is a union type into 2 separate events for each type in the union.\n   *\n   * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n   * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n   * returned event causes this utility to leak a listener on the original event.\n   *\n   * @example\n   * ```\n   * const event = new EventEmitter<number | undefined>().event;\n   * const [numberEvent, undefinedEvent] = Event.split(event, isUndefined);\n   * ```\n   *\n   * @param event The event source for the new event.\n   * @param isT A function that determines what event is of the first type.\n   * @param disposable A disposable store to add the new EventEmitter to.\n   */\n  function split(event, isT, disposable) {\n    return [Event.filter(event, isT, disposable), Event.filter(event, e => !isT(e), disposable)];\n  }\n  Event.split = split;\n  /**\n   * Buffers an event until it has a listener attached.\n   *\n   * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n   * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n   * returned event causes this utility to leak a listener on the original event.\n   *\n   * @param event The event source for the new event.\n   * @param flushAfterTimeout Determines whether to flush the buffer after a timeout immediately or after a\n   * `setTimeout` when the first event listener is added.\n   * @param _buffer Internal: A source event array used for tests.\n   *\n   * @example\n   * ```\n   * // Start accumulating events, when the first listener is attached, flush\n   * // the event after a timeout such that multiple listeners attached before\n   * // the timeout would receive the event\n   * this.onInstallExtension = Event.buffer(service.onInstallExtension, true);\n   * ```\n   */\n  function buffer(event, flushAfterTimeout = false, _buffer = []) {\n    let buffer = _buffer.slice();\n    let listener = event(e => {\n      if (buffer) {\n        buffer.push(e);\n      } else {\n        emitter.fire(e);\n      }\n    });\n    const flush = () => {\n      buffer === null || buffer === void 0 ? void 0 : buffer.forEach(e => emitter.fire(e));\n      buffer = null;\n    };\n    const emitter = new Emitter({\n      onWillAddFirstListener() {\n        if (!listener) {\n          listener = event(e => emitter.fire(e));\n        }\n      },\n      onDidAddFirstListener() {\n        if (buffer) {\n          if (flushAfterTimeout) {\n            setTimeout(flush);\n          } else {\n            flush();\n          }\n        }\n      },\n      onDidRemoveLastListener() {\n        if (listener) {\n          listener.dispose();\n        }\n        listener = null;\n      }\n    });\n    return emitter.event;\n  }\n  Event.buffer = buffer;\n  class ChainableEvent {\n    constructor(event) {\n      this.event = event;\n      this.disposables = new DisposableStore();\n    }\n    /** @see {@link Event.map} */\n    map(fn) {\n      return new ChainableEvent(map(this.event, fn, this.disposables));\n    }\n    /** @see {@link Event.forEach} */\n    forEach(fn) {\n      return new ChainableEvent(forEach(this.event, fn, this.disposables));\n    }\n    filter(fn) {\n      return new ChainableEvent(filter(this.event, fn, this.disposables));\n    }\n    /** @see {@link Event.reduce} */\n    reduce(merge, initial) {\n      return new ChainableEvent(reduce(this.event, merge, initial, this.disposables));\n    }\n    /** @see {@link Event.reduce} */\n    latch() {\n      return new ChainableEvent(latch(this.event, undefined, this.disposables));\n    }\n    debounce(merge, delay = 100, leading = false, flushOnListenerRemove = false, leakWarningThreshold) {\n      return new ChainableEvent(debounce(this.event, merge, delay, leading, flushOnListenerRemove, leakWarningThreshold, this.disposables));\n    }\n    /**\n     * Attach a listener to the event.\n     */\n    on(listener, thisArgs, disposables) {\n      return this.event(listener, thisArgs, disposables);\n    }\n    /** @see {@link Event.once} */\n    once(listener, thisArgs, disposables) {\n      return once(this.event)(listener, thisArgs, disposables);\n    }\n    dispose() {\n      this.disposables.dispose();\n    }\n  }\n  /**\n   * Wraps the event in an {@link IChainableEvent}, allowing a more functional programming style.\n   *\n   * @example\n   * ```\n   * // Normal\n   * const onEnterPressNormal = Event.filter(\n   *   Event.map(onKeyPress.event, e => new StandardKeyboardEvent(e)),\n   *   e.keyCode === KeyCode.Enter\n   * ).event;\n   *\n   * // Using chain\n   * const onEnterPressChain = Event.chain(onKeyPress.event)\n   *   .map(e => new StandardKeyboardEvent(e))\n   *   .filter(e => e.keyCode === KeyCode.Enter)\n   *   .event;\n   * ```\n   */\n  function chain(event) {\n    return new ChainableEvent(event);\n  }\n  Event.chain = chain;\n  /**\n   * Creates an {@link Event} from a node event emitter.\n   */\n  function fromNodeEventEmitter(emitter, eventName, map = id => id) {\n    const fn = (...args) => result.fire(map(...args));\n    const onFirstListenerAdd = () => emitter.on(eventName, fn);\n    const onLastListenerRemove = () => emitter.removeListener(eventName, fn);\n    const result = new Emitter({\n      onWillAddFirstListener: onFirstListenerAdd,\n      onDidRemoveLastListener: onLastListenerRemove\n    });\n    return result.event;\n  }\n  Event.fromNodeEventEmitter = fromNodeEventEmitter;\n  /**\n   * Creates an {@link Event} from a DOM event emitter.\n   */\n  function fromDOMEventEmitter(emitter, eventName, map = id => id) {\n    const fn = (...args) => result.fire(map(...args));\n    const onFirstListenerAdd = () => emitter.addEventListener(eventName, fn);\n    const onLastListenerRemove = () => emitter.removeEventListener(eventName, fn);\n    const result = new Emitter({\n      onWillAddFirstListener: onFirstListenerAdd,\n      onDidRemoveLastListener: onLastListenerRemove\n    });\n    return result.event;\n  }\n  Event.fromDOMEventEmitter = fromDOMEventEmitter;\n  /**\n   * Creates a promise out of an event, using the {@link Event.once} helper.\n   */\n  function toPromise(event) {\n    return new Promise(resolve => once(event)(resolve));\n  }\n  Event.toPromise = toPromise;\n  /**\n   * Adds a listener to an event and calls the listener immediately with undefined as the event object.\n   *\n   * @example\n   * ```\n   * // Initialize the UI and update it when dataChangeEvent fires\n   * runAndSubscribe(dataChangeEvent, () => this._updateUI());\n   * ```\n   */\n  function runAndSubscribe(event, handler) {\n    handler(undefined);\n    return event(e => handler(e));\n  }\n  Event.runAndSubscribe = runAndSubscribe;\n  /**\n   * Adds a listener to an event and calls the listener immediately with undefined as the event object. A new\n   * {@link DisposableStore} is passed to the listener which is disposed when the returned disposable is disposed.\n   */\n  function runAndSubscribeWithStore(event, handler) {\n    let store = null;\n    function run(e) {\n      store === null || store === void 0 ? void 0 : store.dispose();\n      store = new DisposableStore();\n      handler(e, store);\n    }\n    run(undefined);\n    const disposable = event(e => run(e));\n    return toDisposable(() => {\n      disposable.dispose();\n      store === null || store === void 0 ? void 0 : store.dispose();\n    });\n  }\n  Event.runAndSubscribeWithStore = runAndSubscribeWithStore;\n  class EmitterObserver {\n    constructor(_observable, store) {\n      this._observable = _observable;\n      this._counter = 0;\n      this._hasChanged = false;\n      const options = {\n        onWillAddFirstListener: () => {\n          _observable.addObserver(this);\n        },\n        onDidRemoveLastListener: () => {\n          _observable.removeObserver(this);\n        }\n      };\n      if (!store) {\n        _addLeakageTraceLogic(options);\n      }\n      this.emitter = new Emitter(options);\n      if (store) {\n        store.add(this.emitter);\n      }\n    }\n    beginUpdate(_observable) {\n      // assert(_observable === this.obs);\n      this._counter++;\n    }\n    handlePossibleChange(_observable) {\n      // assert(_observable === this.obs);\n    }\n    handleChange(_observable, _change) {\n      // assert(_observable === this.obs);\n      this._hasChanged = true;\n    }\n    endUpdate(_observable) {\n      // assert(_observable === this.obs);\n      this._counter--;\n      if (this._counter === 0) {\n        this._observable.reportChanges();\n        if (this._hasChanged) {\n          this._hasChanged = false;\n          this.emitter.fire(this._observable.get());\n        }\n      }\n    }\n  }\n  /**\n   * Creates an event emitter that is fired when the observable changes.\n   * Each listeners subscribes to the emitter.\n   */\n  function fromObservable(obs, store) {\n    const observer = new EmitterObserver(obs, store);\n    return observer.emitter.event;\n  }\n  Event.fromObservable = fromObservable;\n  /**\n   * Each listener is attached to the observable directly.\n   */\n  function fromObservableLight(observable) {\n    return listener => {\n      let count = 0;\n      let didChange = false;\n      const observer = {\n        beginUpdate() {\n          count++;\n        },\n        endUpdate() {\n          count--;\n          if (count === 0) {\n            observable.reportChanges();\n            if (didChange) {\n              didChange = false;\n              listener();\n            }\n          }\n        },\n        handlePossibleChange() {\n          // noop\n        },\n        handleChange() {\n          didChange = true;\n        }\n      };\n      observable.addObserver(observer);\n      observable.reportChanges();\n      return {\n        dispose() {\n          observable.removeObserver(observer);\n        }\n      };\n    };\n  }\n  Event.fromObservableLight = fromObservableLight;\n})(Event || (Event = {}));\nexport class EventProfiling {\n  constructor(name) {\n    this.listenerCount = 0;\n    this.invocationCount = 0;\n    this.elapsedOverall = 0;\n    this.durations = [];\n    this.name = `${name}_${EventProfiling._idPool++}`;\n    EventProfiling.all.add(this);\n  }\n  start(listenerCount) {\n    this._stopWatch = new StopWatch();\n    this.listenerCount = listenerCount;\n  }\n  stop() {\n    if (this._stopWatch) {\n      const elapsed = this._stopWatch.elapsed();\n      this.durations.push(elapsed);\n      this.elapsedOverall += elapsed;\n      this.invocationCount += 1;\n      this._stopWatch = undefined;\n    }\n  }\n}\nEventProfiling.all = new Set();\nEventProfiling._idPool = 0;\nlet _globalLeakWarningThreshold = -1;\nclass LeakageMonitor {\n  constructor(threshold, name = Math.random().toString(18).slice(2, 5)) {\n    this.threshold = threshold;\n    this.name = name;\n    this._warnCountdown = 0;\n  }\n  dispose() {\n    var _a;\n    (_a = this._stacks) === null || _a === void 0 ? void 0 : _a.clear();\n  }\n  check(stack, listenerCount) {\n    const threshold = this.threshold;\n    if (threshold <= 0 || listenerCount < threshold) {\n      return undefined;\n    }\n    if (!this._stacks) {\n      this._stacks = new Map();\n    }\n    const count = this._stacks.get(stack.value) || 0;\n    this._stacks.set(stack.value, count + 1);\n    this._warnCountdown -= 1;\n    if (this._warnCountdown <= 0) {\n      // only warn on first exceed and then every time the limit\n      // is exceeded by 50% again\n      this._warnCountdown = threshold * 0.5;\n      // find most frequent listener and print warning\n      let topStack;\n      let topCount = 0;\n      for (const [stack, count] of this._stacks) {\n        if (!topStack || topCount < count) {\n          topStack = stack;\n          topCount = count;\n        }\n      }\n      console.warn(`[${this.name}] potential listener LEAK detected, having ${listenerCount} listeners already. MOST frequent listener (${topCount}):`);\n      console.warn(topStack);\n    }\n    return () => {\n      const count = this._stacks.get(stack.value) || 0;\n      this._stacks.set(stack.value, count - 1);\n    };\n  }\n}\nclass Stacktrace {\n  static create() {\n    var _a;\n    return new Stacktrace((_a = new Error().stack) !== null && _a !== void 0 ? _a : '');\n  }\n  constructor(value) {\n    this.value = value;\n  }\n  print() {\n    console.warn(this.value.split('\\n').slice(2).join('\\n'));\n  }\n}\nclass UniqueContainer {\n  constructor(value) {\n    this.value = value;\n  }\n}\nconst compactionThreshold = 2;\nconst forEachListener = (listeners, fn) => {\n  if (listeners instanceof UniqueContainer) {\n    fn(listeners);\n  } else {\n    for (let i = 0; i < listeners.length; i++) {\n      const l = listeners[i];\n      if (l) {\n        fn(l);\n      }\n    }\n  }\n};\n/**\n * The Emitter can be used to expose an Event to the public\n * to fire it from the insides.\n * Sample:\n    class Document {\n\n        private readonly _onDidChange = new Emitter<(value:string)=>any>();\n\n        public onDidChange = this._onDidChange.event;\n\n        // getter-style\n        // get onDidChange(): Event<(value:string)=>any> {\n        // \treturn this._onDidChange.event;\n        // }\n\n        private _doIt() {\n            //...\n            this._onDidChange.fire(value);\n        }\n    }\n */\nexport class Emitter {\n  constructor(options) {\n    var _a, _b, _c, _d, _e;\n    this._size = 0;\n    this._options = options;\n    this._leakageMon = _globalLeakWarningThreshold > 0 || ((_a = this._options) === null || _a === void 0 ? void 0 : _a.leakWarningThreshold) ? new LeakageMonitor((_c = (_b = this._options) === null || _b === void 0 ? void 0 : _b.leakWarningThreshold) !== null && _c !== void 0 ? _c : _globalLeakWarningThreshold) : undefined;\n    this._perfMon = ((_d = this._options) === null || _d === void 0 ? void 0 : _d._profName) ? new EventProfiling(this._options._profName) : undefined;\n    this._deliveryQueue = (_e = this._options) === null || _e === void 0 ? void 0 : _e.deliveryQueue;\n  }\n  dispose() {\n    var _a, _b, _c, _d;\n    if (!this._disposed) {\n      this._disposed = true;\n      // It is bad to have listeners at the time of disposing an emitter, it is worst to have listeners keep the emitter\n      // alive via the reference that's embedded in their disposables. Therefore we loop over all remaining listeners and\n      // unset their subscriptions/disposables. Looping and blaming remaining listeners is done on next tick because the\n      // the following programming pattern is very popular:\n      //\n      // const someModel = this._disposables.add(new ModelObject()); // (1) create and register model\n      // this._disposables.add(someModel.onDidChange(() => { ... }); // (2) subscribe and register model-event listener\n      // ...later...\n      // this._disposables.dispose(); disposes (1) then (2): don't warn after (1) but after the \"overall dispose\" is done\n      if (((_a = this._deliveryQueue) === null || _a === void 0 ? void 0 : _a.current) === this) {\n        this._deliveryQueue.reset();\n      }\n      if (this._listeners) {\n        if (_enableDisposeWithListenerWarning) {\n          const listeners = this._listeners;\n          queueMicrotask(() => {\n            forEachListener(listeners, l => {\n              var _a;\n              return (_a = l.stack) === null || _a === void 0 ? void 0 : _a.print();\n            });\n          });\n        }\n        this._listeners = undefined;\n        this._size = 0;\n      }\n      (_c = (_b = this._options) === null || _b === void 0 ? void 0 : _b.onDidRemoveLastListener) === null || _c === void 0 ? void 0 : _c.call(_b);\n      (_d = this._leakageMon) === null || _d === void 0 ? void 0 : _d.dispose();\n    }\n  }\n  /**\n   * For the public to allow to subscribe\n   * to events from this Emitter\n   */\n  get event() {\n    var _a;\n    (_a = this._event) !== null && _a !== void 0 ? _a : this._event = (callback, thisArgs, disposables) => {\n      var _a, _b, _c, _d, _e;\n      if (this._leakageMon && this._size > this._leakageMon.threshold * 3) {\n        console.warn(`[${this._leakageMon.name}] REFUSES to accept new listeners because it exceeded its threshold by far`);\n        return Disposable.None;\n      }\n      if (this._disposed) {\n        // todo: should we warn if a listener is added to a disposed emitter? This happens often\n        return Disposable.None;\n      }\n      if (thisArgs) {\n        callback = callback.bind(thisArgs);\n      }\n      const contained = new UniqueContainer(callback);\n      let removeMonitor;\n      let stack;\n      if (this._leakageMon && this._size >= Math.ceil(this._leakageMon.threshold * 0.2)) {\n        // check and record this emitter for potential leakage\n        contained.stack = Stacktrace.create();\n        removeMonitor = this._leakageMon.check(contained.stack, this._size + 1);\n      }\n      if (_enableDisposeWithListenerWarning) {\n        contained.stack = stack !== null && stack !== void 0 ? stack : Stacktrace.create();\n      }\n      if (!this._listeners) {\n        (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.onWillAddFirstListener) === null || _b === void 0 ? void 0 : _b.call(_a, this);\n        this._listeners = contained;\n        (_d = (_c = this._options) === null || _c === void 0 ? void 0 : _c.onDidAddFirstListener) === null || _d === void 0 ? void 0 : _d.call(_c, this);\n      } else if (this._listeners instanceof UniqueContainer) {\n        (_e = this._deliveryQueue) !== null && _e !== void 0 ? _e : this._deliveryQueue = new EventDeliveryQueuePrivate();\n        this._listeners = [this._listeners, contained];\n      } else {\n        this._listeners.push(contained);\n      }\n      this._size++;\n      const result = toDisposable(() => {\n        removeMonitor === null || removeMonitor === void 0 ? void 0 : removeMonitor();\n        this._removeListener(contained);\n      });\n      if (disposables instanceof DisposableStore) {\n        disposables.add(result);\n      } else if (Array.isArray(disposables)) {\n        disposables.push(result);\n      }\n      return result;\n    };\n    return this._event;\n  }\n  _removeListener(listener) {\n    var _a, _b, _c, _d;\n    (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.onWillRemoveListener) === null || _b === void 0 ? void 0 : _b.call(_a, this);\n    if (!this._listeners) {\n      return; // expected if a listener gets disposed\n    }\n\n    if (this._size === 1) {\n      this._listeners = undefined;\n      (_d = (_c = this._options) === null || _c === void 0 ? void 0 : _c.onDidRemoveLastListener) === null || _d === void 0 ? void 0 : _d.call(_c, this);\n      this._size = 0;\n      return;\n    }\n    // size > 1 which requires that listeners be a list:\n    const listeners = this._listeners;\n    const index = listeners.indexOf(listener);\n    if (index === -1) {\n      console.log('disposed?', this._disposed);\n      console.log('size?', this._size);\n      console.log('arr?', JSON.stringify(this._listeners));\n      throw new Error('Attempted to dispose unknown listener');\n    }\n    this._size--;\n    listeners[index] = undefined;\n    const adjustDeliveryQueue = this._deliveryQueue.current === this;\n    if (this._size * compactionThreshold <= listeners.length) {\n      let n = 0;\n      for (let i = 0; i < listeners.length; i++) {\n        if (listeners[i]) {\n          listeners[n++] = listeners[i];\n        } else if (adjustDeliveryQueue) {\n          this._deliveryQueue.end--;\n          if (n < this._deliveryQueue.i) {\n            this._deliveryQueue.i--;\n          }\n        }\n      }\n      listeners.length = n;\n    }\n  }\n  _deliver(listener, value) {\n    var _a;\n    if (!listener) {\n      return;\n    }\n    const errorHandler = ((_a = this._options) === null || _a === void 0 ? void 0 : _a.onListenerError) || onUnexpectedError;\n    if (!errorHandler) {\n      listener.value(value);\n      return;\n    }\n    try {\n      listener.value(value);\n    } catch (e) {\n      errorHandler(e);\n    }\n  }\n  /** Delivers items in the queue. Assumes the queue is ready to go. */\n  _deliverQueue(dq) {\n    const listeners = dq.current._listeners;\n    while (dq.i < dq.end) {\n      // important: dq.i is incremented before calling deliver() because it might reenter deliverQueue()\n      this._deliver(listeners[dq.i++], dq.value);\n    }\n    dq.reset();\n  }\n  /**\n   * To be kept private to fire an event to\n   * subscribers\n   */\n  fire(event) {\n    var _a, _b, _c, _d;\n    if ((_a = this._deliveryQueue) === null || _a === void 0 ? void 0 : _a.current) {\n      this._deliverQueue(this._deliveryQueue);\n      (_b = this._perfMon) === null || _b === void 0 ? void 0 : _b.stop(); // last fire() will have starting perfmon, stop it before starting the next dispatch\n    }\n\n    (_c = this._perfMon) === null || _c === void 0 ? void 0 : _c.start(this._size);\n    if (!this._listeners) {\n      // no-op\n    } else if (this._listeners instanceof UniqueContainer) {\n      this._deliver(this._listeners, event);\n    } else {\n      const dq = this._deliveryQueue;\n      dq.enqueue(this, event, this._listeners.length);\n      this._deliverQueue(dq);\n    }\n    (_d = this._perfMon) === null || _d === void 0 ? void 0 : _d.stop();\n  }\n  hasListeners() {\n    return this._size > 0;\n  }\n}\nexport const createEventDeliveryQueue = () => new EventDeliveryQueuePrivate();\nclass EventDeliveryQueuePrivate {\n  constructor() {\n    /**\n     * Index in current's listener list.\n     */\n    this.i = -1;\n    /**\n     * The last index in the listener's list to deliver.\n     */\n    this.end = 0;\n  }\n  enqueue(emitter, value, end) {\n    this.i = 0;\n    this.end = end;\n    this.current = emitter;\n    this.value = value;\n  }\n  reset() {\n    this.i = this.end; // force any current emission loop to stop, mainly for during dispose\n    this.current = undefined;\n    this.value = undefined;\n  }\n}\nexport class PauseableEmitter extends Emitter {\n  constructor(options) {\n    super(options);\n    this._isPaused = 0;\n    this._eventQueue = new LinkedList();\n    this._mergeFn = options === null || options === void 0 ? void 0 : options.merge;\n  }\n  pause() {\n    this._isPaused++;\n  }\n  resume() {\n    if (this._isPaused !== 0 && --this._isPaused === 0) {\n      if (this._mergeFn) {\n        // use the merge function to create a single composite\n        // event. make a copy in case firing pauses this emitter\n        if (this._eventQueue.size > 0) {\n          const events = Array.from(this._eventQueue);\n          this._eventQueue.clear();\n          super.fire(this._mergeFn(events));\n        }\n      } else {\n        // no merging, fire each event individually and test\n        // that this emitter isn't paused halfway through\n        while (!this._isPaused && this._eventQueue.size !== 0) {\n          super.fire(this._eventQueue.shift());\n        }\n      }\n    }\n  }\n  fire(event) {\n    if (this._size) {\n      if (this._isPaused !== 0) {\n        this._eventQueue.push(event);\n      } else {\n        super.fire(event);\n      }\n    }\n  }\n}\nexport class DebounceEmitter extends PauseableEmitter {\n  constructor(options) {\n    var _a;\n    super(options);\n    this._delay = (_a = options.delay) !== null && _a !== void 0 ? _a : 100;\n  }\n  fire(event) {\n    if (!this._handle) {\n      this.pause();\n      this._handle = setTimeout(() => {\n        this._handle = undefined;\n        this.resume();\n      }, this._delay);\n    }\n    super.fire(event);\n  }\n}\n/**\n * An emitter which queue all events and then process them at the\n * end of the event loop.\n */\nexport class MicrotaskEmitter extends Emitter {\n  constructor(options) {\n    super(options);\n    this._queuedEvents = [];\n    this._mergeFn = options === null || options === void 0 ? void 0 : options.merge;\n  }\n  fire(event) {\n    if (!this.hasListeners()) {\n      return;\n    }\n    this._queuedEvents.push(event);\n    if (this._queuedEvents.length === 1) {\n      queueMicrotask(() => {\n        if (this._mergeFn) {\n          super.fire(this._mergeFn(this._queuedEvents));\n        } else {\n          this._queuedEvents.forEach(e => super.fire(e));\n        }\n        this._queuedEvents = [];\n      });\n    }\n  }\n}\nexport class EventMultiplexer {\n  constructor() {\n    this.hasListeners = false;\n    this.events = [];\n    this.emitter = new Emitter({\n      onWillAddFirstListener: () => this.onFirstListenerAdd(),\n      onDidRemoveLastListener: () => this.onLastListenerRemove()\n    });\n  }\n  get event() {\n    return this.emitter.event;\n  }\n  add(event) {\n    const e = {\n      event: event,\n      listener: null\n    };\n    this.events.push(e);\n    if (this.hasListeners) {\n      this.hook(e);\n    }\n    const dispose = () => {\n      if (this.hasListeners) {\n        this.unhook(e);\n      }\n      const idx = this.events.indexOf(e);\n      this.events.splice(idx, 1);\n    };\n    return toDisposable(onceFn(dispose));\n  }\n  onFirstListenerAdd() {\n    this.hasListeners = true;\n    this.events.forEach(e => this.hook(e));\n  }\n  onLastListenerRemove() {\n    this.hasListeners = false;\n    this.events.forEach(e => this.unhook(e));\n  }\n  hook(e) {\n    e.listener = e.event(r => this.emitter.fire(r));\n  }\n  unhook(e) {\n    if (e.listener) {\n      e.listener.dispose();\n    }\n    e.listener = null;\n  }\n  dispose() {\n    this.emitter.dispose();\n  }\n}\n/**\n * The EventBufferer is useful in situations in which you want\n * to delay firing your events during some code.\n * You can wrap that code and be sure that the event will not\n * be fired during that wrap.\n *\n * ```\n * const emitter: Emitter;\n * const delayer = new EventDelayer();\n * const delayedEvent = delayer.wrapEvent(emitter.event);\n *\n * delayedEvent(console.log);\n *\n * delayer.bufferEvents(() => {\n *   emitter.fire(); // event will not be fired yet\n * });\n *\n * // event will only be fired at this point\n * ```\n */\nexport class EventBufferer {\n  constructor() {\n    this.buffers = [];\n  }\n  wrapEvent(event) {\n    return (listener, thisArgs, disposables) => {\n      return event(i => {\n        const buffer = this.buffers[this.buffers.length - 1];\n        if (buffer) {\n          buffer.push(() => listener.call(thisArgs, i));\n        } else {\n          listener.call(thisArgs, i);\n        }\n      }, undefined, disposables);\n    };\n  }\n  bufferEvents(fn) {\n    const buffer = [];\n    this.buffers.push(buffer);\n    const r = fn();\n    this.buffers.pop();\n    buffer.forEach(flush => flush());\n    return r;\n  }\n}\n/**\n * A Relay is an event forwarder which functions as a replugabble event pipe.\n * Once created, you can connect an input event to it and it will simply forward\n * events from that input event through its own `event` property. The `input`\n * can be changed at any point in time.\n */\nexport class Relay {\n  constructor() {\n    this.listening = false;\n    this.inputEvent = Event.None;\n    this.inputEventListener = Disposable.None;\n    this.emitter = new Emitter({\n      onDidAddFirstListener: () => {\n        this.listening = true;\n        this.inputEventListener = this.inputEvent(this.emitter.fire, this.emitter);\n      },\n      onDidRemoveLastListener: () => {\n        this.listening = false;\n        this.inputEventListener.dispose();\n      }\n    });\n    this.event = this.emitter.event;\n  }\n  set input(event) {\n    this.inputEvent = event;\n    if (this.listening) {\n      this.inputEventListener.dispose();\n      this.inputEventListener = event(this.emitter.fire, this.emitter);\n    }\n  }\n  dispose() {\n    this.inputEventListener.dispose();\n    this.emitter.dispose();\n  }\n}","map":{"version":3,"names":["onUnexpectedError","once","onceFn","combinedDisposable","Disposable","DisposableStore","toDisposable","LinkedList","StopWatch","_enableDisposeWithListenerWarning","_enableSnapshotPotentialLeakWarning","Event","None","_addLeakageTraceLogic","options","onDidAddListener","origListenerDidAdd","stack","Stacktrace","create","count","console","warn","print","defer","event","disposable","debounce","undefined","listener","thisArgs","disposables","didFire","result","e","dispose","call","map","snapshot","i","forEach","each","filter","signal","any","events","reduce","merge","initial","output","onWillAddFirstListener","emitter","fire","onDidRemoveLastListener","Emitter","add","delay","leading","flushOnListenerRemove","leakWarningThreshold","subscription","handle","numDebouncedCalls","doFire","cur","_output","clearTimeout","setTimeout","queueMicrotask","onWillRemoveListener","accumulate","last","push","latch","equals","a","b","firstCall","cache","value","shouldEmit","split","isT","buffer","flushAfterTimeout","_buffer","slice","flush","onDidAddFirstListener","ChainableEvent","constructor","fn","on","chain","fromNodeEventEmitter","eventName","id","args","onFirstListenerAdd","onLastListenerRemove","removeListener","fromDOMEventEmitter","addEventListener","removeEventListener","toPromise","Promise","resolve","runAndSubscribe","handler","runAndSubscribeWithStore","store","run","EmitterObserver","_observable","_counter","_hasChanged","addObserver","removeObserver","beginUpdate","handlePossibleChange","handleChange","_change","endUpdate","reportChanges","get","fromObservable","obs","observer","fromObservableLight","observable","didChange","EventProfiling","name","listenerCount","invocationCount","elapsedOverall","durations","_idPool","all","start","_stopWatch","stop","elapsed","Set","_globalLeakWarningThreshold","LeakageMonitor","threshold","Math","random","toString","_warnCountdown","_a","_stacks","clear","check","Map","set","topStack","topCount","Error","join","UniqueContainer","compactionThreshold","forEachListener","listeners","length","l","_b","_c","_d","_e","_size","_options","_leakageMon","_perfMon","_profName","_deliveryQueue","deliveryQueue","_disposed","current","reset","_listeners","_event","callback","bind","contained","removeMonitor","ceil","EventDeliveryQueuePrivate","_removeListener","Array","isArray","index","indexOf","log","JSON","stringify","adjustDeliveryQueue","n","end","_deliver","errorHandler","onListenerError","_deliverQueue","dq","enqueue","hasListeners","createEventDeliveryQueue","PauseableEmitter","_isPaused","_eventQueue","_mergeFn","pause","resume","size","from","shift","DebounceEmitter","_delay","_handle","MicrotaskEmitter","_queuedEvents","EventMultiplexer","hook","unhook","idx","splice","r","EventBufferer","buffers","wrapEvent","bufferEvents","pop","Relay","listening","inputEvent","inputEventListener","input"],"sources":["D:/code/java/program/oj/code/yuoj-frontend-master/node_modules/monaco-editor/esm/vs/base/common/event.js"],"sourcesContent":["import { onUnexpectedError } from './errors.js';\nimport { once as onceFn } from './functional.js';\nimport { combinedDisposable, Disposable, DisposableStore, toDisposable } from './lifecycle.js';\nimport { LinkedList } from './linkedList.js';\nimport { StopWatch } from './stopwatch.js';\n// -----------------------------------------------------------------------------------------------------------------------\n// Uncomment the next line to print warnings whenever an emitter with listeners is disposed. That is a sign of code smell.\n// -----------------------------------------------------------------------------------------------------------------------\nconst _enableDisposeWithListenerWarning = false;\n// _enableDisposeWithListenerWarning = Boolean(\"TRUE\"); // causes a linter warning so that it cannot be pushed\n// -----------------------------------------------------------------------------------------------------------------------\n// Uncomment the next line to print warnings whenever a snapshotted event is used repeatedly without cleanup.\n// See https://github.com/microsoft/vscode/issues/142851\n// -----------------------------------------------------------------------------------------------------------------------\nconst _enableSnapshotPotentialLeakWarning = false;\nexport var Event;\n(function (Event) {\n    Event.None = () => Disposable.None;\n    function _addLeakageTraceLogic(options) {\n        if (_enableSnapshotPotentialLeakWarning) {\n            const { onDidAddListener: origListenerDidAdd } = options;\n            const stack = Stacktrace.create();\n            let count = 0;\n            options.onDidAddListener = () => {\n                if (++count === 2) {\n                    console.warn('snapshotted emitter LIKELY used public and SHOULD HAVE BEEN created with DisposableStore. snapshotted here');\n                    stack.print();\n                }\n                origListenerDidAdd === null || origListenerDidAdd === void 0 ? void 0 : origListenerDidAdd();\n            };\n        }\n    }\n    /**\n     * Given an event, returns another event which debounces calls and defers the listeners to a later task via a shared\n     * `setTimeout`. The event is converted into a signal (`Event<void>`) to avoid additional object creation as a\n     * result of merging events and to try prevent race conditions that could arise when using related deferred and\n     * non-deferred events.\n     *\n     * This is useful for deferring non-critical work (eg. general UI updates) to ensure it does not block critical work\n     * (eg. latency of keypress to text rendered).\n     *\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     *\n     * @param event The event source for the new event.\n     * @param disposable A disposable store to add the new EventEmitter to.\n     */\n    function defer(event, disposable) {\n        return debounce(event, () => void 0, 0, undefined, true, undefined, disposable);\n    }\n    Event.defer = defer;\n    /**\n     * Given an event, returns another event which only fires once.\n     *\n     * @param event The event source for the new event.\n     */\n    function once(event) {\n        return (listener, thisArgs = null, disposables) => {\n            // we need this, in case the event fires during the listener call\n            let didFire = false;\n            let result = undefined;\n            result = event(e => {\n                if (didFire) {\n                    return;\n                }\n                else if (result) {\n                    result.dispose();\n                }\n                else {\n                    didFire = true;\n                }\n                return listener.call(thisArgs, e);\n            }, null, disposables);\n            if (didFire) {\n                result.dispose();\n            }\n            return result;\n        };\n    }\n    Event.once = once;\n    /**\n     * Maps an event of one type into an event of another type using a mapping function, similar to how\n     * `Array.prototype.map` works.\n     *\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     *\n     * @param event The event source for the new event.\n     * @param map The mapping function.\n     * @param disposable A disposable store to add the new EventEmitter to.\n     */\n    function map(event, map, disposable) {\n        return snapshot((listener, thisArgs = null, disposables) => event(i => listener.call(thisArgs, map(i)), null, disposables), disposable);\n    }\n    Event.map = map;\n    /**\n     * Wraps an event in another event that performs some function on the event object before firing.\n     *\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     *\n     * @param event The event source for the new event.\n     * @param each The function to perform on the event object.\n     * @param disposable A disposable store to add the new EventEmitter to.\n     */\n    function forEach(event, each, disposable) {\n        return snapshot((listener, thisArgs = null, disposables) => event(i => { each(i); listener.call(thisArgs, i); }, null, disposables), disposable);\n    }\n    Event.forEach = forEach;\n    function filter(event, filter, disposable) {\n        return snapshot((listener, thisArgs = null, disposables) => event(e => filter(e) && listener.call(thisArgs, e), null, disposables), disposable);\n    }\n    Event.filter = filter;\n    /**\n     * Given an event, returns the same event but typed as `Event<void>`.\n     */\n    function signal(event) {\n        return event;\n    }\n    Event.signal = signal;\n    function any(...events) {\n        return (listener, thisArgs = null, disposables) => combinedDisposable(...events.map(event => event(e => listener.call(thisArgs, e), null, disposables)));\n    }\n    Event.any = any;\n    /**\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     */\n    function reduce(event, merge, initial, disposable) {\n        let output = initial;\n        return map(event, e => {\n            output = merge(output, e);\n            return output;\n        }, disposable);\n    }\n    Event.reduce = reduce;\n    function snapshot(event, disposable) {\n        let listener;\n        const options = {\n            onWillAddFirstListener() {\n                listener = event(emitter.fire, emitter);\n            },\n            onDidRemoveLastListener() {\n                listener === null || listener === void 0 ? void 0 : listener.dispose();\n            }\n        };\n        if (!disposable) {\n            _addLeakageTraceLogic(options);\n        }\n        const emitter = new Emitter(options);\n        disposable === null || disposable === void 0 ? void 0 : disposable.add(emitter);\n        return emitter.event;\n    }\n    function debounce(event, merge, delay = 100, leading = false, flushOnListenerRemove = false, leakWarningThreshold, disposable) {\n        let subscription;\n        let output = undefined;\n        let handle = undefined;\n        let numDebouncedCalls = 0;\n        let doFire;\n        const options = {\n            leakWarningThreshold,\n            onWillAddFirstListener() {\n                subscription = event(cur => {\n                    numDebouncedCalls++;\n                    output = merge(output, cur);\n                    if (leading && !handle) {\n                        emitter.fire(output);\n                        output = undefined;\n                    }\n                    doFire = () => {\n                        const _output = output;\n                        output = undefined;\n                        handle = undefined;\n                        if (!leading || numDebouncedCalls > 1) {\n                            emitter.fire(_output);\n                        }\n                        numDebouncedCalls = 0;\n                    };\n                    if (typeof delay === 'number') {\n                        clearTimeout(handle);\n                        handle = setTimeout(doFire, delay);\n                    }\n                    else {\n                        if (handle === undefined) {\n                            handle = 0;\n                            queueMicrotask(doFire);\n                        }\n                    }\n                });\n            },\n            onWillRemoveListener() {\n                if (flushOnListenerRemove && numDebouncedCalls > 0) {\n                    doFire === null || doFire === void 0 ? void 0 : doFire();\n                }\n            },\n            onDidRemoveLastListener() {\n                doFire = undefined;\n                subscription.dispose();\n            }\n        };\n        if (!disposable) {\n            _addLeakageTraceLogic(options);\n        }\n        const emitter = new Emitter(options);\n        disposable === null || disposable === void 0 ? void 0 : disposable.add(emitter);\n        return emitter.event;\n    }\n    Event.debounce = debounce;\n    /**\n     * Debounces an event, firing after some delay (default=0) with an array of all event original objects.\n     *\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     */\n    function accumulate(event, delay = 0, disposable) {\n        return Event.debounce(event, (last, e) => {\n            if (!last) {\n                return [e];\n            }\n            last.push(e);\n            return last;\n        }, delay, undefined, true, undefined, disposable);\n    }\n    Event.accumulate = accumulate;\n    /**\n     * Filters an event such that some condition is _not_ met more than once in a row, effectively ensuring duplicate\n     * event objects from different sources do not fire the same event object.\n     *\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     *\n     * @param event The event source for the new event.\n     * @param equals The equality condition.\n     * @param disposable A disposable store to add the new EventEmitter to.\n     *\n     * @example\n     * ```\n     * // Fire only one time when a single window is opened or focused\n     * Event.latch(Event.any(onDidOpenWindow, onDidFocusWindow))\n     * ```\n     */\n    function latch(event, equals = (a, b) => a === b, disposable) {\n        let firstCall = true;\n        let cache;\n        return filter(event, value => {\n            const shouldEmit = firstCall || !equals(value, cache);\n            firstCall = false;\n            cache = value;\n            return shouldEmit;\n        }, disposable);\n    }\n    Event.latch = latch;\n    /**\n     * Splits an event whose parameter is a union type into 2 separate events for each type in the union.\n     *\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     *\n     * @example\n     * ```\n     * const event = new EventEmitter<number | undefined>().event;\n     * const [numberEvent, undefinedEvent] = Event.split(event, isUndefined);\n     * ```\n     *\n     * @param event The event source for the new event.\n     * @param isT A function that determines what event is of the first type.\n     * @param disposable A disposable store to add the new EventEmitter to.\n     */\n    function split(event, isT, disposable) {\n        return [\n            Event.filter(event, isT, disposable),\n            Event.filter(event, e => !isT(e), disposable),\n        ];\n    }\n    Event.split = split;\n    /**\n     * Buffers an event until it has a listener attached.\n     *\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     *\n     * @param event The event source for the new event.\n     * @param flushAfterTimeout Determines whether to flush the buffer after a timeout immediately or after a\n     * `setTimeout` when the first event listener is added.\n     * @param _buffer Internal: A source event array used for tests.\n     *\n     * @example\n     * ```\n     * // Start accumulating events, when the first listener is attached, flush\n     * // the event after a timeout such that multiple listeners attached before\n     * // the timeout would receive the event\n     * this.onInstallExtension = Event.buffer(service.onInstallExtension, true);\n     * ```\n     */\n    function buffer(event, flushAfterTimeout = false, _buffer = []) {\n        let buffer = _buffer.slice();\n        let listener = event(e => {\n            if (buffer) {\n                buffer.push(e);\n            }\n            else {\n                emitter.fire(e);\n            }\n        });\n        const flush = () => {\n            buffer === null || buffer === void 0 ? void 0 : buffer.forEach(e => emitter.fire(e));\n            buffer = null;\n        };\n        const emitter = new Emitter({\n            onWillAddFirstListener() {\n                if (!listener) {\n                    listener = event(e => emitter.fire(e));\n                }\n            },\n            onDidAddFirstListener() {\n                if (buffer) {\n                    if (flushAfterTimeout) {\n                        setTimeout(flush);\n                    }\n                    else {\n                        flush();\n                    }\n                }\n            },\n            onDidRemoveLastListener() {\n                if (listener) {\n                    listener.dispose();\n                }\n                listener = null;\n            }\n        });\n        return emitter.event;\n    }\n    Event.buffer = buffer;\n    class ChainableEvent {\n        constructor(event) {\n            this.event = event;\n            this.disposables = new DisposableStore();\n        }\n        /** @see {@link Event.map} */\n        map(fn) {\n            return new ChainableEvent(map(this.event, fn, this.disposables));\n        }\n        /** @see {@link Event.forEach} */\n        forEach(fn) {\n            return new ChainableEvent(forEach(this.event, fn, this.disposables));\n        }\n        filter(fn) {\n            return new ChainableEvent(filter(this.event, fn, this.disposables));\n        }\n        /** @see {@link Event.reduce} */\n        reduce(merge, initial) {\n            return new ChainableEvent(reduce(this.event, merge, initial, this.disposables));\n        }\n        /** @see {@link Event.reduce} */\n        latch() {\n            return new ChainableEvent(latch(this.event, undefined, this.disposables));\n        }\n        debounce(merge, delay = 100, leading = false, flushOnListenerRemove = false, leakWarningThreshold) {\n            return new ChainableEvent(debounce(this.event, merge, delay, leading, flushOnListenerRemove, leakWarningThreshold, this.disposables));\n        }\n        /**\n         * Attach a listener to the event.\n         */\n        on(listener, thisArgs, disposables) {\n            return this.event(listener, thisArgs, disposables);\n        }\n        /** @see {@link Event.once} */\n        once(listener, thisArgs, disposables) {\n            return once(this.event)(listener, thisArgs, disposables);\n        }\n        dispose() {\n            this.disposables.dispose();\n        }\n    }\n    /**\n     * Wraps the event in an {@link IChainableEvent}, allowing a more functional programming style.\n     *\n     * @example\n     * ```\n     * // Normal\n     * const onEnterPressNormal = Event.filter(\n     *   Event.map(onKeyPress.event, e => new StandardKeyboardEvent(e)),\n     *   e.keyCode === KeyCode.Enter\n     * ).event;\n     *\n     * // Using chain\n     * const onEnterPressChain = Event.chain(onKeyPress.event)\n     *   .map(e => new StandardKeyboardEvent(e))\n     *   .filter(e => e.keyCode === KeyCode.Enter)\n     *   .event;\n     * ```\n     */\n    function chain(event) {\n        return new ChainableEvent(event);\n    }\n    Event.chain = chain;\n    /**\n     * Creates an {@link Event} from a node event emitter.\n     */\n    function fromNodeEventEmitter(emitter, eventName, map = id => id) {\n        const fn = (...args) => result.fire(map(...args));\n        const onFirstListenerAdd = () => emitter.on(eventName, fn);\n        const onLastListenerRemove = () => emitter.removeListener(eventName, fn);\n        const result = new Emitter({ onWillAddFirstListener: onFirstListenerAdd, onDidRemoveLastListener: onLastListenerRemove });\n        return result.event;\n    }\n    Event.fromNodeEventEmitter = fromNodeEventEmitter;\n    /**\n     * Creates an {@link Event} from a DOM event emitter.\n     */\n    function fromDOMEventEmitter(emitter, eventName, map = id => id) {\n        const fn = (...args) => result.fire(map(...args));\n        const onFirstListenerAdd = () => emitter.addEventListener(eventName, fn);\n        const onLastListenerRemove = () => emitter.removeEventListener(eventName, fn);\n        const result = new Emitter({ onWillAddFirstListener: onFirstListenerAdd, onDidRemoveLastListener: onLastListenerRemove });\n        return result.event;\n    }\n    Event.fromDOMEventEmitter = fromDOMEventEmitter;\n    /**\n     * Creates a promise out of an event, using the {@link Event.once} helper.\n     */\n    function toPromise(event) {\n        return new Promise(resolve => once(event)(resolve));\n    }\n    Event.toPromise = toPromise;\n    /**\n     * Adds a listener to an event and calls the listener immediately with undefined as the event object.\n     *\n     * @example\n     * ```\n     * // Initialize the UI and update it when dataChangeEvent fires\n     * runAndSubscribe(dataChangeEvent, () => this._updateUI());\n     * ```\n     */\n    function runAndSubscribe(event, handler) {\n        handler(undefined);\n        return event(e => handler(e));\n    }\n    Event.runAndSubscribe = runAndSubscribe;\n    /**\n     * Adds a listener to an event and calls the listener immediately with undefined as the event object. A new\n     * {@link DisposableStore} is passed to the listener which is disposed when the returned disposable is disposed.\n     */\n    function runAndSubscribeWithStore(event, handler) {\n        let store = null;\n        function run(e) {\n            store === null || store === void 0 ? void 0 : store.dispose();\n            store = new DisposableStore();\n            handler(e, store);\n        }\n        run(undefined);\n        const disposable = event(e => run(e));\n        return toDisposable(() => {\n            disposable.dispose();\n            store === null || store === void 0 ? void 0 : store.dispose();\n        });\n    }\n    Event.runAndSubscribeWithStore = runAndSubscribeWithStore;\n    class EmitterObserver {\n        constructor(_observable, store) {\n            this._observable = _observable;\n            this._counter = 0;\n            this._hasChanged = false;\n            const options = {\n                onWillAddFirstListener: () => {\n                    _observable.addObserver(this);\n                },\n                onDidRemoveLastListener: () => {\n                    _observable.removeObserver(this);\n                }\n            };\n            if (!store) {\n                _addLeakageTraceLogic(options);\n            }\n            this.emitter = new Emitter(options);\n            if (store) {\n                store.add(this.emitter);\n            }\n        }\n        beginUpdate(_observable) {\n            // assert(_observable === this.obs);\n            this._counter++;\n        }\n        handlePossibleChange(_observable) {\n            // assert(_observable === this.obs);\n        }\n        handleChange(_observable, _change) {\n            // assert(_observable === this.obs);\n            this._hasChanged = true;\n        }\n        endUpdate(_observable) {\n            // assert(_observable === this.obs);\n            this._counter--;\n            if (this._counter === 0) {\n                this._observable.reportChanges();\n                if (this._hasChanged) {\n                    this._hasChanged = false;\n                    this.emitter.fire(this._observable.get());\n                }\n            }\n        }\n    }\n    /**\n     * Creates an event emitter that is fired when the observable changes.\n     * Each listeners subscribes to the emitter.\n     */\n    function fromObservable(obs, store) {\n        const observer = new EmitterObserver(obs, store);\n        return observer.emitter.event;\n    }\n    Event.fromObservable = fromObservable;\n    /**\n     * Each listener is attached to the observable directly.\n     */\n    function fromObservableLight(observable) {\n        return (listener) => {\n            let count = 0;\n            let didChange = false;\n            const observer = {\n                beginUpdate() {\n                    count++;\n                },\n                endUpdate() {\n                    count--;\n                    if (count === 0) {\n                        observable.reportChanges();\n                        if (didChange) {\n                            didChange = false;\n                            listener();\n                        }\n                    }\n                },\n                handlePossibleChange() {\n                    // noop\n                },\n                handleChange() {\n                    didChange = true;\n                }\n            };\n            observable.addObserver(observer);\n            observable.reportChanges();\n            return {\n                dispose() {\n                    observable.removeObserver(observer);\n                }\n            };\n        };\n    }\n    Event.fromObservableLight = fromObservableLight;\n})(Event || (Event = {}));\nexport class EventProfiling {\n    constructor(name) {\n        this.listenerCount = 0;\n        this.invocationCount = 0;\n        this.elapsedOverall = 0;\n        this.durations = [];\n        this.name = `${name}_${EventProfiling._idPool++}`;\n        EventProfiling.all.add(this);\n    }\n    start(listenerCount) {\n        this._stopWatch = new StopWatch();\n        this.listenerCount = listenerCount;\n    }\n    stop() {\n        if (this._stopWatch) {\n            const elapsed = this._stopWatch.elapsed();\n            this.durations.push(elapsed);\n            this.elapsedOverall += elapsed;\n            this.invocationCount += 1;\n            this._stopWatch = undefined;\n        }\n    }\n}\nEventProfiling.all = new Set();\nEventProfiling._idPool = 0;\nlet _globalLeakWarningThreshold = -1;\nclass LeakageMonitor {\n    constructor(threshold, name = Math.random().toString(18).slice(2, 5)) {\n        this.threshold = threshold;\n        this.name = name;\n        this._warnCountdown = 0;\n    }\n    dispose() {\n        var _a;\n        (_a = this._stacks) === null || _a === void 0 ? void 0 : _a.clear();\n    }\n    check(stack, listenerCount) {\n        const threshold = this.threshold;\n        if (threshold <= 0 || listenerCount < threshold) {\n            return undefined;\n        }\n        if (!this._stacks) {\n            this._stacks = new Map();\n        }\n        const count = (this._stacks.get(stack.value) || 0);\n        this._stacks.set(stack.value, count + 1);\n        this._warnCountdown -= 1;\n        if (this._warnCountdown <= 0) {\n            // only warn on first exceed and then every time the limit\n            // is exceeded by 50% again\n            this._warnCountdown = threshold * 0.5;\n            // find most frequent listener and print warning\n            let topStack;\n            let topCount = 0;\n            for (const [stack, count] of this._stacks) {\n                if (!topStack || topCount < count) {\n                    topStack = stack;\n                    topCount = count;\n                }\n            }\n            console.warn(`[${this.name}] potential listener LEAK detected, having ${listenerCount} listeners already. MOST frequent listener (${topCount}):`);\n            console.warn(topStack);\n        }\n        return () => {\n            const count = (this._stacks.get(stack.value) || 0);\n            this._stacks.set(stack.value, count - 1);\n        };\n    }\n}\nclass Stacktrace {\n    static create() {\n        var _a;\n        return new Stacktrace((_a = new Error().stack) !== null && _a !== void 0 ? _a : '');\n    }\n    constructor(value) {\n        this.value = value;\n    }\n    print() {\n        console.warn(this.value.split('\\n').slice(2).join('\\n'));\n    }\n}\nclass UniqueContainer {\n    constructor(value) {\n        this.value = value;\n    }\n}\nconst compactionThreshold = 2;\nconst forEachListener = (listeners, fn) => {\n    if (listeners instanceof UniqueContainer) {\n        fn(listeners);\n    }\n    else {\n        for (let i = 0; i < listeners.length; i++) {\n            const l = listeners[i];\n            if (l) {\n                fn(l);\n            }\n        }\n    }\n};\n/**\n * The Emitter can be used to expose an Event to the public\n * to fire it from the insides.\n * Sample:\n    class Document {\n\n        private readonly _onDidChange = new Emitter<(value:string)=>any>();\n\n        public onDidChange = this._onDidChange.event;\n\n        // getter-style\n        // get onDidChange(): Event<(value:string)=>any> {\n        // \treturn this._onDidChange.event;\n        // }\n\n        private _doIt() {\n            //...\n            this._onDidChange.fire(value);\n        }\n    }\n */\nexport class Emitter {\n    constructor(options) {\n        var _a, _b, _c, _d, _e;\n        this._size = 0;\n        this._options = options;\n        this._leakageMon = _globalLeakWarningThreshold > 0 || ((_a = this._options) === null || _a === void 0 ? void 0 : _a.leakWarningThreshold) ? new LeakageMonitor((_c = (_b = this._options) === null || _b === void 0 ? void 0 : _b.leakWarningThreshold) !== null && _c !== void 0 ? _c : _globalLeakWarningThreshold) : undefined;\n        this._perfMon = ((_d = this._options) === null || _d === void 0 ? void 0 : _d._profName) ? new EventProfiling(this._options._profName) : undefined;\n        this._deliveryQueue = (_e = this._options) === null || _e === void 0 ? void 0 : _e.deliveryQueue;\n    }\n    dispose() {\n        var _a, _b, _c, _d;\n        if (!this._disposed) {\n            this._disposed = true;\n            // It is bad to have listeners at the time of disposing an emitter, it is worst to have listeners keep the emitter\n            // alive via the reference that's embedded in their disposables. Therefore we loop over all remaining listeners and\n            // unset their subscriptions/disposables. Looping and blaming remaining listeners is done on next tick because the\n            // the following programming pattern is very popular:\n            //\n            // const someModel = this._disposables.add(new ModelObject()); // (1) create and register model\n            // this._disposables.add(someModel.onDidChange(() => { ... }); // (2) subscribe and register model-event listener\n            // ...later...\n            // this._disposables.dispose(); disposes (1) then (2): don't warn after (1) but after the \"overall dispose\" is done\n            if (((_a = this._deliveryQueue) === null || _a === void 0 ? void 0 : _a.current) === this) {\n                this._deliveryQueue.reset();\n            }\n            if (this._listeners) {\n                if (_enableDisposeWithListenerWarning) {\n                    const listeners = this._listeners;\n                    queueMicrotask(() => {\n                        forEachListener(listeners, l => { var _a; return (_a = l.stack) === null || _a === void 0 ? void 0 : _a.print(); });\n                    });\n                }\n                this._listeners = undefined;\n                this._size = 0;\n            }\n            (_c = (_b = this._options) === null || _b === void 0 ? void 0 : _b.onDidRemoveLastListener) === null || _c === void 0 ? void 0 : _c.call(_b);\n            (_d = this._leakageMon) === null || _d === void 0 ? void 0 : _d.dispose();\n        }\n    }\n    /**\n     * For the public to allow to subscribe\n     * to events from this Emitter\n     */\n    get event() {\n        var _a;\n        (_a = this._event) !== null && _a !== void 0 ? _a : (this._event = (callback, thisArgs, disposables) => {\n            var _a, _b, _c, _d, _e;\n            if (this._leakageMon && this._size > this._leakageMon.threshold * 3) {\n                console.warn(`[${this._leakageMon.name}] REFUSES to accept new listeners because it exceeded its threshold by far`);\n                return Disposable.None;\n            }\n            if (this._disposed) {\n                // todo: should we warn if a listener is added to a disposed emitter? This happens often\n                return Disposable.None;\n            }\n            if (thisArgs) {\n                callback = callback.bind(thisArgs);\n            }\n            const contained = new UniqueContainer(callback);\n            let removeMonitor;\n            let stack;\n            if (this._leakageMon && this._size >= Math.ceil(this._leakageMon.threshold * 0.2)) {\n                // check and record this emitter for potential leakage\n                contained.stack = Stacktrace.create();\n                removeMonitor = this._leakageMon.check(contained.stack, this._size + 1);\n            }\n            if (_enableDisposeWithListenerWarning) {\n                contained.stack = stack !== null && stack !== void 0 ? stack : Stacktrace.create();\n            }\n            if (!this._listeners) {\n                (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.onWillAddFirstListener) === null || _b === void 0 ? void 0 : _b.call(_a, this);\n                this._listeners = contained;\n                (_d = (_c = this._options) === null || _c === void 0 ? void 0 : _c.onDidAddFirstListener) === null || _d === void 0 ? void 0 : _d.call(_c, this);\n            }\n            else if (this._listeners instanceof UniqueContainer) {\n                (_e = this._deliveryQueue) !== null && _e !== void 0 ? _e : (this._deliveryQueue = new EventDeliveryQueuePrivate());\n                this._listeners = [this._listeners, contained];\n            }\n            else {\n                this._listeners.push(contained);\n            }\n            this._size++;\n            const result = toDisposable(() => { removeMonitor === null || removeMonitor === void 0 ? void 0 : removeMonitor(); this._removeListener(contained); });\n            if (disposables instanceof DisposableStore) {\n                disposables.add(result);\n            }\n            else if (Array.isArray(disposables)) {\n                disposables.push(result);\n            }\n            return result;\n        });\n        return this._event;\n    }\n    _removeListener(listener) {\n        var _a, _b, _c, _d;\n        (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.onWillRemoveListener) === null || _b === void 0 ? void 0 : _b.call(_a, this);\n        if (!this._listeners) {\n            return; // expected if a listener gets disposed\n        }\n        if (this._size === 1) {\n            this._listeners = undefined;\n            (_d = (_c = this._options) === null || _c === void 0 ? void 0 : _c.onDidRemoveLastListener) === null || _d === void 0 ? void 0 : _d.call(_c, this);\n            this._size = 0;\n            return;\n        }\n        // size > 1 which requires that listeners be a list:\n        const listeners = this._listeners;\n        const index = listeners.indexOf(listener);\n        if (index === -1) {\n            console.log('disposed?', this._disposed);\n            console.log('size?', this._size);\n            console.log('arr?', JSON.stringify(this._listeners));\n            throw new Error('Attempted to dispose unknown listener');\n        }\n        this._size--;\n        listeners[index] = undefined;\n        const adjustDeliveryQueue = this._deliveryQueue.current === this;\n        if (this._size * compactionThreshold <= listeners.length) {\n            let n = 0;\n            for (let i = 0; i < listeners.length; i++) {\n                if (listeners[i]) {\n                    listeners[n++] = listeners[i];\n                }\n                else if (adjustDeliveryQueue) {\n                    this._deliveryQueue.end--;\n                    if (n < this._deliveryQueue.i) {\n                        this._deliveryQueue.i--;\n                    }\n                }\n            }\n            listeners.length = n;\n        }\n    }\n    _deliver(listener, value) {\n        var _a;\n        if (!listener) {\n            return;\n        }\n        const errorHandler = ((_a = this._options) === null || _a === void 0 ? void 0 : _a.onListenerError) || onUnexpectedError;\n        if (!errorHandler) {\n            listener.value(value);\n            return;\n        }\n        try {\n            listener.value(value);\n        }\n        catch (e) {\n            errorHandler(e);\n        }\n    }\n    /** Delivers items in the queue. Assumes the queue is ready to go. */\n    _deliverQueue(dq) {\n        const listeners = dq.current._listeners;\n        while (dq.i < dq.end) {\n            // important: dq.i is incremented before calling deliver() because it might reenter deliverQueue()\n            this._deliver(listeners[dq.i++], dq.value);\n        }\n        dq.reset();\n    }\n    /**\n     * To be kept private to fire an event to\n     * subscribers\n     */\n    fire(event) {\n        var _a, _b, _c, _d;\n        if ((_a = this._deliveryQueue) === null || _a === void 0 ? void 0 : _a.current) {\n            this._deliverQueue(this._deliveryQueue);\n            (_b = this._perfMon) === null || _b === void 0 ? void 0 : _b.stop(); // last fire() will have starting perfmon, stop it before starting the next dispatch\n        }\n        (_c = this._perfMon) === null || _c === void 0 ? void 0 : _c.start(this._size);\n        if (!this._listeners) {\n            // no-op\n        }\n        else if (this._listeners instanceof UniqueContainer) {\n            this._deliver(this._listeners, event);\n        }\n        else {\n            const dq = this._deliveryQueue;\n            dq.enqueue(this, event, this._listeners.length);\n            this._deliverQueue(dq);\n        }\n        (_d = this._perfMon) === null || _d === void 0 ? void 0 : _d.stop();\n    }\n    hasListeners() {\n        return this._size > 0;\n    }\n}\nexport const createEventDeliveryQueue = () => new EventDeliveryQueuePrivate();\nclass EventDeliveryQueuePrivate {\n    constructor() {\n        /**\n         * Index in current's listener list.\n         */\n        this.i = -1;\n        /**\n         * The last index in the listener's list to deliver.\n         */\n        this.end = 0;\n    }\n    enqueue(emitter, value, end) {\n        this.i = 0;\n        this.end = end;\n        this.current = emitter;\n        this.value = value;\n    }\n    reset() {\n        this.i = this.end; // force any current emission loop to stop, mainly for during dispose\n        this.current = undefined;\n        this.value = undefined;\n    }\n}\nexport class PauseableEmitter extends Emitter {\n    constructor(options) {\n        super(options);\n        this._isPaused = 0;\n        this._eventQueue = new LinkedList();\n        this._mergeFn = options === null || options === void 0 ? void 0 : options.merge;\n    }\n    pause() {\n        this._isPaused++;\n    }\n    resume() {\n        if (this._isPaused !== 0 && --this._isPaused === 0) {\n            if (this._mergeFn) {\n                // use the merge function to create a single composite\n                // event. make a copy in case firing pauses this emitter\n                if (this._eventQueue.size > 0) {\n                    const events = Array.from(this._eventQueue);\n                    this._eventQueue.clear();\n                    super.fire(this._mergeFn(events));\n                }\n            }\n            else {\n                // no merging, fire each event individually and test\n                // that this emitter isn't paused halfway through\n                while (!this._isPaused && this._eventQueue.size !== 0) {\n                    super.fire(this._eventQueue.shift());\n                }\n            }\n        }\n    }\n    fire(event) {\n        if (this._size) {\n            if (this._isPaused !== 0) {\n                this._eventQueue.push(event);\n            }\n            else {\n                super.fire(event);\n            }\n        }\n    }\n}\nexport class DebounceEmitter extends PauseableEmitter {\n    constructor(options) {\n        var _a;\n        super(options);\n        this._delay = (_a = options.delay) !== null && _a !== void 0 ? _a : 100;\n    }\n    fire(event) {\n        if (!this._handle) {\n            this.pause();\n            this._handle = setTimeout(() => {\n                this._handle = undefined;\n                this.resume();\n            }, this._delay);\n        }\n        super.fire(event);\n    }\n}\n/**\n * An emitter which queue all events and then process them at the\n * end of the event loop.\n */\nexport class MicrotaskEmitter extends Emitter {\n    constructor(options) {\n        super(options);\n        this._queuedEvents = [];\n        this._mergeFn = options === null || options === void 0 ? void 0 : options.merge;\n    }\n    fire(event) {\n        if (!this.hasListeners()) {\n            return;\n        }\n        this._queuedEvents.push(event);\n        if (this._queuedEvents.length === 1) {\n            queueMicrotask(() => {\n                if (this._mergeFn) {\n                    super.fire(this._mergeFn(this._queuedEvents));\n                }\n                else {\n                    this._queuedEvents.forEach(e => super.fire(e));\n                }\n                this._queuedEvents = [];\n            });\n        }\n    }\n}\nexport class EventMultiplexer {\n    constructor() {\n        this.hasListeners = false;\n        this.events = [];\n        this.emitter = new Emitter({\n            onWillAddFirstListener: () => this.onFirstListenerAdd(),\n            onDidRemoveLastListener: () => this.onLastListenerRemove()\n        });\n    }\n    get event() {\n        return this.emitter.event;\n    }\n    add(event) {\n        const e = { event: event, listener: null };\n        this.events.push(e);\n        if (this.hasListeners) {\n            this.hook(e);\n        }\n        const dispose = () => {\n            if (this.hasListeners) {\n                this.unhook(e);\n            }\n            const idx = this.events.indexOf(e);\n            this.events.splice(idx, 1);\n        };\n        return toDisposable(onceFn(dispose));\n    }\n    onFirstListenerAdd() {\n        this.hasListeners = true;\n        this.events.forEach(e => this.hook(e));\n    }\n    onLastListenerRemove() {\n        this.hasListeners = false;\n        this.events.forEach(e => this.unhook(e));\n    }\n    hook(e) {\n        e.listener = e.event(r => this.emitter.fire(r));\n    }\n    unhook(e) {\n        if (e.listener) {\n            e.listener.dispose();\n        }\n        e.listener = null;\n    }\n    dispose() {\n        this.emitter.dispose();\n    }\n}\n/**\n * The EventBufferer is useful in situations in which you want\n * to delay firing your events during some code.\n * You can wrap that code and be sure that the event will not\n * be fired during that wrap.\n *\n * ```\n * const emitter: Emitter;\n * const delayer = new EventDelayer();\n * const delayedEvent = delayer.wrapEvent(emitter.event);\n *\n * delayedEvent(console.log);\n *\n * delayer.bufferEvents(() => {\n *   emitter.fire(); // event will not be fired yet\n * });\n *\n * // event will only be fired at this point\n * ```\n */\nexport class EventBufferer {\n    constructor() {\n        this.buffers = [];\n    }\n    wrapEvent(event) {\n        return (listener, thisArgs, disposables) => {\n            return event(i => {\n                const buffer = this.buffers[this.buffers.length - 1];\n                if (buffer) {\n                    buffer.push(() => listener.call(thisArgs, i));\n                }\n                else {\n                    listener.call(thisArgs, i);\n                }\n            }, undefined, disposables);\n        };\n    }\n    bufferEvents(fn) {\n        const buffer = [];\n        this.buffers.push(buffer);\n        const r = fn();\n        this.buffers.pop();\n        buffer.forEach(flush => flush());\n        return r;\n    }\n}\n/**\n * A Relay is an event forwarder which functions as a replugabble event pipe.\n * Once created, you can connect an input event to it and it will simply forward\n * events from that input event through its own `event` property. The `input`\n * can be changed at any point in time.\n */\nexport class Relay {\n    constructor() {\n        this.listening = false;\n        this.inputEvent = Event.None;\n        this.inputEventListener = Disposable.None;\n        this.emitter = new Emitter({\n            onDidAddFirstListener: () => {\n                this.listening = true;\n                this.inputEventListener = this.inputEvent(this.emitter.fire, this.emitter);\n            },\n            onDidRemoveLastListener: () => {\n                this.listening = false;\n                this.inputEventListener.dispose();\n            }\n        });\n        this.event = this.emitter.event;\n    }\n    set input(event) {\n        this.inputEvent = event;\n        if (this.listening) {\n            this.inputEventListener.dispose();\n            this.inputEventListener = event(this.emitter.fire, this.emitter);\n        }\n    }\n    dispose() {\n        this.inputEventListener.dispose();\n        this.emitter.dispose();\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import Point from './Point.js';\nimport { createIntersectContext } from './BoundingRect.js';\nvar mathMin = Math.min;\nvar mathMax = Math.max;\nvar mathAbs = Math.abs;\nvar _extent = [0, 0];\nvar _extent2 = [0, 0];\nvar _intersectCtx = createIntersectContext();\nvar _minTv = _intersectCtx.minTv;\nvar _maxTv = _intersectCtx.maxTv;\nvar OrientedBoundingRect = function () {\n  function OrientedBoundingRect(rect, transform) {\n    this._corners = [];\n    this._axes = [];\n    this._origin = [0, 0];\n    for (var i = 0; i < 4; i++) {\n      this._corners[i] = new Point();\n    }\n    for (var i = 0; i < 2; i++) {\n      this._axes[i] = new Point();\n    }\n    if (rect) {\n      this.fromBoundingRect(rect, transform);\n    }\n  }\n  OrientedBoundingRect.prototype.fromBoundingRect = function (rect, transform) {\n    var corners = this._corners;\n    var axes = this._axes;\n    var x = rect.x;\n    var y = rect.y;\n    var x2 = x + rect.width;\n    var y2 = y + rect.height;\n    corners[0].set(x, y);\n    corners[1].set(x2, y);\n    corners[2].set(x2, y2);\n    corners[3].set(x, y2);\n    if (transform) {\n      for (var i = 0; i < 4; i++) {\n        corners[i].transform(transform);\n      }\n    }\n    Point.sub(axes[0], corners[1], corners[0]);\n    Point.sub(axes[1], corners[3], corners[0]);\n    axes[0].normalize();\n    axes[1].normalize();\n    for (var i = 0; i < 2; i++) {\n      this._origin[i] = axes[i].dot(corners[0]);\n    }\n  };\n  OrientedBoundingRect.prototype.intersect = function (other, mtv, opt) {\n    var overlapped = true;\n    var noMtv = !mtv;\n    if (mtv) {\n      Point.set(mtv, 0, 0);\n    }\n    _intersectCtx.reset(opt, !noMtv);\n    if (!this._intersectCheckOneSide(this, other, noMtv, 1)) {\n      overlapped = false;\n      if (noMtv) {\n        return overlapped;\n      }\n    }\n    if (!this._intersectCheckOneSide(other, this, noMtv, -1)) {\n      overlapped = false;\n      if (noMtv) {\n        return overlapped;\n      }\n    }\n    if (!noMtv && !_intersectCtx.negativeSize) {\n      Point.copy(mtv, overlapped ? _intersectCtx.useDir ? _intersectCtx.dirMinTv : _minTv : _maxTv);\n    }\n    return overlapped;\n  };\n  OrientedBoundingRect.prototype._intersectCheckOneSide = function (self, other, noMtv, inverse) {\n    var overlapped = true;\n    for (var i = 0; i < 2; i++) {\n      var axis = self._axes[i];\n      self._getProjMinMaxOnAxis(i, self._corners, _extent);\n      self._getProjMinMaxOnAxis(i, other._corners, _extent2);\n      if (_intersectCtx.negativeSize || _extent[1] < _extent2[0] || _extent[0] > _extent2[1]) {\n        overlapped = false;\n        if (_intersectCtx.negativeSize || noMtv) {\n          return overlapped;\n        }\n        var dist0 = mathAbs(_extent2[0] - _extent[1]);\n        var dist1 = mathAbs(_extent[0] - _extent2[1]);\n        if (mathMin(dist0, dist1) > _maxTv.len()) {\n          if (dist0 < dist1) {\n            Point.scale(_maxTv, axis, -dist0 * inverse);\n          } else {\n            Point.scale(_maxTv, axis, dist1 * inverse);\n          }\n        }\n      } else if (!noMtv) {\n        var dist0 = mathAbs(_extent2[0] - _extent[1]);\n        var dist1 = mathAbs(_extent[0] - _extent2[1]);\n        if (_intersectCtx.useDir || mathMin(dist0, dist1) < _minTv.len()) {\n          if (dist0 < dist1 || !_intersectCtx.bidirectional) {\n            Point.scale(_minTv, axis, dist0 * inverse);\n            if (_intersectCtx.useDir) {\n              _intersectCtx.calcDirMTV();\n            }\n          }\n          if (dist0 >= dist1 || !_intersectCtx.bidirectional) {\n            Point.scale(_minTv, axis, -dist1 * inverse);\n            if (_intersectCtx.useDir) {\n              _intersectCtx.calcDirMTV();\n            }\n          }\n        }\n      }\n    }\n    return overlapped;\n  };\n  OrientedBoundingRect.prototype._getProjMinMaxOnAxis = function (dim, corners, out) {\n    var axis = this._axes[dim];\n    var origin = this._origin;\n    var proj = corners[0].dot(axis) + origin[dim];\n    var min = proj;\n    var max = proj;\n    for (var i = 1; i < corners.length; i++) {\n      var proj_1 = corners[i].dot(axis) + origin[dim];\n      min = mathMin(proj_1, min);\n      max = mathMax(proj_1, max);\n    }\n    out[0] = min + _intersectCtx.touchThreshold;\n    out[1] = max - _intersectCtx.touchThreshold;\n    _intersectCtx.negativeSize = out[1] < out[0];\n  };\n  return OrientedBoundingRect;\n}();\nexport default OrientedBoundingRect;","map":{"version":3,"names":["Point","createIntersectContext","mathMin","Math","min","mathMax","max","mathAbs","abs","_extent","_extent2","_intersectCtx","_minTv","minTv","_maxTv","maxTv","OrientedBoundingRect","rect","transform","_corners","_axes","_origin","i","fromBoundingRect","prototype","corners","axes","x","y","x2","width","y2","height","set","sub","normalize","dot","intersect","other","mtv","opt","overlapped","noMtv","reset","_intersectCheckOneSide","negativeSize","copy","useDir","dirMinTv","self","inverse","axis","_getProjMinMaxOnAxis","dist0","dist1","len","scale","bidirectional","calcDirMTV","dim","out","origin","proj","length","proj_1","touchThreshold"],"sources":["D:/code/java/program/oj/code/yuoj-frontend-master/node_modules/zrender/lib/core/OrientedBoundingRect.js"],"sourcesContent":["import Point from './Point.js';\nimport { createIntersectContext } from './BoundingRect.js';\nvar mathMin = Math.min;\nvar mathMax = Math.max;\nvar mathAbs = Math.abs;\nvar _extent = [0, 0];\nvar _extent2 = [0, 0];\nvar _intersectCtx = createIntersectContext();\nvar _minTv = _intersectCtx.minTv;\nvar _maxTv = _intersectCtx.maxTv;\nvar OrientedBoundingRect = (function () {\n    function OrientedBoundingRect(rect, transform) {\n        this._corners = [];\n        this._axes = [];\n        this._origin = [0, 0];\n        for (var i = 0; i < 4; i++) {\n            this._corners[i] = new Point();\n        }\n        for (var i = 0; i < 2; i++) {\n            this._axes[i] = new Point();\n        }\n        if (rect) {\n            this.fromBoundingRect(rect, transform);\n        }\n    }\n    OrientedBoundingRect.prototype.fromBoundingRect = function (rect, transform) {\n        var corners = this._corners;\n        var axes = this._axes;\n        var x = rect.x;\n        var y = rect.y;\n        var x2 = x + rect.width;\n        var y2 = y + rect.height;\n        corners[0].set(x, y);\n        corners[1].set(x2, y);\n        corners[2].set(x2, y2);\n        corners[3].set(x, y2);\n        if (transform) {\n            for (var i = 0; i < 4; i++) {\n                corners[i].transform(transform);\n            }\n        }\n        Point.sub(axes[0], corners[1], corners[0]);\n        Point.sub(axes[1], corners[3], corners[0]);\n        axes[0].normalize();\n        axes[1].normalize();\n        for (var i = 0; i < 2; i++) {\n            this._origin[i] = axes[i].dot(corners[0]);\n        }\n    };\n    OrientedBoundingRect.prototype.intersect = function (other, mtv, opt) {\n        var overlapped = true;\n        var noMtv = !mtv;\n        if (mtv) {\n            Point.set(mtv, 0, 0);\n        }\n        _intersectCtx.reset(opt, !noMtv);\n        if (!this._intersectCheckOneSide(this, other, noMtv, 1)) {\n            overlapped = false;\n            if (noMtv) {\n                return overlapped;\n            }\n        }\n        if (!this._intersectCheckOneSide(other, this, noMtv, -1)) {\n            overlapped = false;\n            if (noMtv) {\n                return overlapped;\n            }\n        }\n        if (!noMtv && !_intersectCtx.negativeSize) {\n            Point.copy(mtv, overlapped\n                ? (_intersectCtx.useDir ? _intersectCtx.dirMinTv : _minTv)\n                : _maxTv);\n        }\n        return overlapped;\n    };\n    OrientedBoundingRect.prototype._intersectCheckOneSide = function (self, other, noMtv, inverse) {\n        var overlapped = true;\n        for (var i = 0; i < 2; i++) {\n            var axis = self._axes[i];\n            self._getProjMinMaxOnAxis(i, self._corners, _extent);\n            self._getProjMinMaxOnAxis(i, other._corners, _extent2);\n            if (_intersectCtx.negativeSize || _extent[1] < _extent2[0] || _extent[0] > _extent2[1]) {\n                overlapped = false;\n                if (_intersectCtx.negativeSize || noMtv) {\n                    return overlapped;\n                }\n                var dist0 = mathAbs(_extent2[0] - _extent[1]);\n                var dist1 = mathAbs(_extent[0] - _extent2[1]);\n                if (mathMin(dist0, dist1) > _maxTv.len()) {\n                    if (dist0 < dist1) {\n                        Point.scale(_maxTv, axis, -dist0 * inverse);\n                    }\n                    else {\n                        Point.scale(_maxTv, axis, dist1 * inverse);\n                    }\n                }\n            }\n            else if (!noMtv) {\n                var dist0 = mathAbs(_extent2[0] - _extent[1]);\n                var dist1 = mathAbs(_extent[0] - _extent2[1]);\n                if (_intersectCtx.useDir || mathMin(dist0, dist1) < _minTv.len()) {\n                    if (dist0 < dist1 || !_intersectCtx.bidirectional) {\n                        Point.scale(_minTv, axis, dist0 * inverse);\n                        if (_intersectCtx.useDir) {\n                            _intersectCtx.calcDirMTV();\n                        }\n                    }\n                    if (dist0 >= dist1 || !_intersectCtx.bidirectional) {\n                        Point.scale(_minTv, axis, -dist1 * inverse);\n                        if (_intersectCtx.useDir) {\n                            _intersectCtx.calcDirMTV();\n                        }\n                    }\n                }\n            }\n        }\n        return overlapped;\n    };\n    OrientedBoundingRect.prototype._getProjMinMaxOnAxis = function (dim, corners, out) {\n        var axis = this._axes[dim];\n        var origin = this._origin;\n        var proj = corners[0].dot(axis) + origin[dim];\n        var min = proj;\n        var max = proj;\n        for (var i = 1; i < corners.length; i++) {\n            var proj_1 = corners[i].dot(axis) + origin[dim];\n            min = mathMin(proj_1, min);\n            max = mathMax(proj_1, max);\n        }\n        out[0] = min + _intersectCtx.touchThreshold;\n        out[1] = max - _intersectCtx.touchThreshold;\n        _intersectCtx.negativeSize = out[1] < out[0];\n    };\n    return OrientedBoundingRect;\n}());\nexport default OrientedBoundingRect;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
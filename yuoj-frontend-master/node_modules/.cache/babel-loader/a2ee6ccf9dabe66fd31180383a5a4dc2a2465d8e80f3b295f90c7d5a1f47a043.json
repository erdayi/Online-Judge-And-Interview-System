{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar _a, _b, _c, _d;\n// TODO\n// ??? refactor? check the outer usage of data provider.\n// merge with defaultDimValueGetter?\nimport { isTypedArray, extend, assert, each, isObject, bind, isArray } from 'zrender/lib/core/util.js';\nimport { getDataItemValue } from '../../util/model.js';\nimport { createSourceFromSeriesDataOption, isSourceInstance } from '../Source.js';\nimport { SOURCE_FORMAT_ORIGINAL, SOURCE_FORMAT_OBJECT_ROWS, SOURCE_FORMAT_KEYED_COLUMNS, SOURCE_FORMAT_TYPED_ARRAY, SOURCE_FORMAT_ARRAY_ROWS, SERIES_LAYOUT_BY_COLUMN, SERIES_LAYOUT_BY_ROW } from '../../util/types.js';\nimport { error } from '../../util/log.js';\nvar providerMethods;\nvar mountMethods;\n/**\n * If normal array used, mutable chunk size is supported.\n * If typed array used, chunk size must be fixed.\n */\nvar DefaultDataProvider = /** @class */function () {\n  function DefaultDataProvider(sourceParam, dimSize) {\n    // let source: Source;\n    var source = !isSourceInstance(sourceParam) ? createSourceFromSeriesDataOption(sourceParam) : sourceParam;\n    // declare source is Source;\n    this._source = source;\n    var data = this._data = source.data;\n    var sourceFormat = source.sourceFormat;\n    var seriesLayoutBy = source.seriesLayoutBy;\n    // Typed array. TODO IE10+?\n    if (sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (dimSize == null) {\n          throw new Error('Typed array data must specify dimension size');\n        }\n      }\n      this._offset = 0;\n      this._dimSize = dimSize;\n      this._data = data;\n    }\n    if (process.env.NODE_ENV !== 'production') {\n      var validator = rawSourceDataValidatorMap[getMethodMapKey(sourceFormat, seriesLayoutBy)];\n      validator && validator(data, source.dimensionsDefine);\n    }\n    mountMethods(this, data, source);\n  }\n  DefaultDataProvider.prototype.getSource = function () {\n    return this._source;\n  };\n  DefaultDataProvider.prototype.count = function () {\n    return 0;\n  };\n  DefaultDataProvider.prototype.getItem = function (idx, out) {\n    return;\n  };\n  DefaultDataProvider.prototype.appendData = function (newData) {};\n  DefaultDataProvider.prototype.clean = function () {};\n  DefaultDataProvider.protoInitialize = function () {\n    // PENDING: To avoid potential incompat (e.g., prototype\n    // is visited somewhere), still init them on prototype.\n    var proto = DefaultDataProvider.prototype;\n    proto.pure = false;\n    proto.persistent = true;\n  }();\n  DefaultDataProvider.internalField = function () {\n    var _a;\n    mountMethods = function (provider, data, source) {\n      var sourceFormat = source.sourceFormat;\n      var seriesLayoutBy = source.seriesLayoutBy;\n      var startIndex = source.startIndex;\n      var dimsDef = source.dimensionsDefine;\n      var methods = providerMethods[getMethodMapKey(sourceFormat, seriesLayoutBy)];\n      if (process.env.NODE_ENV !== 'production') {\n        assert(methods, 'Invalide sourceFormat: ' + sourceFormat);\n      }\n      extend(provider, methods);\n      if (sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {\n        provider.getItem = getItemForTypedArray;\n        provider.count = countForTypedArray;\n        provider.fillStorage = fillStorageForTypedArray;\n      } else {\n        var rawItemGetter = getRawSourceItemGetter(sourceFormat, seriesLayoutBy);\n        provider.getItem = bind(rawItemGetter, null, data, startIndex, dimsDef);\n        var rawCounter = getRawSourceDataCounter(sourceFormat, seriesLayoutBy);\n        provider.count = bind(rawCounter, null, data, startIndex, dimsDef);\n      }\n    };\n    var getItemForTypedArray = function (idx, out) {\n      idx = idx - this._offset;\n      out = out || [];\n      var data = this._data;\n      var dimSize = this._dimSize;\n      var offset = dimSize * idx;\n      for (var i = 0; i < dimSize; i++) {\n        out[i] = data[offset + i];\n      }\n      return out;\n    };\n    var fillStorageForTypedArray = function (start, end, storage, extent) {\n      var data = this._data;\n      var dimSize = this._dimSize;\n      for (var dim = 0; dim < dimSize; dim++) {\n        var dimExtent = extent[dim];\n        var min = dimExtent[0] == null ? Infinity : dimExtent[0];\n        var max = dimExtent[1] == null ? -Infinity : dimExtent[1];\n        var count = end - start;\n        var arr = storage[dim];\n        for (var i = 0; i < count; i++) {\n          // appendData with TypedArray will always do replace in provider.\n          var val = data[i * dimSize + dim];\n          arr[start + i] = val;\n          val < min && (min = val);\n          val > max && (max = val);\n        }\n        dimExtent[0] = min;\n        dimExtent[1] = max;\n      }\n    };\n    var countForTypedArray = function () {\n      return this._data ? this._data.length / this._dimSize : 0;\n    };\n    providerMethods = (_a = {}, _a[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_COLUMN] = {\n      pure: true,\n      appendData: appendDataSimply\n    }, _a[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_ROW] = {\n      pure: true,\n      appendData: function () {\n        throw new Error('Do not support appendData when set seriesLayoutBy: \"row\".');\n      }\n    }, _a[SOURCE_FORMAT_OBJECT_ROWS] = {\n      pure: true,\n      appendData: appendDataSimply\n    }, _a[SOURCE_FORMAT_KEYED_COLUMNS] = {\n      pure: true,\n      appendData: function (newData) {\n        var data = this._data;\n        each(newData, function (newCol, key) {\n          var oldCol = data[key] || (data[key] = []);\n          for (var i = 0; i < (newCol || []).length; i++) {\n            oldCol.push(newCol[i]);\n          }\n        });\n      }\n    }, _a[SOURCE_FORMAT_ORIGINAL] = {\n      appendData: appendDataSimply\n    }, _a[SOURCE_FORMAT_TYPED_ARRAY] = {\n      persistent: false,\n      pure: true,\n      appendData: function (newData) {\n        if (process.env.NODE_ENV !== 'production') {\n          assert(isTypedArray(newData), 'Added data must be TypedArray if data in initialization is TypedArray');\n        }\n        this._data = newData;\n      },\n      // Clean self if data is already used.\n      clean: function () {\n        // PENDING\n        this._offset += this.count();\n        this._data = null;\n      }\n    }, _a);\n    function appendDataSimply(newData) {\n      for (var i = 0; i < newData.length; i++) {\n        this._data.push(newData[i]);\n      }\n    }\n  }();\n  return DefaultDataProvider;\n}();\nexport { DefaultDataProvider };\nvar validateSimply = function (rawData) {\n  if (!isArray(rawData)) {\n    error('series.data or dataset.source must be an array.');\n  }\n};\n/**\n * Only run in dev mode - hint users for debug.\n */\nvar rawSourceDataValidatorMap = (_a = {}, _a[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_COLUMN] = validateSimply, _a[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_ROW] = validateSimply, _a[SOURCE_FORMAT_OBJECT_ROWS] = validateSimply, _a[SOURCE_FORMAT_KEYED_COLUMNS] = function (rawData, dimsDef) {\n  for (var i = 0; i < dimsDef.length; i++) {\n    var dimName = dimsDef[i].name;\n    if (dimName == null) {\n      error('dimension name must not be null/undefined.');\n    }\n  }\n}, _a[SOURCE_FORMAT_ORIGINAL] = validateSimply, _a);\nvar getItemSimply = function (rawData, startIndex, dimsDef, idx) {\n  return rawData[idx];\n};\nvar rawSourceItemGetterMap = (_b = {}, _b[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_COLUMN] = function (rawData, startIndex, dimsDef, idx) {\n  return rawData[idx + startIndex];\n}, _b[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_ROW] = function (rawData, startIndex, dimsDef, idx, out) {\n  idx += startIndex;\n  var item = out || [];\n  var data = rawData;\n  for (var i = 0; i < data.length; i++) {\n    var row = data[i];\n    item[i] = row ? row[idx] : null;\n  }\n  return item;\n}, _b[SOURCE_FORMAT_OBJECT_ROWS] = getItemSimply, _b[SOURCE_FORMAT_KEYED_COLUMNS] = function (rawData, startIndex, dimsDef, idx, out) {\n  var item = out || [];\n  for (var i = 0; i < dimsDef.length; i++) {\n    var dimName = dimsDef[i].name;\n    var col = dimName != null ? rawData[dimName] : null;\n    item[i] = col ? col[idx] : null;\n  }\n  return item;\n}, _b[SOURCE_FORMAT_ORIGINAL] = getItemSimply, _b);\nexport function getRawSourceItemGetter(sourceFormat, seriesLayoutBy) {\n  var method = rawSourceItemGetterMap[getMethodMapKey(sourceFormat, seriesLayoutBy)];\n  if (process.env.NODE_ENV !== 'production') {\n    assert(method, 'Do not support get item on \"' + sourceFormat + '\", \"' + seriesLayoutBy + '\".');\n  }\n  return method;\n}\nvar countSimply = function (rawData, startIndex, dimsDef) {\n  return rawData.length;\n};\nvar rawSourceDataCounterMap = (_c = {}, _c[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_COLUMN] = function (rawData, startIndex, dimsDef) {\n  return Math.max(0, rawData.length - startIndex);\n}, _c[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_ROW] = function (rawData, startIndex, dimsDef) {\n  var row = rawData[0];\n  return row ? Math.max(0, row.length - startIndex) : 0;\n}, _c[SOURCE_FORMAT_OBJECT_ROWS] = countSimply, _c[SOURCE_FORMAT_KEYED_COLUMNS] = function (rawData, startIndex, dimsDef) {\n  var dimName = dimsDef[0].name;\n  var col = dimName != null ? rawData[dimName] : null;\n  return col ? col.length : 0;\n}, _c[SOURCE_FORMAT_ORIGINAL] = countSimply, _c);\nexport function getRawSourceDataCounter(sourceFormat, seriesLayoutBy) {\n  var method = rawSourceDataCounterMap[getMethodMapKey(sourceFormat, seriesLayoutBy)];\n  if (process.env.NODE_ENV !== 'production') {\n    assert(method, 'Do not support count on \"' + sourceFormat + '\", \"' + seriesLayoutBy + '\".');\n  }\n  return method;\n}\nvar getRawValueSimply = function (dataItem, dimIndex, property) {\n  return dataItem[dimIndex];\n};\nvar rawSourceValueGetterMap = (_d = {}, _d[SOURCE_FORMAT_ARRAY_ROWS] = getRawValueSimply, _d[SOURCE_FORMAT_OBJECT_ROWS] = function (dataItem, dimIndex, property) {\n  return dataItem[property];\n}, _d[SOURCE_FORMAT_KEYED_COLUMNS] = getRawValueSimply, _d[SOURCE_FORMAT_ORIGINAL] = function (dataItem, dimIndex, property) {\n  // FIXME: In some case (markpoint in geo (geo-map.html)),\n  // dataItem is {coord: [...]}\n  var value = getDataItemValue(dataItem);\n  return !(value instanceof Array) ? value : value[dimIndex];\n}, _d[SOURCE_FORMAT_TYPED_ARRAY] = getRawValueSimply, _d);\nexport function getRawSourceValueGetter(sourceFormat) {\n  var method = rawSourceValueGetterMap[sourceFormat];\n  if (process.env.NODE_ENV !== 'production') {\n    assert(method, 'Do not support get value on \"' + sourceFormat + '\".');\n  }\n  return method;\n}\nfunction getMethodMapKey(sourceFormat, seriesLayoutBy) {\n  return sourceFormat === SOURCE_FORMAT_ARRAY_ROWS ? sourceFormat + '_' + seriesLayoutBy : sourceFormat;\n}\n// ??? FIXME can these logic be more neat: getRawValue, getRawDataItem,\n// Consider persistent.\n// Caution: why use raw value to display on label or tooltip?\n// A reason is to avoid format. For example time value we do not know\n// how to format is expected. More over, if stack is used, calculated\n// value may be 0.91000000001, which have brings trouble to display.\n// TODO: consider how to treat null/undefined/NaN when display?\nexport function retrieveRawValue(data, dataIndex,\n// If dimIndex is null/undefined, return OptionDataItem.\n// Otherwise, return OptionDataValue.\ndim) {\n  if (!data) {\n    return;\n  }\n  // Consider data may be not persistent.\n  var dataItem = data.getRawDataItem(dataIndex);\n  if (dataItem == null) {\n    return;\n  }\n  var store = data.getStore();\n  var sourceFormat = store.getSource().sourceFormat;\n  if (dim != null) {\n    var dimIndex = data.getDimensionIndex(dim);\n    var property = store.getDimensionProperty(dimIndex);\n    return getRawSourceValueGetter(sourceFormat)(dataItem, dimIndex, property);\n  } else {\n    var result = dataItem;\n    if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {\n      result = getDataItemValue(dataItem);\n    }\n    return result;\n  }\n}\n/**\n * Compatible with some cases (in pie, map) like:\n * data: [{name: 'xx', value: 5, selected: true}, ...]\n * where only sourceFormat is 'original' and 'objectRows' supported.\n *\n * // TODO\n * Supported detail options in data item when using 'arrayRows'.\n *\n * @param data\n * @param dataIndex\n * @param attr like 'selected'\n */\nexport function retrieveRawAttr(data, dataIndex, attr) {\n  if (!data) {\n    return;\n  }\n  var sourceFormat = data.getStore().getSource().sourceFormat;\n  if (sourceFormat !== SOURCE_FORMAT_ORIGINAL && sourceFormat !== SOURCE_FORMAT_OBJECT_ROWS) {\n    return;\n  }\n  var dataItem = data.getRawDataItem(dataIndex);\n  if (sourceFormat === SOURCE_FORMAT_ORIGINAL && !isObject(dataItem)) {\n    dataItem = null;\n  }\n  if (dataItem) {\n    return dataItem[attr];\n  }\n}","map":{"version":3,"names":["_a","_b","_c","_d","isTypedArray","extend","assert","each","isObject","bind","isArray","getDataItemValue","createSourceFromSeriesDataOption","isSourceInstance","SOURCE_FORMAT_ORIGINAL","SOURCE_FORMAT_OBJECT_ROWS","SOURCE_FORMAT_KEYED_COLUMNS","SOURCE_FORMAT_TYPED_ARRAY","SOURCE_FORMAT_ARRAY_ROWS","SERIES_LAYOUT_BY_COLUMN","SERIES_LAYOUT_BY_ROW","error","providerMethods","mountMethods","DefaultDataProvider","sourceParam","dimSize","source","_source","data","_data","sourceFormat","seriesLayoutBy","process","env","NODE_ENV","Error","_offset","_dimSize","validator","rawSourceDataValidatorMap","getMethodMapKey","dimensionsDefine","prototype","getSource","count","getItem","idx","out","appendData","newData","clean","protoInitialize","proto","pure","persistent","internalField","provider","startIndex","dimsDef","methods","getItemForTypedArray","countForTypedArray","fillStorage","fillStorageForTypedArray","rawItemGetter","getRawSourceItemGetter","rawCounter","getRawSourceDataCounter","offset","i","start","end","storage","extent","dim","dimExtent","min","Infinity","max","arr","val","length","appendDataSimply","newCol","key","oldCol","push","validateSimply","rawData","dimName","name","getItemSimply","rawSourceItemGetterMap","item","row","col","method","countSimply","rawSourceDataCounterMap","Math","getRawValueSimply","dataItem","dimIndex","property","rawSourceValueGetterMap","value","Array","getRawSourceValueGetter","retrieveRawValue","dataIndex","getRawDataItem","store","getStore","getDimensionIndex","getDimensionProperty","result","retrieveRawAttr","attr"],"sources":["D:/code/java/program/oj/code/yuoj-frontend-master/node_modules/echarts/lib/data/helper/dataProvider.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar _a, _b, _c, _d;\n// TODO\n// ??? refactor? check the outer usage of data provider.\n// merge with defaultDimValueGetter?\nimport { isTypedArray, extend, assert, each, isObject, bind, isArray } from 'zrender/lib/core/util.js';\nimport { getDataItemValue } from '../../util/model.js';\nimport { createSourceFromSeriesDataOption, isSourceInstance } from '../Source.js';\nimport { SOURCE_FORMAT_ORIGINAL, SOURCE_FORMAT_OBJECT_ROWS, SOURCE_FORMAT_KEYED_COLUMNS, SOURCE_FORMAT_TYPED_ARRAY, SOURCE_FORMAT_ARRAY_ROWS, SERIES_LAYOUT_BY_COLUMN, SERIES_LAYOUT_BY_ROW } from '../../util/types.js';\nimport { error } from '../../util/log.js';\nvar providerMethods;\nvar mountMethods;\n/**\n * If normal array used, mutable chunk size is supported.\n * If typed array used, chunk size must be fixed.\n */\nvar DefaultDataProvider = /** @class */function () {\n  function DefaultDataProvider(sourceParam, dimSize) {\n    // let source: Source;\n    var source = !isSourceInstance(sourceParam) ? createSourceFromSeriesDataOption(sourceParam) : sourceParam;\n    // declare source is Source;\n    this._source = source;\n    var data = this._data = source.data;\n    var sourceFormat = source.sourceFormat;\n    var seriesLayoutBy = source.seriesLayoutBy;\n    // Typed array. TODO IE10+?\n    if (sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (dimSize == null) {\n          throw new Error('Typed array data must specify dimension size');\n        }\n      }\n      this._offset = 0;\n      this._dimSize = dimSize;\n      this._data = data;\n    }\n    if (process.env.NODE_ENV !== 'production') {\n      var validator = rawSourceDataValidatorMap[getMethodMapKey(sourceFormat, seriesLayoutBy)];\n      validator && validator(data, source.dimensionsDefine);\n    }\n    mountMethods(this, data, source);\n  }\n  DefaultDataProvider.prototype.getSource = function () {\n    return this._source;\n  };\n  DefaultDataProvider.prototype.count = function () {\n    return 0;\n  };\n  DefaultDataProvider.prototype.getItem = function (idx, out) {\n    return;\n  };\n  DefaultDataProvider.prototype.appendData = function (newData) {};\n  DefaultDataProvider.prototype.clean = function () {};\n  DefaultDataProvider.protoInitialize = function () {\n    // PENDING: To avoid potential incompat (e.g., prototype\n    // is visited somewhere), still init them on prototype.\n    var proto = DefaultDataProvider.prototype;\n    proto.pure = false;\n    proto.persistent = true;\n  }();\n  DefaultDataProvider.internalField = function () {\n    var _a;\n    mountMethods = function (provider, data, source) {\n      var sourceFormat = source.sourceFormat;\n      var seriesLayoutBy = source.seriesLayoutBy;\n      var startIndex = source.startIndex;\n      var dimsDef = source.dimensionsDefine;\n      var methods = providerMethods[getMethodMapKey(sourceFormat, seriesLayoutBy)];\n      if (process.env.NODE_ENV !== 'production') {\n        assert(methods, 'Invalide sourceFormat: ' + sourceFormat);\n      }\n      extend(provider, methods);\n      if (sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {\n        provider.getItem = getItemForTypedArray;\n        provider.count = countForTypedArray;\n        provider.fillStorage = fillStorageForTypedArray;\n      } else {\n        var rawItemGetter = getRawSourceItemGetter(sourceFormat, seriesLayoutBy);\n        provider.getItem = bind(rawItemGetter, null, data, startIndex, dimsDef);\n        var rawCounter = getRawSourceDataCounter(sourceFormat, seriesLayoutBy);\n        provider.count = bind(rawCounter, null, data, startIndex, dimsDef);\n      }\n    };\n    var getItemForTypedArray = function (idx, out) {\n      idx = idx - this._offset;\n      out = out || [];\n      var data = this._data;\n      var dimSize = this._dimSize;\n      var offset = dimSize * idx;\n      for (var i = 0; i < dimSize; i++) {\n        out[i] = data[offset + i];\n      }\n      return out;\n    };\n    var fillStorageForTypedArray = function (start, end, storage, extent) {\n      var data = this._data;\n      var dimSize = this._dimSize;\n      for (var dim = 0; dim < dimSize; dim++) {\n        var dimExtent = extent[dim];\n        var min = dimExtent[0] == null ? Infinity : dimExtent[0];\n        var max = dimExtent[1] == null ? -Infinity : dimExtent[1];\n        var count = end - start;\n        var arr = storage[dim];\n        for (var i = 0; i < count; i++) {\n          // appendData with TypedArray will always do replace in provider.\n          var val = data[i * dimSize + dim];\n          arr[start + i] = val;\n          val < min && (min = val);\n          val > max && (max = val);\n        }\n        dimExtent[0] = min;\n        dimExtent[1] = max;\n      }\n    };\n    var countForTypedArray = function () {\n      return this._data ? this._data.length / this._dimSize : 0;\n    };\n    providerMethods = (_a = {}, _a[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_COLUMN] = {\n      pure: true,\n      appendData: appendDataSimply\n    }, _a[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_ROW] = {\n      pure: true,\n      appendData: function () {\n        throw new Error('Do not support appendData when set seriesLayoutBy: \"row\".');\n      }\n    }, _a[SOURCE_FORMAT_OBJECT_ROWS] = {\n      pure: true,\n      appendData: appendDataSimply\n    }, _a[SOURCE_FORMAT_KEYED_COLUMNS] = {\n      pure: true,\n      appendData: function (newData) {\n        var data = this._data;\n        each(newData, function (newCol, key) {\n          var oldCol = data[key] || (data[key] = []);\n          for (var i = 0; i < (newCol || []).length; i++) {\n            oldCol.push(newCol[i]);\n          }\n        });\n      }\n    }, _a[SOURCE_FORMAT_ORIGINAL] = {\n      appendData: appendDataSimply\n    }, _a[SOURCE_FORMAT_TYPED_ARRAY] = {\n      persistent: false,\n      pure: true,\n      appendData: function (newData) {\n        if (process.env.NODE_ENV !== 'production') {\n          assert(isTypedArray(newData), 'Added data must be TypedArray if data in initialization is TypedArray');\n        }\n        this._data = newData;\n      },\n      // Clean self if data is already used.\n      clean: function () {\n        // PENDING\n        this._offset += this.count();\n        this._data = null;\n      }\n    }, _a);\n    function appendDataSimply(newData) {\n      for (var i = 0; i < newData.length; i++) {\n        this._data.push(newData[i]);\n      }\n    }\n  }();\n  return DefaultDataProvider;\n}();\nexport { DefaultDataProvider };\nvar validateSimply = function (rawData) {\n  if (!isArray(rawData)) {\n    error('series.data or dataset.source must be an array.');\n  }\n};\n/**\n * Only run in dev mode - hint users for debug.\n */\nvar rawSourceDataValidatorMap = (_a = {}, _a[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_COLUMN] = validateSimply, _a[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_ROW] = validateSimply, _a[SOURCE_FORMAT_OBJECT_ROWS] = validateSimply, _a[SOURCE_FORMAT_KEYED_COLUMNS] = function (rawData, dimsDef) {\n  for (var i = 0; i < dimsDef.length; i++) {\n    var dimName = dimsDef[i].name;\n    if (dimName == null) {\n      error('dimension name must not be null/undefined.');\n    }\n  }\n}, _a[SOURCE_FORMAT_ORIGINAL] = validateSimply, _a);\nvar getItemSimply = function (rawData, startIndex, dimsDef, idx) {\n  return rawData[idx];\n};\nvar rawSourceItemGetterMap = (_b = {}, _b[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_COLUMN] = function (rawData, startIndex, dimsDef, idx) {\n  return rawData[idx + startIndex];\n}, _b[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_ROW] = function (rawData, startIndex, dimsDef, idx, out) {\n  idx += startIndex;\n  var item = out || [];\n  var data = rawData;\n  for (var i = 0; i < data.length; i++) {\n    var row = data[i];\n    item[i] = row ? row[idx] : null;\n  }\n  return item;\n}, _b[SOURCE_FORMAT_OBJECT_ROWS] = getItemSimply, _b[SOURCE_FORMAT_KEYED_COLUMNS] = function (rawData, startIndex, dimsDef, idx, out) {\n  var item = out || [];\n  for (var i = 0; i < dimsDef.length; i++) {\n    var dimName = dimsDef[i].name;\n    var col = dimName != null ? rawData[dimName] : null;\n    item[i] = col ? col[idx] : null;\n  }\n  return item;\n}, _b[SOURCE_FORMAT_ORIGINAL] = getItemSimply, _b);\nexport function getRawSourceItemGetter(sourceFormat, seriesLayoutBy) {\n  var method = rawSourceItemGetterMap[getMethodMapKey(sourceFormat, seriesLayoutBy)];\n  if (process.env.NODE_ENV !== 'production') {\n    assert(method, 'Do not support get item on \"' + sourceFormat + '\", \"' + seriesLayoutBy + '\".');\n  }\n  return method;\n}\nvar countSimply = function (rawData, startIndex, dimsDef) {\n  return rawData.length;\n};\nvar rawSourceDataCounterMap = (_c = {}, _c[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_COLUMN] = function (rawData, startIndex, dimsDef) {\n  return Math.max(0, rawData.length - startIndex);\n}, _c[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_ROW] = function (rawData, startIndex, dimsDef) {\n  var row = rawData[0];\n  return row ? Math.max(0, row.length - startIndex) : 0;\n}, _c[SOURCE_FORMAT_OBJECT_ROWS] = countSimply, _c[SOURCE_FORMAT_KEYED_COLUMNS] = function (rawData, startIndex, dimsDef) {\n  var dimName = dimsDef[0].name;\n  var col = dimName != null ? rawData[dimName] : null;\n  return col ? col.length : 0;\n}, _c[SOURCE_FORMAT_ORIGINAL] = countSimply, _c);\nexport function getRawSourceDataCounter(sourceFormat, seriesLayoutBy) {\n  var method = rawSourceDataCounterMap[getMethodMapKey(sourceFormat, seriesLayoutBy)];\n  if (process.env.NODE_ENV !== 'production') {\n    assert(method, 'Do not support count on \"' + sourceFormat + '\", \"' + seriesLayoutBy + '\".');\n  }\n  return method;\n}\nvar getRawValueSimply = function (dataItem, dimIndex, property) {\n  return dataItem[dimIndex];\n};\nvar rawSourceValueGetterMap = (_d = {}, _d[SOURCE_FORMAT_ARRAY_ROWS] = getRawValueSimply, _d[SOURCE_FORMAT_OBJECT_ROWS] = function (dataItem, dimIndex, property) {\n  return dataItem[property];\n}, _d[SOURCE_FORMAT_KEYED_COLUMNS] = getRawValueSimply, _d[SOURCE_FORMAT_ORIGINAL] = function (dataItem, dimIndex, property) {\n  // FIXME: In some case (markpoint in geo (geo-map.html)),\n  // dataItem is {coord: [...]}\n  var value = getDataItemValue(dataItem);\n  return !(value instanceof Array) ? value : value[dimIndex];\n}, _d[SOURCE_FORMAT_TYPED_ARRAY] = getRawValueSimply, _d);\nexport function getRawSourceValueGetter(sourceFormat) {\n  var method = rawSourceValueGetterMap[sourceFormat];\n  if (process.env.NODE_ENV !== 'production') {\n    assert(method, 'Do not support get value on \"' + sourceFormat + '\".');\n  }\n  return method;\n}\nfunction getMethodMapKey(sourceFormat, seriesLayoutBy) {\n  return sourceFormat === SOURCE_FORMAT_ARRAY_ROWS ? sourceFormat + '_' + seriesLayoutBy : sourceFormat;\n}\n// ??? FIXME can these logic be more neat: getRawValue, getRawDataItem,\n// Consider persistent.\n// Caution: why use raw value to display on label or tooltip?\n// A reason is to avoid format. For example time value we do not know\n// how to format is expected. More over, if stack is used, calculated\n// value may be 0.91000000001, which have brings trouble to display.\n// TODO: consider how to treat null/undefined/NaN when display?\nexport function retrieveRawValue(data, dataIndex,\n// If dimIndex is null/undefined, return OptionDataItem.\n// Otherwise, return OptionDataValue.\ndim) {\n  if (!data) {\n    return;\n  }\n  // Consider data may be not persistent.\n  var dataItem = data.getRawDataItem(dataIndex);\n  if (dataItem == null) {\n    return;\n  }\n  var store = data.getStore();\n  var sourceFormat = store.getSource().sourceFormat;\n  if (dim != null) {\n    var dimIndex = data.getDimensionIndex(dim);\n    var property = store.getDimensionProperty(dimIndex);\n    return getRawSourceValueGetter(sourceFormat)(dataItem, dimIndex, property);\n  } else {\n    var result = dataItem;\n    if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {\n      result = getDataItemValue(dataItem);\n    }\n    return result;\n  }\n}\n/**\n * Compatible with some cases (in pie, map) like:\n * data: [{name: 'xx', value: 5, selected: true}, ...]\n * where only sourceFormat is 'original' and 'objectRows' supported.\n *\n * // TODO\n * Supported detail options in data item when using 'arrayRows'.\n *\n * @param data\n * @param dataIndex\n * @param attr like 'selected'\n */\nexport function retrieveRawAttr(data, dataIndex, attr) {\n  if (!data) {\n    return;\n  }\n  var sourceFormat = data.getStore().getSource().sourceFormat;\n  if (sourceFormat !== SOURCE_FORMAT_ORIGINAL && sourceFormat !== SOURCE_FORMAT_OBJECT_ROWS) {\n    return;\n  }\n  var dataItem = data.getRawDataItem(dataIndex);\n  if (sourceFormat === SOURCE_FORMAT_ORIGINAL && !isObject(dataItem)) {\n    dataItem = null;\n  }\n  if (dataItem) {\n    return dataItem[attr];\n  }\n}"],"mappings":";AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIA,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE;AAClB;AACA;AACA;AACA,SAASC,YAAY,EAAEC,MAAM,EAAEC,MAAM,EAAEC,IAAI,EAAEC,QAAQ,EAAEC,IAAI,EAAEC,OAAO,QAAQ,0BAA0B;AACtG,SAASC,gBAAgB,QAAQ,qBAAqB;AACtD,SAASC,gCAAgC,EAAEC,gBAAgB,QAAQ,cAAc;AACjF,SAASC,sBAAsB,EAAEC,yBAAyB,EAAEC,2BAA2B,EAAEC,yBAAyB,EAAEC,wBAAwB,EAAEC,uBAAuB,EAAEC,oBAAoB,QAAQ,qBAAqB;AACxN,SAASC,KAAK,QAAQ,mBAAmB;AACzC,IAAIC,eAAe;AACnB,IAAIC,YAAY;AAChB;AACA;AACA;AACA;AACA,IAAIC,mBAAmB,GAAG,aAAa,YAAY;EACjD,SAASA,mBAAmBA,CAACC,WAAW,EAAEC,OAAO,EAAE;IACjD;IACA,IAAIC,MAAM,GAAG,CAACd,gBAAgB,CAACY,WAAW,CAAC,GAAGb,gCAAgC,CAACa,WAAW,CAAC,GAAGA,WAAW;IACzG;IACA,IAAI,CAACG,OAAO,GAAGD,MAAM;IACrB,IAAIE,IAAI,GAAG,IAAI,CAACC,KAAK,GAAGH,MAAM,CAACE,IAAI;IACnC,IAAIE,YAAY,GAAGJ,MAAM,CAACI,YAAY;IACtC,IAAIC,cAAc,GAAGL,MAAM,CAACK,cAAc;IAC1C;IACA,IAAID,YAAY,KAAKd,yBAAyB,EAAE;MAC9C,IAAIgB,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;QACzC,IAAIT,OAAO,IAAI,IAAI,EAAE;UACnB,MAAM,IAAIU,KAAK,CAAC,8CAA8C,CAAC;QACjE;MACF;MACA,IAAI,CAACC,OAAO,GAAG,CAAC;MAChB,IAAI,CAACC,QAAQ,GAAGZ,OAAO;MACvB,IAAI,CAACI,KAAK,GAAGD,IAAI;IACnB;IACA,IAAII,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;MACzC,IAAII,SAAS,GAAGC,yBAAyB,CAACC,eAAe,CAACV,YAAY,EAAEC,cAAc,CAAC,CAAC;MACxFO,SAAS,IAAIA,SAAS,CAACV,IAAI,EAAEF,MAAM,CAACe,gBAAgB,CAAC;IACvD;IACAnB,YAAY,CAAC,IAAI,EAAEM,IAAI,EAAEF,MAAM,CAAC;EAClC;EACAH,mBAAmB,CAACmB,SAAS,CAACC,SAAS,GAAG,YAAY;IACpD,OAAO,IAAI,CAAChB,OAAO;EACrB,CAAC;EACDJ,mBAAmB,CAACmB,SAAS,CAACE,KAAK,GAAG,YAAY;IAChD,OAAO,CAAC;EACV,CAAC;EACDrB,mBAAmB,CAACmB,SAAS,CAACG,OAAO,GAAG,UAAUC,GAAG,EAAEC,GAAG,EAAE;IAC1D;EACF,CAAC;EACDxB,mBAAmB,CAACmB,SAAS,CAACM,UAAU,GAAG,UAAUC,OAAO,EAAE,CAAC,CAAC;EAChE1B,mBAAmB,CAACmB,SAAS,CAACQ,KAAK,GAAG,YAAY,CAAC,CAAC;EACpD3B,mBAAmB,CAAC4B,eAAe,GAAG,YAAY;IAChD;IACA;IACA,IAAIC,KAAK,GAAG7B,mBAAmB,CAACmB,SAAS;IACzCU,KAAK,CAACC,IAAI,GAAG,KAAK;IAClBD,KAAK,CAACE,UAAU,GAAG,IAAI;EACzB,CAAC,CAAC,CAAC;EACH/B,mBAAmB,CAACgC,aAAa,GAAG,YAAY;IAC9C,IAAIxD,EAAE;IACNuB,YAAY,GAAG,SAAAA,CAAUkC,QAAQ,EAAE5B,IAAI,EAAEF,MAAM,EAAE;MAC/C,IAAII,YAAY,GAAGJ,MAAM,CAACI,YAAY;MACtC,IAAIC,cAAc,GAAGL,MAAM,CAACK,cAAc;MAC1C,IAAI0B,UAAU,GAAG/B,MAAM,CAAC+B,UAAU;MAClC,IAAIC,OAAO,GAAGhC,MAAM,CAACe,gBAAgB;MACrC,IAAIkB,OAAO,GAAGtC,eAAe,CAACmB,eAAe,CAACV,YAAY,EAAEC,cAAc,CAAC,CAAC;MAC5E,IAAIC,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;QACzC7B,MAAM,CAACsD,OAAO,EAAE,yBAAyB,GAAG7B,YAAY,CAAC;MAC3D;MACA1B,MAAM,CAACoD,QAAQ,EAAEG,OAAO,CAAC;MACzB,IAAI7B,YAAY,KAAKd,yBAAyB,EAAE;QAC9CwC,QAAQ,CAACX,OAAO,GAAGe,oBAAoB;QACvCJ,QAAQ,CAACZ,KAAK,GAAGiB,kBAAkB;QACnCL,QAAQ,CAACM,WAAW,GAAGC,wBAAwB;MACjD,CAAC,MAAM;QACL,IAAIC,aAAa,GAAGC,sBAAsB,CAACnC,YAAY,EAAEC,cAAc,CAAC;QACxEyB,QAAQ,CAACX,OAAO,GAAGrC,IAAI,CAACwD,aAAa,EAAE,IAAI,EAAEpC,IAAI,EAAE6B,UAAU,EAAEC,OAAO,CAAC;QACvE,IAAIQ,UAAU,GAAGC,uBAAuB,CAACrC,YAAY,EAAEC,cAAc,CAAC;QACtEyB,QAAQ,CAACZ,KAAK,GAAGpC,IAAI,CAAC0D,UAAU,EAAE,IAAI,EAAEtC,IAAI,EAAE6B,UAAU,EAAEC,OAAO,CAAC;MACpE;IACF,CAAC;IACD,IAAIE,oBAAoB,GAAG,SAAAA,CAAUd,GAAG,EAAEC,GAAG,EAAE;MAC7CD,GAAG,GAAGA,GAAG,GAAG,IAAI,CAACV,OAAO;MACxBW,GAAG,GAAGA,GAAG,IAAI,EAAE;MACf,IAAInB,IAAI,GAAG,IAAI,CAACC,KAAK;MACrB,IAAIJ,OAAO,GAAG,IAAI,CAACY,QAAQ;MAC3B,IAAI+B,MAAM,GAAG3C,OAAO,GAAGqB,GAAG;MAC1B,KAAK,IAAIuB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG5C,OAAO,EAAE4C,CAAC,EAAE,EAAE;QAChCtB,GAAG,CAACsB,CAAC,CAAC,GAAGzC,IAAI,CAACwC,MAAM,GAAGC,CAAC,CAAC;MAC3B;MACA,OAAOtB,GAAG;IACZ,CAAC;IACD,IAAIgB,wBAAwB,GAAG,SAAAA,CAAUO,KAAK,EAAEC,GAAG,EAAEC,OAAO,EAAEC,MAAM,EAAE;MACpE,IAAI7C,IAAI,GAAG,IAAI,CAACC,KAAK;MACrB,IAAIJ,OAAO,GAAG,IAAI,CAACY,QAAQ;MAC3B,KAAK,IAAIqC,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAGjD,OAAO,EAAEiD,GAAG,EAAE,EAAE;QACtC,IAAIC,SAAS,GAAGF,MAAM,CAACC,GAAG,CAAC;QAC3B,IAAIE,GAAG,GAAGD,SAAS,CAAC,CAAC,CAAC,IAAI,IAAI,GAAGE,QAAQ,GAAGF,SAAS,CAAC,CAAC,CAAC;QACxD,IAAIG,GAAG,GAAGH,SAAS,CAAC,CAAC,CAAC,IAAI,IAAI,GAAG,CAACE,QAAQ,GAAGF,SAAS,CAAC,CAAC,CAAC;QACzD,IAAI/B,KAAK,GAAG2B,GAAG,GAAGD,KAAK;QACvB,IAAIS,GAAG,GAAGP,OAAO,CAACE,GAAG,CAAC;QACtB,KAAK,IAAIL,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGzB,KAAK,EAAEyB,CAAC,EAAE,EAAE;UAC9B;UACA,IAAIW,GAAG,GAAGpD,IAAI,CAACyC,CAAC,GAAG5C,OAAO,GAAGiD,GAAG,CAAC;UACjCK,GAAG,CAACT,KAAK,GAAGD,CAAC,CAAC,GAAGW,GAAG;UACpBA,GAAG,GAAGJ,GAAG,KAAKA,GAAG,GAAGI,GAAG,CAAC;UACxBA,GAAG,GAAGF,GAAG,KAAKA,GAAG,GAAGE,GAAG,CAAC;QAC1B;QACAL,SAAS,CAAC,CAAC,CAAC,GAAGC,GAAG;QAClBD,SAAS,CAAC,CAAC,CAAC,GAAGG,GAAG;MACpB;IACF,CAAC;IACD,IAAIjB,kBAAkB,GAAG,SAAAA,CAAA,EAAY;MACnC,OAAO,IAAI,CAAChC,KAAK,GAAG,IAAI,CAACA,KAAK,CAACoD,MAAM,GAAG,IAAI,CAAC5C,QAAQ,GAAG,CAAC;IAC3D,CAAC;IACDhB,eAAe,IAAItB,EAAE,GAAG,CAAC,CAAC,EAAEA,EAAE,CAACkB,wBAAwB,GAAG,GAAG,GAAGC,uBAAuB,CAAC,GAAG;MACzFmC,IAAI,EAAE,IAAI;MACVL,UAAU,EAAEkC;IACd,CAAC,EAAEnF,EAAE,CAACkB,wBAAwB,GAAG,GAAG,GAAGE,oBAAoB,CAAC,GAAG;MAC7DkC,IAAI,EAAE,IAAI;MACVL,UAAU,EAAE,SAAAA,CAAA,EAAY;QACtB,MAAM,IAAIb,KAAK,CAAC,2DAA2D,CAAC;MAC9E;IACF,CAAC,EAAEpC,EAAE,CAACe,yBAAyB,CAAC,GAAG;MACjCuC,IAAI,EAAE,IAAI;MACVL,UAAU,EAAEkC;IACd,CAAC,EAAEnF,EAAE,CAACgB,2BAA2B,CAAC,GAAG;MACnCsC,IAAI,EAAE,IAAI;MACVL,UAAU,EAAE,SAAAA,CAAUC,OAAO,EAAE;QAC7B,IAAIrB,IAAI,GAAG,IAAI,CAACC,KAAK;QACrBvB,IAAI,CAAC2C,OAAO,EAAE,UAAUkC,MAAM,EAAEC,GAAG,EAAE;UACnC,IAAIC,MAAM,GAAGzD,IAAI,CAACwD,GAAG,CAAC,KAAKxD,IAAI,CAACwD,GAAG,CAAC,GAAG,EAAE,CAAC;UAC1C,KAAK,IAAIf,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAACc,MAAM,IAAI,EAAE,EAAEF,MAAM,EAAEZ,CAAC,EAAE,EAAE;YAC9CgB,MAAM,CAACC,IAAI,CAACH,MAAM,CAACd,CAAC,CAAC,CAAC;UACxB;QACF,CAAC,CAAC;MACJ;IACF,CAAC,EAAEtE,EAAE,CAACc,sBAAsB,CAAC,GAAG;MAC9BmC,UAAU,EAAEkC;IACd,CAAC,EAAEnF,EAAE,CAACiB,yBAAyB,CAAC,GAAG;MACjCsC,UAAU,EAAE,KAAK;MACjBD,IAAI,EAAE,IAAI;MACVL,UAAU,EAAE,SAAAA,CAAUC,OAAO,EAAE;QAC7B,IAAIjB,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;UACzC7B,MAAM,CAACF,YAAY,CAAC8C,OAAO,CAAC,EAAE,uEAAuE,CAAC;QACxG;QACA,IAAI,CAACpB,KAAK,GAAGoB,OAAO;MACtB,CAAC;MACD;MACAC,KAAK,EAAE,SAAAA,CAAA,EAAY;QACjB;QACA,IAAI,CAACd,OAAO,IAAI,IAAI,CAACQ,KAAK,CAAC,CAAC;QAC5B,IAAI,CAACf,KAAK,GAAG,IAAI;MACnB;IACF,CAAC,EAAE9B,EAAE,CAAC;IACN,SAASmF,gBAAgBA,CAACjC,OAAO,EAAE;MACjC,KAAK,IAAIoB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGpB,OAAO,CAACgC,MAAM,EAAEZ,CAAC,EAAE,EAAE;QACvC,IAAI,CAACxC,KAAK,CAACyD,IAAI,CAACrC,OAAO,CAACoB,CAAC,CAAC,CAAC;MAC7B;IACF;EACF,CAAC,CAAC,CAAC;EACH,OAAO9C,mBAAmB;AAC5B,CAAC,CAAC,CAAC;AACH,SAASA,mBAAmB;AAC5B,IAAIgE,cAAc,GAAG,SAAAA,CAAUC,OAAO,EAAE;EACtC,IAAI,CAAC/E,OAAO,CAAC+E,OAAO,CAAC,EAAE;IACrBpE,KAAK,CAAC,iDAAiD,CAAC;EAC1D;AACF,CAAC;AACD;AACA;AACA;AACA,IAAImB,yBAAyB,IAAIxC,EAAE,GAAG,CAAC,CAAC,EAAEA,EAAE,CAACkB,wBAAwB,GAAG,GAAG,GAAGC,uBAAuB,CAAC,GAAGqE,cAAc,EAAExF,EAAE,CAACkB,wBAAwB,GAAG,GAAG,GAAGE,oBAAoB,CAAC,GAAGoE,cAAc,EAAExF,EAAE,CAACe,yBAAyB,CAAC,GAAGyE,cAAc,EAAExF,EAAE,CAACgB,2BAA2B,CAAC,GAAG,UAAUyE,OAAO,EAAE9B,OAAO,EAAE;EACjT,KAAK,IAAIW,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGX,OAAO,CAACuB,MAAM,EAAEZ,CAAC,EAAE,EAAE;IACvC,IAAIoB,OAAO,GAAG/B,OAAO,CAACW,CAAC,CAAC,CAACqB,IAAI;IAC7B,IAAID,OAAO,IAAI,IAAI,EAAE;MACnBrE,KAAK,CAAC,4CAA4C,CAAC;IACrD;EACF;AACF,CAAC,EAAErB,EAAE,CAACc,sBAAsB,CAAC,GAAG0E,cAAc,EAAExF,EAAE,CAAC;AACnD,IAAI4F,aAAa,GAAG,SAAAA,CAAUH,OAAO,EAAE/B,UAAU,EAAEC,OAAO,EAAEZ,GAAG,EAAE;EAC/D,OAAO0C,OAAO,CAAC1C,GAAG,CAAC;AACrB,CAAC;AACD,IAAI8C,sBAAsB,IAAI5F,EAAE,GAAG,CAAC,CAAC,EAAEA,EAAE,CAACiB,wBAAwB,GAAG,GAAG,GAAGC,uBAAuB,CAAC,GAAG,UAAUsE,OAAO,EAAE/B,UAAU,EAAEC,OAAO,EAAEZ,GAAG,EAAE;EACjJ,OAAO0C,OAAO,CAAC1C,GAAG,GAAGW,UAAU,CAAC;AAClC,CAAC,EAAEzD,EAAE,CAACiB,wBAAwB,GAAG,GAAG,GAAGE,oBAAoB,CAAC,GAAG,UAAUqE,OAAO,EAAE/B,UAAU,EAAEC,OAAO,EAAEZ,GAAG,EAAEC,GAAG,EAAE;EAC/GD,GAAG,IAAIW,UAAU;EACjB,IAAIoC,IAAI,GAAG9C,GAAG,IAAI,EAAE;EACpB,IAAInB,IAAI,GAAG4D,OAAO;EAClB,KAAK,IAAInB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGzC,IAAI,CAACqD,MAAM,EAAEZ,CAAC,EAAE,EAAE;IACpC,IAAIyB,GAAG,GAAGlE,IAAI,CAACyC,CAAC,CAAC;IACjBwB,IAAI,CAACxB,CAAC,CAAC,GAAGyB,GAAG,GAAGA,GAAG,CAAChD,GAAG,CAAC,GAAG,IAAI;EACjC;EACA,OAAO+C,IAAI;AACb,CAAC,EAAE7F,EAAE,CAACc,yBAAyB,CAAC,GAAG6E,aAAa,EAAE3F,EAAE,CAACe,2BAA2B,CAAC,GAAG,UAAUyE,OAAO,EAAE/B,UAAU,EAAEC,OAAO,EAAEZ,GAAG,EAAEC,GAAG,EAAE;EACpI,IAAI8C,IAAI,GAAG9C,GAAG,IAAI,EAAE;EACpB,KAAK,IAAIsB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGX,OAAO,CAACuB,MAAM,EAAEZ,CAAC,EAAE,EAAE;IACvC,IAAIoB,OAAO,GAAG/B,OAAO,CAACW,CAAC,CAAC,CAACqB,IAAI;IAC7B,IAAIK,GAAG,GAAGN,OAAO,IAAI,IAAI,GAAGD,OAAO,CAACC,OAAO,CAAC,GAAG,IAAI;IACnDI,IAAI,CAACxB,CAAC,CAAC,GAAG0B,GAAG,GAAGA,GAAG,CAACjD,GAAG,CAAC,GAAG,IAAI;EACjC;EACA,OAAO+C,IAAI;AACb,CAAC,EAAE7F,EAAE,CAACa,sBAAsB,CAAC,GAAG8E,aAAa,EAAE3F,EAAE,CAAC;AAClD,OAAO,SAASiE,sBAAsBA,CAACnC,YAAY,EAAEC,cAAc,EAAE;EACnE,IAAIiE,MAAM,GAAGJ,sBAAsB,CAACpD,eAAe,CAACV,YAAY,EAAEC,cAAc,CAAC,CAAC;EAClF,IAAIC,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;IACzC7B,MAAM,CAAC2F,MAAM,EAAE,8BAA8B,GAAGlE,YAAY,GAAG,MAAM,GAAGC,cAAc,GAAG,IAAI,CAAC;EAChG;EACA,OAAOiE,MAAM;AACf;AACA,IAAIC,WAAW,GAAG,SAAAA,CAAUT,OAAO,EAAE/B,UAAU,EAAEC,OAAO,EAAE;EACxD,OAAO8B,OAAO,CAACP,MAAM;AACvB,CAAC;AACD,IAAIiB,uBAAuB,IAAIjG,EAAE,GAAG,CAAC,CAAC,EAAEA,EAAE,CAACgB,wBAAwB,GAAG,GAAG,GAAGC,uBAAuB,CAAC,GAAG,UAAUsE,OAAO,EAAE/B,UAAU,EAAEC,OAAO,EAAE;EAC7I,OAAOyC,IAAI,CAACrB,GAAG,CAAC,CAAC,EAAEU,OAAO,CAACP,MAAM,GAAGxB,UAAU,CAAC;AACjD,CAAC,EAAExD,EAAE,CAACgB,wBAAwB,GAAG,GAAG,GAAGE,oBAAoB,CAAC,GAAG,UAAUqE,OAAO,EAAE/B,UAAU,EAAEC,OAAO,EAAE;EACrG,IAAIoC,GAAG,GAAGN,OAAO,CAAC,CAAC,CAAC;EACpB,OAAOM,GAAG,GAAGK,IAAI,CAACrB,GAAG,CAAC,CAAC,EAAEgB,GAAG,CAACb,MAAM,GAAGxB,UAAU,CAAC,GAAG,CAAC;AACvD,CAAC,EAAExD,EAAE,CAACa,yBAAyB,CAAC,GAAGmF,WAAW,EAAEhG,EAAE,CAACc,2BAA2B,CAAC,GAAG,UAAUyE,OAAO,EAAE/B,UAAU,EAAEC,OAAO,EAAE;EACxH,IAAI+B,OAAO,GAAG/B,OAAO,CAAC,CAAC,CAAC,CAACgC,IAAI;EAC7B,IAAIK,GAAG,GAAGN,OAAO,IAAI,IAAI,GAAGD,OAAO,CAACC,OAAO,CAAC,GAAG,IAAI;EACnD,OAAOM,GAAG,GAAGA,GAAG,CAACd,MAAM,GAAG,CAAC;AAC7B,CAAC,EAAEhF,EAAE,CAACY,sBAAsB,CAAC,GAAGoF,WAAW,EAAEhG,EAAE,CAAC;AAChD,OAAO,SAASkE,uBAAuBA,CAACrC,YAAY,EAAEC,cAAc,EAAE;EACpE,IAAIiE,MAAM,GAAGE,uBAAuB,CAAC1D,eAAe,CAACV,YAAY,EAAEC,cAAc,CAAC,CAAC;EACnF,IAAIC,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;IACzC7B,MAAM,CAAC2F,MAAM,EAAE,2BAA2B,GAAGlE,YAAY,GAAG,MAAM,GAAGC,cAAc,GAAG,IAAI,CAAC;EAC7F;EACA,OAAOiE,MAAM;AACf;AACA,IAAII,iBAAiB,GAAG,SAAAA,CAAUC,QAAQ,EAAEC,QAAQ,EAAEC,QAAQ,EAAE;EAC9D,OAAOF,QAAQ,CAACC,QAAQ,CAAC;AAC3B,CAAC;AACD,IAAIE,uBAAuB,IAAItG,EAAE,GAAG,CAAC,CAAC,EAAEA,EAAE,CAACe,wBAAwB,CAAC,GAAGmF,iBAAiB,EAAElG,EAAE,CAACY,yBAAyB,CAAC,GAAG,UAAUuF,QAAQ,EAAEC,QAAQ,EAAEC,QAAQ,EAAE;EAChK,OAAOF,QAAQ,CAACE,QAAQ,CAAC;AAC3B,CAAC,EAAErG,EAAE,CAACa,2BAA2B,CAAC,GAAGqF,iBAAiB,EAAElG,EAAE,CAACW,sBAAsB,CAAC,GAAG,UAAUwF,QAAQ,EAAEC,QAAQ,EAAEC,QAAQ,EAAE;EAC3H;EACA;EACA,IAAIE,KAAK,GAAG/F,gBAAgB,CAAC2F,QAAQ,CAAC;EACtC,OAAO,EAAEI,KAAK,YAAYC,KAAK,CAAC,GAAGD,KAAK,GAAGA,KAAK,CAACH,QAAQ,CAAC;AAC5D,CAAC,EAAEpG,EAAE,CAACc,yBAAyB,CAAC,GAAGoF,iBAAiB,EAAElG,EAAE,CAAC;AACzD,OAAO,SAASyG,uBAAuBA,CAAC7E,YAAY,EAAE;EACpD,IAAIkE,MAAM,GAAGQ,uBAAuB,CAAC1E,YAAY,CAAC;EAClD,IAAIE,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;IACzC7B,MAAM,CAAC2F,MAAM,EAAE,+BAA+B,GAAGlE,YAAY,GAAG,IAAI,CAAC;EACvE;EACA,OAAOkE,MAAM;AACf;AACA,SAASxD,eAAeA,CAACV,YAAY,EAAEC,cAAc,EAAE;EACrD,OAAOD,YAAY,KAAKb,wBAAwB,GAAGa,YAAY,GAAG,GAAG,GAAGC,cAAc,GAAGD,YAAY;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAAS8E,gBAAgBA,CAAChF,IAAI,EAAEiF,SAAS;AAChD;AACA;AACAnC,GAAG,EAAE;EACH,IAAI,CAAC9C,IAAI,EAAE;IACT;EACF;EACA;EACA,IAAIyE,QAAQ,GAAGzE,IAAI,CAACkF,cAAc,CAACD,SAAS,CAAC;EAC7C,IAAIR,QAAQ,IAAI,IAAI,EAAE;IACpB;EACF;EACA,IAAIU,KAAK,GAAGnF,IAAI,CAACoF,QAAQ,CAAC,CAAC;EAC3B,IAAIlF,YAAY,GAAGiF,KAAK,CAACpE,SAAS,CAAC,CAAC,CAACb,YAAY;EACjD,IAAI4C,GAAG,IAAI,IAAI,EAAE;IACf,IAAI4B,QAAQ,GAAG1E,IAAI,CAACqF,iBAAiB,CAACvC,GAAG,CAAC;IAC1C,IAAI6B,QAAQ,GAAGQ,KAAK,CAACG,oBAAoB,CAACZ,QAAQ,CAAC;IACnD,OAAOK,uBAAuB,CAAC7E,YAAY,CAAC,CAACuE,QAAQ,EAAEC,QAAQ,EAAEC,QAAQ,CAAC;EAC5E,CAAC,MAAM;IACL,IAAIY,MAAM,GAAGd,QAAQ;IACrB,IAAIvE,YAAY,KAAKjB,sBAAsB,EAAE;MAC3CsG,MAAM,GAAGzG,gBAAgB,CAAC2F,QAAQ,CAAC;IACrC;IACA,OAAOc,MAAM;EACf;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,eAAeA,CAACxF,IAAI,EAAEiF,SAAS,EAAEQ,IAAI,EAAE;EACrD,IAAI,CAACzF,IAAI,EAAE;IACT;EACF;EACA,IAAIE,YAAY,GAAGF,IAAI,CAACoF,QAAQ,CAAC,CAAC,CAACrE,SAAS,CAAC,CAAC,CAACb,YAAY;EAC3D,IAAIA,YAAY,KAAKjB,sBAAsB,IAAIiB,YAAY,KAAKhB,yBAAyB,EAAE;IACzF;EACF;EACA,IAAIuF,QAAQ,GAAGzE,IAAI,CAACkF,cAAc,CAACD,SAAS,CAAC;EAC7C,IAAI/E,YAAY,KAAKjB,sBAAsB,IAAI,CAACN,QAAQ,CAAC8F,QAAQ,CAAC,EAAE;IAClEA,QAAQ,GAAG,IAAI;EACjB;EACA,IAAIA,QAAQ,EAAE;IACZ,OAAOA,QAAQ,CAACgB,IAAI,CAAC;EACvB;AACF"},"metadata":{},"sourceType":"module","externalDependencies":[]}
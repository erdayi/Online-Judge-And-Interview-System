{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { __extends } from \"tslib\";\nimport * as zrUtil from 'zrender/lib/core/util.js';\nimport BoundingRect from 'zrender/lib/core/BoundingRect.js';\nimport View from '../View.js';\nimport geoSourceManager from './geoSourceManager.js';\nimport { SINGLE_REFERRING } from '../../util/model.js';\nimport { warn } from '../../util/log.js';\nvar GEO_DEFAULT_PARAMS = {\n  'geoJSON': {\n    aspectScale: 0.75,\n    invertLongitute: true\n  },\n  'geoSVG': {\n    aspectScale: 1,\n    invertLongitute: false\n  }\n};\nexport var geo2DDimensions = ['lng', 'lat'];\nvar Geo = /** @class */function (_super) {\n  __extends(Geo, _super);\n  function Geo(name, map, opt) {\n    var _this = _super.call(this, name, {\n      api: opt.api,\n      ecModel: opt.ecModel\n    }) || this;\n    _this.dimensions = geo2DDimensions;\n    _this.type = 'geo';\n    // Only store specified name coord via `addGeoCoord`.\n    _this._nameCoordMap = zrUtil.createHashMap();\n    _this.map = map;\n    var projection = opt.projection;\n    var source = geoSourceManager.load(map, opt.nameMap, opt.nameProperty);\n    var resource = geoSourceManager.getGeoResource(map);\n    var resourceType = _this.resourceType = resource ? resource.type : null;\n    var regions = _this.regions = source.regions;\n    var defaultParams = GEO_DEFAULT_PARAMS[resource.type];\n    _this._regionsMap = source.regionsMap;\n    _this.regions = source.regions;\n    if (process.env.NODE_ENV !== 'production' && projection) {\n      // Do some check\n      if (resourceType === 'geoSVG') {\n        if (process.env.NODE_ENV !== 'production') {\n          warn(\"Map \" + map + \" with SVG source can't use projection. Only GeoJSON source supports projection.\");\n        }\n        projection = null;\n      }\n      if (!(projection.project && projection.unproject)) {\n        if (process.env.NODE_ENV !== 'production') {\n          warn('project and unproject must be both provided in the projeciton.');\n        }\n        projection = null;\n      }\n    }\n    _this.projection = projection;\n    var boundingRect;\n    if (projection) {\n      // Can't reuse the raw bounding rect\n      for (var i = 0; i < regions.length; i++) {\n        var regionRect = regions[i].getBoundingRect(projection);\n        boundingRect = boundingRect || regionRect.clone();\n        boundingRect.union(regionRect);\n      }\n    } else {\n      boundingRect = source.boundingRect;\n    }\n    _this.setBoundingRect(boundingRect.x, boundingRect.y, boundingRect.width, boundingRect.height);\n    // aspectScale and invertLongitute actually is the parameters default raw projection.\n    // So we ignore them if projection is given.\n    // Ignore default aspect scale if projection exits.\n    _this.aspectScale = projection ? 1 : zrUtil.retrieve2(opt.aspectScale, defaultParams.aspectScale);\n    // Not invert longitude if projection exits.\n    _this._invertLongitute = projection ? false : defaultParams.invertLongitute;\n    return _this;\n  }\n  Geo.prototype._transformTo = function (x, y, width, height) {\n    var rect = this.getBoundingRect();\n    var invertLongitute = this._invertLongitute;\n    rect = rect.clone();\n    if (invertLongitute) {\n      // Longitude is inverted.\n      rect.y = -rect.y - rect.height;\n    }\n    var rawTransformable = this._rawTransformable;\n    rawTransformable.transform = rect.calculateTransform(new BoundingRect(x, y, width, height));\n    var rawParent = rawTransformable.parent;\n    rawTransformable.parent = null;\n    rawTransformable.decomposeTransform();\n    rawTransformable.parent = rawParent;\n    if (invertLongitute) {\n      rawTransformable.scaleY = -rawTransformable.scaleY;\n    }\n    this._updateTransform();\n  };\n  Geo.prototype.getRegion = function (name) {\n    return this._regionsMap.get(name);\n  };\n  Geo.prototype.getRegionByCoord = function (coord) {\n    var regions = this.regions;\n    for (var i = 0; i < regions.length; i++) {\n      var region = regions[i];\n      if (region.type === 'geoJSON' && region.contain(coord)) {\n        return regions[i];\n      }\n    }\n  };\n  /**\n   * Add geoCoord for indexing by name\n   */\n  Geo.prototype.addGeoCoord = function (name, geoCoord) {\n    this._nameCoordMap.set(name, geoCoord);\n  };\n  /**\n   * Get geoCoord by name\n   */\n  Geo.prototype.getGeoCoord = function (name) {\n    var region = this._regionsMap.get(name);\n    // Calculate center only on demand.\n    return this._nameCoordMap.get(name) || region && region.getCenter();\n  };\n  Geo.prototype.dataToPoint = function (data, noRoam, out) {\n    if (zrUtil.isString(data)) {\n      // Map area name to geoCoord\n      data = this.getGeoCoord(data);\n    }\n    if (data) {\n      var projection = this.projection;\n      if (projection) {\n        // projection may return null point.\n        data = projection.project(data);\n      }\n      return data && this.projectedToPoint(data, noRoam, out);\n    }\n  };\n  Geo.prototype.pointToData = function (point, reserved, out) {\n    var projection = this.projection;\n    if (projection) {\n      // projection may return null point.\n      point = projection.unproject(point);\n    }\n    // FIXME: if no `point`, should return [NaN, NaN], rather than undefined.\n    //  null/undefined has special meaning in `convertFromPixel`.\n    return point && this.pointToProjected(point, out);\n  };\n  /**\n   * Point to projected data. Same with pointToData when projection is used.\n   */\n  Geo.prototype.pointToProjected = function (point, out) {\n    return _super.prototype.pointToData.call(this, point, 0, out);\n  };\n  Geo.prototype.projectedToPoint = function (projected, noRoam, out) {\n    return _super.prototype.dataToPoint.call(this, projected, noRoam, out);\n  };\n  Geo.prototype.convertToPixel = function (ecModel, finder, value) {\n    var coordSys = getCoordSys(finder);\n    return coordSys === this ? coordSys.dataToPoint(value) : null;\n  };\n  Geo.prototype.convertFromPixel = function (ecModel, finder, pixel) {\n    var coordSys = getCoordSys(finder);\n    return coordSys === this ? coordSys.pointToData(pixel) : null;\n  };\n  return Geo;\n}(View);\n;\nzrUtil.mixin(Geo, View);\nfunction getCoordSys(finder) {\n  var geoModel = finder.geoModel;\n  var seriesModel = finder.seriesModel;\n  return geoModel ? geoModel.coordinateSystem : seriesModel ? seriesModel.coordinateSystem // For map series.\n  || (seriesModel.getReferringComponents('geo', SINGLE_REFERRING).models[0] || {}).coordinateSystem : null;\n}\nexport default Geo;","map":{"version":3,"names":["__extends","zrUtil","BoundingRect","View","geoSourceManager","SINGLE_REFERRING","warn","GEO_DEFAULT_PARAMS","aspectScale","invertLongitute","geo2DDimensions","Geo","_super","name","map","opt","_this","call","api","ecModel","dimensions","type","_nameCoordMap","createHashMap","projection","source","load","nameMap","nameProperty","resource","getGeoResource","resourceType","regions","defaultParams","_regionsMap","regionsMap","process","env","NODE_ENV","project","unproject","boundingRect","i","length","regionRect","getBoundingRect","clone","union","setBoundingRect","x","y","width","height","retrieve2","_invertLongitute","prototype","_transformTo","rect","rawTransformable","_rawTransformable","transform","calculateTransform","rawParent","parent","decomposeTransform","scaleY","_updateTransform","getRegion","get","getRegionByCoord","coord","region","contain","addGeoCoord","geoCoord","set","getGeoCoord","getCenter","dataToPoint","data","noRoam","out","isString","projectedToPoint","pointToData","point","reserved","pointToProjected","projected","convertToPixel","finder","value","coordSys","getCoordSys","convertFromPixel","pixel","mixin","geoModel","seriesModel","coordinateSystem","getReferringComponents","models"],"sources":["D:/code/java/program/oj/code/yuoj-frontend-master/node_modules/echarts/lib/coord/geo/Geo.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { __extends } from \"tslib\";\nimport * as zrUtil from 'zrender/lib/core/util.js';\nimport BoundingRect from 'zrender/lib/core/BoundingRect.js';\nimport View from '../View.js';\nimport geoSourceManager from './geoSourceManager.js';\nimport { SINGLE_REFERRING } from '../../util/model.js';\nimport { warn } from '../../util/log.js';\nvar GEO_DEFAULT_PARAMS = {\n  'geoJSON': {\n    aspectScale: 0.75,\n    invertLongitute: true\n  },\n  'geoSVG': {\n    aspectScale: 1,\n    invertLongitute: false\n  }\n};\nexport var geo2DDimensions = ['lng', 'lat'];\nvar Geo = /** @class */function (_super) {\n  __extends(Geo, _super);\n  function Geo(name, map, opt) {\n    var _this = _super.call(this, name, {\n      api: opt.api,\n      ecModel: opt.ecModel\n    }) || this;\n    _this.dimensions = geo2DDimensions;\n    _this.type = 'geo';\n    // Only store specified name coord via `addGeoCoord`.\n    _this._nameCoordMap = zrUtil.createHashMap();\n    _this.map = map;\n    var projection = opt.projection;\n    var source = geoSourceManager.load(map, opt.nameMap, opt.nameProperty);\n    var resource = geoSourceManager.getGeoResource(map);\n    var resourceType = _this.resourceType = resource ? resource.type : null;\n    var regions = _this.regions = source.regions;\n    var defaultParams = GEO_DEFAULT_PARAMS[resource.type];\n    _this._regionsMap = source.regionsMap;\n    _this.regions = source.regions;\n    if (process.env.NODE_ENV !== 'production' && projection) {\n      // Do some check\n      if (resourceType === 'geoSVG') {\n        if (process.env.NODE_ENV !== 'production') {\n          warn(\"Map \" + map + \" with SVG source can't use projection. Only GeoJSON source supports projection.\");\n        }\n        projection = null;\n      }\n      if (!(projection.project && projection.unproject)) {\n        if (process.env.NODE_ENV !== 'production') {\n          warn('project and unproject must be both provided in the projeciton.');\n        }\n        projection = null;\n      }\n    }\n    _this.projection = projection;\n    var boundingRect;\n    if (projection) {\n      // Can't reuse the raw bounding rect\n      for (var i = 0; i < regions.length; i++) {\n        var regionRect = regions[i].getBoundingRect(projection);\n        boundingRect = boundingRect || regionRect.clone();\n        boundingRect.union(regionRect);\n      }\n    } else {\n      boundingRect = source.boundingRect;\n    }\n    _this.setBoundingRect(boundingRect.x, boundingRect.y, boundingRect.width, boundingRect.height);\n    // aspectScale and invertLongitute actually is the parameters default raw projection.\n    // So we ignore them if projection is given.\n    // Ignore default aspect scale if projection exits.\n    _this.aspectScale = projection ? 1 : zrUtil.retrieve2(opt.aspectScale, defaultParams.aspectScale);\n    // Not invert longitude if projection exits.\n    _this._invertLongitute = projection ? false : defaultParams.invertLongitute;\n    return _this;\n  }\n  Geo.prototype._transformTo = function (x, y, width, height) {\n    var rect = this.getBoundingRect();\n    var invertLongitute = this._invertLongitute;\n    rect = rect.clone();\n    if (invertLongitute) {\n      // Longitude is inverted.\n      rect.y = -rect.y - rect.height;\n    }\n    var rawTransformable = this._rawTransformable;\n    rawTransformable.transform = rect.calculateTransform(new BoundingRect(x, y, width, height));\n    var rawParent = rawTransformable.parent;\n    rawTransformable.parent = null;\n    rawTransformable.decomposeTransform();\n    rawTransformable.parent = rawParent;\n    if (invertLongitute) {\n      rawTransformable.scaleY = -rawTransformable.scaleY;\n    }\n    this._updateTransform();\n  };\n  Geo.prototype.getRegion = function (name) {\n    return this._regionsMap.get(name);\n  };\n  Geo.prototype.getRegionByCoord = function (coord) {\n    var regions = this.regions;\n    for (var i = 0; i < regions.length; i++) {\n      var region = regions[i];\n      if (region.type === 'geoJSON' && region.contain(coord)) {\n        return regions[i];\n      }\n    }\n  };\n  /**\n   * Add geoCoord for indexing by name\n   */\n  Geo.prototype.addGeoCoord = function (name, geoCoord) {\n    this._nameCoordMap.set(name, geoCoord);\n  };\n  /**\n   * Get geoCoord by name\n   */\n  Geo.prototype.getGeoCoord = function (name) {\n    var region = this._regionsMap.get(name);\n    // Calculate center only on demand.\n    return this._nameCoordMap.get(name) || region && region.getCenter();\n  };\n  Geo.prototype.dataToPoint = function (data, noRoam, out) {\n    if (zrUtil.isString(data)) {\n      // Map area name to geoCoord\n      data = this.getGeoCoord(data);\n    }\n    if (data) {\n      var projection = this.projection;\n      if (projection) {\n        // projection may return null point.\n        data = projection.project(data);\n      }\n      return data && this.projectedToPoint(data, noRoam, out);\n    }\n  };\n  Geo.prototype.pointToData = function (point, reserved, out) {\n    var projection = this.projection;\n    if (projection) {\n      // projection may return null point.\n      point = projection.unproject(point);\n    }\n    // FIXME: if no `point`, should return [NaN, NaN], rather than undefined.\n    //  null/undefined has special meaning in `convertFromPixel`.\n    return point && this.pointToProjected(point, out);\n  };\n  /**\n   * Point to projected data. Same with pointToData when projection is used.\n   */\n  Geo.prototype.pointToProjected = function (point, out) {\n    return _super.prototype.pointToData.call(this, point, 0, out);\n  };\n  Geo.prototype.projectedToPoint = function (projected, noRoam, out) {\n    return _super.prototype.dataToPoint.call(this, projected, noRoam, out);\n  };\n  Geo.prototype.convertToPixel = function (ecModel, finder, value) {\n    var coordSys = getCoordSys(finder);\n    return coordSys === this ? coordSys.dataToPoint(value) : null;\n  };\n  Geo.prototype.convertFromPixel = function (ecModel, finder, pixel) {\n    var coordSys = getCoordSys(finder);\n    return coordSys === this ? coordSys.pointToData(pixel) : null;\n  };\n  return Geo;\n}(View);\n;\nzrUtil.mixin(Geo, View);\nfunction getCoordSys(finder) {\n  var geoModel = finder.geoModel;\n  var seriesModel = finder.seriesModel;\n  return geoModel ? geoModel.coordinateSystem : seriesModel ? seriesModel.coordinateSystem // For map series.\n  || (seriesModel.getReferringComponents('geo', SINGLE_REFERRING).models[0] || {}).coordinateSystem : null;\n}\nexport default Geo;"],"mappings":"AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,SAAS,QAAQ,OAAO;AACjC,OAAO,KAAKC,MAAM,MAAM,0BAA0B;AAClD,OAAOC,YAAY,MAAM,kCAAkC;AAC3D,OAAOC,IAAI,MAAM,YAAY;AAC7B,OAAOC,gBAAgB,MAAM,uBAAuB;AACpD,SAASC,gBAAgB,QAAQ,qBAAqB;AACtD,SAASC,IAAI,QAAQ,mBAAmB;AACxC,IAAIC,kBAAkB,GAAG;EACvB,SAAS,EAAE;IACTC,WAAW,EAAE,IAAI;IACjBC,eAAe,EAAE;EACnB,CAAC;EACD,QAAQ,EAAE;IACRD,WAAW,EAAE,CAAC;IACdC,eAAe,EAAE;EACnB;AACF,CAAC;AACD,OAAO,IAAIC,eAAe,GAAG,CAAC,KAAK,EAAE,KAAK,CAAC;AAC3C,IAAIC,GAAG,GAAG,aAAa,UAAUC,MAAM,EAAE;EACvCZ,SAAS,CAACW,GAAG,EAAEC,MAAM,CAAC;EACtB,SAASD,GAAGA,CAACE,IAAI,EAAEC,GAAG,EAAEC,GAAG,EAAE;IAC3B,IAAIC,KAAK,GAAGJ,MAAM,CAACK,IAAI,CAAC,IAAI,EAAEJ,IAAI,EAAE;MAClCK,GAAG,EAAEH,GAAG,CAACG,GAAG;MACZC,OAAO,EAAEJ,GAAG,CAACI;IACf,CAAC,CAAC,IAAI,IAAI;IACVH,KAAK,CAACI,UAAU,GAAGV,eAAe;IAClCM,KAAK,CAACK,IAAI,GAAG,KAAK;IAClB;IACAL,KAAK,CAACM,aAAa,GAAGrB,MAAM,CAACsB,aAAa,CAAC,CAAC;IAC5CP,KAAK,CAACF,GAAG,GAAGA,GAAG;IACf,IAAIU,UAAU,GAAGT,GAAG,CAACS,UAAU;IAC/B,IAAIC,MAAM,GAAGrB,gBAAgB,CAACsB,IAAI,CAACZ,GAAG,EAAEC,GAAG,CAACY,OAAO,EAAEZ,GAAG,CAACa,YAAY,CAAC;IACtE,IAAIC,QAAQ,GAAGzB,gBAAgB,CAAC0B,cAAc,CAAChB,GAAG,CAAC;IACnD,IAAIiB,YAAY,GAAGf,KAAK,CAACe,YAAY,GAAGF,QAAQ,GAAGA,QAAQ,CAACR,IAAI,GAAG,IAAI;IACvE,IAAIW,OAAO,GAAGhB,KAAK,CAACgB,OAAO,GAAGP,MAAM,CAACO,OAAO;IAC5C,IAAIC,aAAa,GAAG1B,kBAAkB,CAACsB,QAAQ,CAACR,IAAI,CAAC;IACrDL,KAAK,CAACkB,WAAW,GAAGT,MAAM,CAACU,UAAU;IACrCnB,KAAK,CAACgB,OAAO,GAAGP,MAAM,CAACO,OAAO;IAC9B,IAAII,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,IAAId,UAAU,EAAE;MACvD;MACA,IAAIO,YAAY,KAAK,QAAQ,EAAE;QAC7B,IAAIK,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;UACzChC,IAAI,CAAC,MAAM,GAAGQ,GAAG,GAAG,iFAAiF,CAAC;QACxG;QACAU,UAAU,GAAG,IAAI;MACnB;MACA,IAAI,EAAEA,UAAU,CAACe,OAAO,IAAIf,UAAU,CAACgB,SAAS,CAAC,EAAE;QACjD,IAAIJ,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;UACzChC,IAAI,CAAC,gEAAgE,CAAC;QACxE;QACAkB,UAAU,GAAG,IAAI;MACnB;IACF;IACAR,KAAK,CAACQ,UAAU,GAAGA,UAAU;IAC7B,IAAIiB,YAAY;IAChB,IAAIjB,UAAU,EAAE;MACd;MACA,KAAK,IAAIkB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGV,OAAO,CAACW,MAAM,EAAED,CAAC,EAAE,EAAE;QACvC,IAAIE,UAAU,GAAGZ,OAAO,CAACU,CAAC,CAAC,CAACG,eAAe,CAACrB,UAAU,CAAC;QACvDiB,YAAY,GAAGA,YAAY,IAAIG,UAAU,CAACE,KAAK,CAAC,CAAC;QACjDL,YAAY,CAACM,KAAK,CAACH,UAAU,CAAC;MAChC;IACF,CAAC,MAAM;MACLH,YAAY,GAAGhB,MAAM,CAACgB,YAAY;IACpC;IACAzB,KAAK,CAACgC,eAAe,CAACP,YAAY,CAACQ,CAAC,EAAER,YAAY,CAACS,CAAC,EAAET,YAAY,CAACU,KAAK,EAAEV,YAAY,CAACW,MAAM,CAAC;IAC9F;IACA;IACA;IACApC,KAAK,CAACR,WAAW,GAAGgB,UAAU,GAAG,CAAC,GAAGvB,MAAM,CAACoD,SAAS,CAACtC,GAAG,CAACP,WAAW,EAAEyB,aAAa,CAACzB,WAAW,CAAC;IACjG;IACAQ,KAAK,CAACsC,gBAAgB,GAAG9B,UAAU,GAAG,KAAK,GAAGS,aAAa,CAACxB,eAAe;IAC3E,OAAOO,KAAK;EACd;EACAL,GAAG,CAAC4C,SAAS,CAACC,YAAY,GAAG,UAAUP,CAAC,EAAEC,CAAC,EAAEC,KAAK,EAAEC,MAAM,EAAE;IAC1D,IAAIK,IAAI,GAAG,IAAI,CAACZ,eAAe,CAAC,CAAC;IACjC,IAAIpC,eAAe,GAAG,IAAI,CAAC6C,gBAAgB;IAC3CG,IAAI,GAAGA,IAAI,CAACX,KAAK,CAAC,CAAC;IACnB,IAAIrC,eAAe,EAAE;MACnB;MACAgD,IAAI,CAACP,CAAC,GAAG,CAACO,IAAI,CAACP,CAAC,GAAGO,IAAI,CAACL,MAAM;IAChC;IACA,IAAIM,gBAAgB,GAAG,IAAI,CAACC,iBAAiB;IAC7CD,gBAAgB,CAACE,SAAS,GAAGH,IAAI,CAACI,kBAAkB,CAAC,IAAI3D,YAAY,CAAC+C,CAAC,EAAEC,CAAC,EAAEC,KAAK,EAAEC,MAAM,CAAC,CAAC;IAC3F,IAAIU,SAAS,GAAGJ,gBAAgB,CAACK,MAAM;IACvCL,gBAAgB,CAACK,MAAM,GAAG,IAAI;IAC9BL,gBAAgB,CAACM,kBAAkB,CAAC,CAAC;IACrCN,gBAAgB,CAACK,MAAM,GAAGD,SAAS;IACnC,IAAIrD,eAAe,EAAE;MACnBiD,gBAAgB,CAACO,MAAM,GAAG,CAACP,gBAAgB,CAACO,MAAM;IACpD;IACA,IAAI,CAACC,gBAAgB,CAAC,CAAC;EACzB,CAAC;EACDvD,GAAG,CAAC4C,SAAS,CAACY,SAAS,GAAG,UAAUtD,IAAI,EAAE;IACxC,OAAO,IAAI,CAACqB,WAAW,CAACkC,GAAG,CAACvD,IAAI,CAAC;EACnC,CAAC;EACDF,GAAG,CAAC4C,SAAS,CAACc,gBAAgB,GAAG,UAAUC,KAAK,EAAE;IAChD,IAAItC,OAAO,GAAG,IAAI,CAACA,OAAO;IAC1B,KAAK,IAAIU,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGV,OAAO,CAACW,MAAM,EAAED,CAAC,EAAE,EAAE;MACvC,IAAI6B,MAAM,GAAGvC,OAAO,CAACU,CAAC,CAAC;MACvB,IAAI6B,MAAM,CAAClD,IAAI,KAAK,SAAS,IAAIkD,MAAM,CAACC,OAAO,CAACF,KAAK,CAAC,EAAE;QACtD,OAAOtC,OAAO,CAACU,CAAC,CAAC;MACnB;IACF;EACF,CAAC;EACD;AACF;AACA;EACE/B,GAAG,CAAC4C,SAAS,CAACkB,WAAW,GAAG,UAAU5D,IAAI,EAAE6D,QAAQ,EAAE;IACpD,IAAI,CAACpD,aAAa,CAACqD,GAAG,CAAC9D,IAAI,EAAE6D,QAAQ,CAAC;EACxC,CAAC;EACD;AACF;AACA;EACE/D,GAAG,CAAC4C,SAAS,CAACqB,WAAW,GAAG,UAAU/D,IAAI,EAAE;IAC1C,IAAI0D,MAAM,GAAG,IAAI,CAACrC,WAAW,CAACkC,GAAG,CAACvD,IAAI,CAAC;IACvC;IACA,OAAO,IAAI,CAACS,aAAa,CAAC8C,GAAG,CAACvD,IAAI,CAAC,IAAI0D,MAAM,IAAIA,MAAM,CAACM,SAAS,CAAC,CAAC;EACrE,CAAC;EACDlE,GAAG,CAAC4C,SAAS,CAACuB,WAAW,GAAG,UAAUC,IAAI,EAAEC,MAAM,EAAEC,GAAG,EAAE;IACvD,IAAIhF,MAAM,CAACiF,QAAQ,CAACH,IAAI,CAAC,EAAE;MACzB;MACAA,IAAI,GAAG,IAAI,CAACH,WAAW,CAACG,IAAI,CAAC;IAC/B;IACA,IAAIA,IAAI,EAAE;MACR,IAAIvD,UAAU,GAAG,IAAI,CAACA,UAAU;MAChC,IAAIA,UAAU,EAAE;QACd;QACAuD,IAAI,GAAGvD,UAAU,CAACe,OAAO,CAACwC,IAAI,CAAC;MACjC;MACA,OAAOA,IAAI,IAAI,IAAI,CAACI,gBAAgB,CAACJ,IAAI,EAAEC,MAAM,EAAEC,GAAG,CAAC;IACzD;EACF,CAAC;EACDtE,GAAG,CAAC4C,SAAS,CAAC6B,WAAW,GAAG,UAAUC,KAAK,EAAEC,QAAQ,EAAEL,GAAG,EAAE;IAC1D,IAAIzD,UAAU,GAAG,IAAI,CAACA,UAAU;IAChC,IAAIA,UAAU,EAAE;MACd;MACA6D,KAAK,GAAG7D,UAAU,CAACgB,SAAS,CAAC6C,KAAK,CAAC;IACrC;IACA;IACA;IACA,OAAOA,KAAK,IAAI,IAAI,CAACE,gBAAgB,CAACF,KAAK,EAAEJ,GAAG,CAAC;EACnD,CAAC;EACD;AACF;AACA;EACEtE,GAAG,CAAC4C,SAAS,CAACgC,gBAAgB,GAAG,UAAUF,KAAK,EAAEJ,GAAG,EAAE;IACrD,OAAOrE,MAAM,CAAC2C,SAAS,CAAC6B,WAAW,CAACnE,IAAI,CAAC,IAAI,EAAEoE,KAAK,EAAE,CAAC,EAAEJ,GAAG,CAAC;EAC/D,CAAC;EACDtE,GAAG,CAAC4C,SAAS,CAAC4B,gBAAgB,GAAG,UAAUK,SAAS,EAAER,MAAM,EAAEC,GAAG,EAAE;IACjE,OAAOrE,MAAM,CAAC2C,SAAS,CAACuB,WAAW,CAAC7D,IAAI,CAAC,IAAI,EAAEuE,SAAS,EAAER,MAAM,EAAEC,GAAG,CAAC;EACxE,CAAC;EACDtE,GAAG,CAAC4C,SAAS,CAACkC,cAAc,GAAG,UAAUtE,OAAO,EAAEuE,MAAM,EAAEC,KAAK,EAAE;IAC/D,IAAIC,QAAQ,GAAGC,WAAW,CAACH,MAAM,CAAC;IAClC,OAAOE,QAAQ,KAAK,IAAI,GAAGA,QAAQ,CAACd,WAAW,CAACa,KAAK,CAAC,GAAG,IAAI;EAC/D,CAAC;EACDhF,GAAG,CAAC4C,SAAS,CAACuC,gBAAgB,GAAG,UAAU3E,OAAO,EAAEuE,MAAM,EAAEK,KAAK,EAAE;IACjE,IAAIH,QAAQ,GAAGC,WAAW,CAACH,MAAM,CAAC;IAClC,OAAOE,QAAQ,KAAK,IAAI,GAAGA,QAAQ,CAACR,WAAW,CAACW,KAAK,CAAC,GAAG,IAAI;EAC/D,CAAC;EACD,OAAOpF,GAAG;AACZ,CAAC,CAACR,IAAI,CAAC;AACP;AACAF,MAAM,CAAC+F,KAAK,CAACrF,GAAG,EAAER,IAAI,CAAC;AACvB,SAAS0F,WAAWA,CAACH,MAAM,EAAE;EAC3B,IAAIO,QAAQ,GAAGP,MAAM,CAACO,QAAQ;EAC9B,IAAIC,WAAW,GAAGR,MAAM,CAACQ,WAAW;EACpC,OAAOD,QAAQ,GAAGA,QAAQ,CAACE,gBAAgB,GAAGD,WAAW,GAAGA,WAAW,CAACC,gBAAgB,CAAC;EAAA,GACtF,CAACD,WAAW,CAACE,sBAAsB,CAAC,KAAK,EAAE/F,gBAAgB,CAAC,CAACgG,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,EAAEF,gBAAgB,GAAG,IAAI;AAC1G;AACA,eAAexF,GAAG"},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { getLayoutRect } from '../../util/layout.js';\nimport { ListIterator } from '../../util/model.js';\nimport { eqNaN, isArray, retrieve2 } from 'zrender/lib/core/util.js';\nimport { WH, XY } from '../../util/graphic.js';\nimport Model from '../../model/Model.js';\nimport { mathMax, mathMin, parsePositionSizeOption } from '../../util/number.js';\nimport { createNaNRectLike, MatrixClampOption, MatrixCellLayoutInfoType, parseCoordRangeOption, resetXYLocatorRange, xyLocatorRangeToRectOneDim } from './matrixCoordHelper.js';\nimport { error } from '../../util/log.js';\nimport { injectCoordSysByOption, simpleCoordSysInjectionProvider } from '../../core/CoordinateSystem.js';\nvar Matrix = /** @class */function () {\n  function Matrix(matrixModel, ecModel, api) {\n    this.dimensions = Matrix.dimensions;\n    this.type = 'matrix';\n    this._model = matrixModel;\n    var models = this._dimModels = {\n      x: matrixModel.getDimensionModel('x'),\n      y: matrixModel.getDimensionModel('y')\n    };\n    this._dims = {\n      x: models.x.dim,\n      y: models.y.dim\n    };\n    this._resize(matrixModel, api);\n  }\n  /**\n   * @see fetchers in `model/referHelper.ts`,\n   * which is used to parse data in ordinal way.\n   * In most series only 'x' and 'y' is required,\n   * but some series, such as heatmap, can specify value.\n   */\n  Matrix.getDimensionsInfo = function () {\n    return [{\n      name: 'x',\n      type: 'ordinal'\n    }, {\n      name: 'y',\n      type: 'ordinal'\n    }, {\n      name: 'value'\n    }];\n  };\n  Matrix.create = function (ecModel, api) {\n    var matrixList = [];\n    ecModel.eachComponent('matrix', function (matrixModel) {\n      var matrix = new Matrix(matrixModel, ecModel, api);\n      matrixList.push(matrix);\n      matrixModel.coordinateSystem = matrix;\n    });\n    // Inject coordinate system\n    // PENDING: optimize to not to travel all components?\n    //  (collect relevant components in ecModel only when model update?)\n    ecModel.eachComponent(function (mainType, componentModel) {\n      injectCoordSysByOption({\n        targetModel: componentModel,\n        coordSysType: 'matrix',\n        coordSysProvider: simpleCoordSysInjectionProvider\n      });\n    });\n    return matrixList;\n  };\n  Matrix.prototype.getRect = function () {\n    return this._rect;\n  };\n  Matrix.prototype._resize = function (matrixModel, api) {\n    var dims = this._dims;\n    var dimModels = this._dimModels;\n    var rect = this._rect = getLayoutRect(matrixModel.getBoxLayoutParams(), {\n      width: api.getWidth(),\n      height: api.getHeight()\n    });\n    layOutUnitsOnDimension(dimModels, dims, rect, 0);\n    layOutUnitsOnDimension(dimModels, dims, rect, 1);\n    layOutDimCellsRestInfoByUnit(0, dims);\n    layOutDimCellsRestInfoByUnit(1, dims);\n    layOutBodyCornerCellMerge(this._model.getBody(), dims);\n    layOutBodyCornerCellMerge(this._model.getCorner(), dims);\n  };\n  /**\n   * @implement\n   * - The input is allowed to be `[NaN/null/undefined, xxx]`/`[xxx, NaN/null/undefined]`;\n   *  the return is `[NaN, xxxresult]`/`[xxxresult, NaN]` or clamped boundary value if\n   *  `clamp` passed. This is for the usage that only get coord on single x or y.\n   * - Alwasy return an numeric array, but never be null/undefined.\n   *  If it can not be located or invalid, return `[NaN, NaN]`.\n   */\n  Matrix.prototype.dataToPoint = function (data, opt, out) {\n    out = out || [];\n    this.dataToLayout(data, opt, _dtpOutDataToLayout);\n    out[0] = _dtpOutDataToLayout.rect.x + _dtpOutDataToLayout.rect.width / 2;\n    out[1] = _dtpOutDataToLayout.rect.y + _dtpOutDataToLayout.rect.height / 2;\n    return out;\n  };\n  /**\n   * @implement\n   * - The input is allowed to be `[NaN/null/undefined, xxx]`/`[xxx, NaN/null/undefined]`;\n   *  the return is `{x: NaN, width: NaN, y: xxxresulty, height: xxxresulth}`/\n   *  `{y: NaN, height: NaN, x: xxxresultx, width: xxxresultw}` or clamped boundary value\n   *  if `clamp` passed. This is for the usage that only get coord on single x or y.\n   * - The returned `out.rect` and `out.matrixXYLocatorRange` is always an object or an 2d-array,\n   *  but never be null/undefined. If it cannot be located or invalid, `NaN` is in their\n   *  corresponding number props.\n   * - Do not provide `out.contentRect`, because it's allowed to input non-leaf dimension x/y or\n   *  a range of x/y, which determines a rect covering multiple cells (even not merged), in which\n   *  case the padding and borderWidth can not be determined to make a contentRect. Therefore only\n   *  return `out.rect` in any case for consistency. The caller is responsible for adding space to\n   *  avoid covering cell borders, if necessary.\n   */\n  Matrix.prototype.dataToLayout = function (data, opt, out) {\n    var dims = this._dims;\n    out = out || {};\n    var outRect = out.rect = out.rect || {};\n    outRect.x = outRect.y = outRect.width = outRect.height = NaN;\n    var outLocRange = out.matrixXYLocatorRange = resetXYLocatorRange(out.matrixXYLocatorRange);\n    if (!isArray(data)) {\n      if (process.env.NODE_ENV !== 'production') {\n        error('Input data must be an array in `convertToLayout`, `convertToPixel`');\n      }\n      return out;\n    }\n    parseCoordRangeOption(outLocRange, null, data, dims, retrieve2(opt && opt.clamp, MatrixClampOption.none));\n    if (!opt || !opt.ignoreMergeCells) {\n      if (!opt || opt.clamp !== MatrixClampOption.corner) {\n        this._model.getBody().expandRangeByCellMerge(outLocRange);\n      }\n      if (!opt || opt.clamp !== MatrixClampOption.body) {\n        this._model.getCorner().expandRangeByCellMerge(outLocRange);\n      }\n    }\n    xyLocatorRangeToRectOneDim(outRect, outLocRange, dims, 0);\n    xyLocatorRangeToRectOneDim(outRect, outLocRange, dims, 1);\n    return out;\n  };\n  /**\n   * The returned locator pair can be the input of `dataToPoint` or `dataToLayout`.\n   *\n   * If point[0] is out of the matrix rect,\n   *  the out[0] is NaN;\n   * else if it is on the right of top-left corner of body,\n   *  the out[0] is the oridinal number (>= 0).\n   * else\n   *  out[0] is the locator for corner or header (<= 0).\n   *\n   * The same rule goes for point[1] and out[1].\n   *\n   * But point[0] and point[1] are calculated separately, i.e.,\n   * the reuslt can be `[1, NaN]` or `[NaN, 1]` if only one dimension is out of boundary.\n   *\n   * @implement\n   */\n  Matrix.prototype.pointToData = function (point, opt, out) {\n    var dims = this._dims;\n    pointToDataOneDimPrepareCtx(_tmpCtxPointToData, 0, dims, point, opt && opt.clamp);\n    pointToDataOneDimPrepareCtx(_tmpCtxPointToData, 1, dims, point, opt && opt.clamp);\n    out = out || [];\n    out[0] = out[1] = NaN;\n    if (_tmpCtxPointToData.y === CtxPointToDataAreaType.inCorner && _tmpCtxPointToData.x === CtxPointToDataAreaType.inBody) {\n      pointToDataOnlyHeaderFillOut(_tmpCtxPointToData, out, 0, dims);\n    } else if (_tmpCtxPointToData.x === CtxPointToDataAreaType.inCorner && _tmpCtxPointToData.y === CtxPointToDataAreaType.inBody) {\n      pointToDataOnlyHeaderFillOut(_tmpCtxPointToData, out, 1, dims);\n    } else {\n      pointToDataBodyCornerFillOut(_tmpCtxPointToData, out, 0, dims);\n      pointToDataBodyCornerFillOut(_tmpCtxPointToData, out, 1, dims);\n    }\n    return out;\n  };\n  Matrix.prototype.convertToPixel = function (ecModel, finder, value, opt) {\n    var coordSys = getCoordSys(finder);\n    return coordSys === this ? coordSys.dataToPoint(value, opt) : undefined;\n  };\n  Matrix.prototype.convertToLayout = function (ecModel, finder, value, opt) {\n    var coordSys = getCoordSys(finder);\n    return coordSys === this ? coordSys.dataToLayout(value, opt) : undefined;\n  };\n  Matrix.prototype.convertFromPixel = function (ecModel, finder, pixel, opt) {\n    var coordSys = getCoordSys(finder);\n    return coordSys === this ? coordSys.pointToData(pixel, opt) : undefined;\n  };\n  Matrix.prototype.containPoint = function (point) {\n    return this._rect.contain(point[0], point[1]);\n  };\n  Matrix.dimensions = ['x', 'y', 'value'];\n  return Matrix;\n}();\nvar _dtpOutDataToLayout = {\n  rect: createNaNRectLike()\n};\nvar _ptdLevelIt = new ListIterator();\nvar _ptdDimCellIt = new ListIterator();\nfunction layOutUnitsOnDimension(dimModels, dims, matrixRect, dimIdx) {\n  var otherDimIdx = 1 - dimIdx;\n  var thisDim = dims[XY[dimIdx]];\n  var otherDim = dims[XY[otherDimIdx]];\n  // Notice: If matrix.x/y.show is false, still lay out, to ensure the\n  // consistent return of `dataToLayout`.\n  var otherDimShow = otherDim.shouldShow();\n  // Reset\n  for (var it_1 = thisDim.resetCellIterator(); it_1.next();) {\n    it_1.item.wh = it_1.item.xy = NaN;\n  }\n  for (var it_2 = otherDim.resetLayoutIterator(null, dimIdx); it_2.next();) {\n    it_2.item.wh = it_2.item.xy = NaN;\n  }\n  // Set specified size from option.\n  var restSize = matrixRect[WH[dimIdx]];\n  var restCellsCount = thisDim.getLocatorCount(dimIdx) + otherDim.getLocatorCount(dimIdx);\n  var tmpLevelModel = new Model();\n  for (var it_3 = otherDim.resetLevelIterator(); it_3.next();) {\n    // Consider `matrix.x.levelSize` and `matrix.x.levels[i].levelSize`.\n    tmpLevelModel.option = it_3.item.option;\n    tmpLevelModel.parentModel = dimModels[XY[otherDimIdx]];\n    layOutSpecified(it_3.item, otherDimShow ? tmpLevelModel.get('levelSize') : 0);\n  }\n  var tmpCellModel = new Model();\n  for (var it_4 = thisDim.resetCellIterator(); it_4.next();) {\n    // Only leaf support size specification, to avoid unnecessary complexity.\n    if (it_4.item.type === MatrixCellLayoutInfoType.leaf) {\n      tmpCellModel.option = it_4.item.option;\n      tmpCellModel.parentModel = undefined;\n      layOutSpecified(it_4.item, tmpCellModel.get('size'));\n    }\n  }\n  function layOutSpecified(item, sizeOption) {\n    var size = parseSizeOption(sizeOption, dimIdx, matrixRect);\n    if (!eqNaN(size)) {\n      item.wh = confineSize(size, restSize);\n      restSize = confineSize(restSize - item.wh);\n      restCellsCount--;\n    }\n  }\n  // Set all sizes and positions to levels and leaf cells of which size is unspecified.\n  // Contents lay out based on matrix, rather than inverse; therefore do not support\n  // calculating size based on content, but allocate equally.\n  var computedCellWH = restCellsCount ? restSize / restCellsCount : 0;\n  // If all size specified, but some space remain (may also caused by matrix.x/y.show: false)\n  // do not align to the big most edge.\n  var notAlignToBigmost = !restCellsCount && restSize >= 1; // `1` for cumulative precision error.\n  var currXY = matrixRect[XY[dimIdx]];\n  var maxLocator = thisDim.getLocatorCount(dimIdx) - 1;\n  var it = new ListIterator();\n  // Lay out levels of the perpendicular dim.\n  for (otherDim.resetLayoutIterator(it, dimIdx); it.next();) {\n    layOutUnspecified(it.item);\n  }\n  for (thisDim.resetLayoutIterator(it, dimIdx); it.next();) {\n    layOutUnspecified(it.item);\n  }\n  function layOutUnspecified(item) {\n    if (eqNaN(item.wh)) {\n      item.wh = computedCellWH;\n    }\n    item.xy = currXY;\n    if (item.id[XY[dimIdx]] === maxLocator && !notAlignToBigmost) {\n      // Align to the rightmost border, consider cumulative precision error.\n      item.wh = matrixRect[XY[dimIdx]] + matrixRect[WH[dimIdx]] - item.xy;\n    }\n    currXY += item.wh;\n  }\n}\nfunction layOutDimCellsRestInfoByUnit(dimIdx, dims) {\n  // Finally save layout info based on the unit leaves and levels.\n  for (var it_5 = dims[XY[dimIdx]].resetCellIterator(); it_5.next();) {\n    var dimCell = it_5.item;\n    layOutRectOneDimBasedOnUnit(dimCell.rect, dimIdx, dimCell.id, dimCell.span, dims);\n    // Consider level varitation on tree leaves, should extend the size to touch matrix body\n    // to avoid weird appearance.\n    layOutRectOneDimBasedOnUnit(dimCell.rect, 1 - dimIdx, dimCell.id, dimCell.span, dims);\n    if (dimCell.type === MatrixCellLayoutInfoType.nonLeaf) {\n      // `xy` and `wh` need to be saved in non-leaf since it supports locating by non-leaf\n      // in `dataToPoint` or `dataToLayout`.\n      dimCell.xy = dimCell.rect[XY[dimIdx]];\n      dimCell.wh = dimCell.rect[WH[dimIdx]];\n    }\n  }\n}\nfunction layOutBodyCornerCellMerge(bodyOrCorner, dims) {\n  bodyOrCorner.travelExistingCells(function (cell) {\n    var computedSpan = cell.span;\n    if (computedSpan) {\n      var layoutRect = cell.spanRect;\n      var id = cell.id;\n      layOutRectOneDimBasedOnUnit(layoutRect, 0, id, computedSpan, dims);\n      layOutRectOneDimBasedOnUnit(layoutRect, 1, id, computedSpan, dims);\n    }\n  });\n}\n// Save to rect for rendering.\nfunction layOutRectOneDimBasedOnUnit(outRect, dimIdx, id, span, dims) {\n  outRect[WH[dimIdx]] = 0;\n  var locator = id[XY[dimIdx]];\n  var dim = locator < 0 ? dims[XY[1 - dimIdx]] : dims[XY[dimIdx]];\n  var layoutUnit = dim.getUnitLayoutInfo(dimIdx, id[XY[dimIdx]]);\n  outRect[XY[dimIdx]] = layoutUnit.xy;\n  outRect[WH[dimIdx]] = layoutUnit.wh;\n  if (span[XY[dimIdx]] > 1) {\n    var layoutUnit2 = dim.getUnitLayoutInfo(dimIdx, id[XY[dimIdx]] + span[XY[dimIdx]] - 1);\n    // Be careful the cumulative error - cell must be aligned.\n    outRect[WH[dimIdx]] = layoutUnit2.xy + layoutUnit2.wh - layoutUnit.xy;\n  }\n}\n/**\n * Return NaN if not defined or invalid.\n */\nfunction parseSizeOption(sizeOption, dimIdx, matrixRect) {\n  var sizeNum = parsePositionSizeOption(sizeOption, matrixRect[WH[dimIdx]]);\n  return confineSize(sizeNum, matrixRect[WH[dimIdx]]);\n}\nfunction confineSize(sizeNum, sizeLimit) {\n  return Math.max(Math.min(sizeNum, retrieve2(sizeLimit, Infinity)), 0);\n}\nfunction getCoordSys(finder) {\n  var matrixModel = finder.matrixModel;\n  var seriesModel = finder.seriesModel;\n  var coordSys = matrixModel ? matrixModel.coordinateSystem : seriesModel ? seriesModel.coordinateSystem : null;\n  return coordSys;\n}\nvar CtxPointToDataAreaType = {\n  inBody: 1,\n  inCorner: 2,\n  outside: 3\n};\n// For handy performance optimization in pointToData.\nvar _tmpCtxPointToData = {\n  x: null,\n  y: null,\n  point: []\n};\nfunction pointToDataOneDimPrepareCtx(ctx, dimIdx, dims, point, clamp) {\n  var thisDim = dims[XY[dimIdx]];\n  var otherDim = dims[XY[1 - dimIdx]];\n  // Notice: considered cases: `matrix.x/y.show: false`, `matrix.x/y.data` is empty.\n  // In this cases the `layout.xy` is on the edge and `layout.wh` is `0`; they still can be\n  // use to calculate clampping.\n  var bodyMaxUnit = thisDim.getUnitLayoutInfo(dimIdx, thisDim.getLocatorCount(dimIdx) - 1);\n  var body0Unit = thisDim.getUnitLayoutInfo(dimIdx, 0);\n  var cornerMinUnit = otherDim.getUnitLayoutInfo(dimIdx, -otherDim.getLocatorCount(dimIdx));\n  var cornerMinus1Unit = otherDim.shouldShow() ? otherDim.getUnitLayoutInfo(dimIdx, -1) : null;\n  var coord = ctx.point[dimIdx] = point[dimIdx]; // Transfer the oridinal coord.\n  if (!body0Unit && !cornerMinus1Unit) {\n    ctx[XY[dimIdx]] = CtxPointToDataAreaType.outside;\n    return;\n  }\n  if (clamp === MatrixClampOption.body) {\n    if (body0Unit) {\n      ctx[XY[dimIdx]] = CtxPointToDataAreaType.inBody;\n      coord = mathMin(bodyMaxUnit.xy + bodyMaxUnit.wh, mathMax(body0Unit.xy, coord));\n      ctx.point[dimIdx] = coord;\n    } else {\n      // If clamp to body, the result must not be in header.\n      ctx[XY[dimIdx]] = CtxPointToDataAreaType.outside;\n    }\n    return;\n  } else if (clamp === MatrixClampOption.corner) {\n    if (cornerMinus1Unit) {\n      ctx[XY[dimIdx]] = CtxPointToDataAreaType.inCorner;\n      coord = mathMin(cornerMinus1Unit.xy + cornerMinus1Unit.wh, mathMax(cornerMinUnit.xy, coord));\n      ctx.point[dimIdx] = coord;\n    } else {\n      // If clamp to corner, the result must not be in body.\n      ctx[XY[dimIdx]] = CtxPointToDataAreaType.outside;\n    }\n    return;\n  }\n  var pxLoc0 = body0Unit ? body0Unit.xy : cornerMinus1Unit ? cornerMinus1Unit.xy + cornerMinus1Unit.wh : NaN;\n  var pxMin = cornerMinUnit ? cornerMinUnit.xy : pxLoc0;\n  var pxMax = bodyMaxUnit ? bodyMaxUnit.xy + bodyMaxUnit.wh : pxLoc0;\n  if (coord < pxMin) {\n    if (!clamp) {\n      // Quick pass for later calc, since mouse event on any place will enter this method if use `pointToData`.\n      ctx[XY[dimIdx]] = CtxPointToDataAreaType.outside;\n      return;\n    }\n    coord = pxMin;\n  } else if (coord > pxMax) {\n    if (!clamp) {\n      ctx[XY[dimIdx]] = CtxPointToDataAreaType.outside;\n      return;\n    }\n    coord = pxMax;\n  }\n  ctx.point[dimIdx] = coord; // Save the updated coord.\n  ctx[XY[dimIdx]] = pxLoc0 <= coord && coord <= pxMax ? CtxPointToDataAreaType.inBody : pxMin <= coord && coord <= pxLoc0 ? CtxPointToDataAreaType.inCorner : CtxPointToDataAreaType.outside;\n  // Every props in ctx must be set in every branch of this method.\n}\n// Assume partialOut has been set to NaN outside.\n// This method may fill out[0] and out[1] in one call.\nfunction pointToDataOnlyHeaderFillOut(ctx, partialOut, dimIdx, dims) {\n  var otherDimIdx = 1 - dimIdx;\n  if (ctx[XY[dimIdx]] === CtxPointToDataAreaType.outside) {\n    return;\n  }\n  for (dims[XY[dimIdx]].resetCellIterator(_ptdDimCellIt); _ptdDimCellIt.next();) {\n    var cell = _ptdDimCellIt.item;\n    if (isCoordInRect(ctx.point[dimIdx], cell.rect, dimIdx) && isCoordInRect(ctx.point[otherDimIdx], cell.rect, otherDimIdx)) {\n      // non-leaves are also allowed to be located.\n      // If the point is in x or y dimension cell area, should check both x and y coord to\n      // determine a cell; in this way a non-leaf cell can be determined.\n      partialOut[dimIdx] = cell.ordinal;\n      partialOut[otherDimIdx] = cell.id[XY[otherDimIdx]];\n      return;\n    }\n  }\n}\n// Assume partialOut has been set to NaN outside.\n// This method may fill out[0] and out[1] in one call.\nfunction pointToDataBodyCornerFillOut(ctx, partialOut, dimIdx, dims) {\n  if (ctx[XY[dimIdx]] === CtxPointToDataAreaType.outside) {\n    return;\n  }\n  var dim = ctx[XY[dimIdx]] === CtxPointToDataAreaType.inCorner ? dims[XY[1 - dimIdx]] : dims[XY[dimIdx]];\n  for (dim.resetLayoutIterator(_ptdLevelIt, dimIdx); _ptdLevelIt.next();) {\n    if (isCoordInLayoutInfo(ctx.point[dimIdx], _ptdLevelIt.item)) {\n      partialOut[dimIdx] = _ptdLevelIt.item.id[XY[dimIdx]];\n      return;\n    }\n  }\n}\nfunction isCoordInLayoutInfo(coord, cell) {\n  return cell.xy <= coord && coord <= cell.xy + cell.wh;\n}\nfunction isCoordInRect(coord, rect, dimIdx) {\n  return rect[XY[dimIdx]] <= coord && coord <= rect[XY[dimIdx]] + rect[WH[dimIdx]];\n}\nexport default Matrix;","map":{"version":3,"names":["getLayoutRect","ListIterator","eqNaN","isArray","retrieve2","WH","XY","Model","mathMax","mathMin","parsePositionSizeOption","createNaNRectLike","MatrixClampOption","MatrixCellLayoutInfoType","parseCoordRangeOption","resetXYLocatorRange","xyLocatorRangeToRectOneDim","error","injectCoordSysByOption","simpleCoordSysInjectionProvider","Matrix","matrixModel","ecModel","api","dimensions","type","_model","models","_dimModels","x","getDimensionModel","y","_dims","dim","_resize","getDimensionsInfo","name","create","matrixList","eachComponent","matrix","push","coordinateSystem","mainType","componentModel","targetModel","coordSysType","coordSysProvider","prototype","getRect","_rect","dims","dimModels","rect","getBoxLayoutParams","width","getWidth","height","getHeight","layOutUnitsOnDimension","layOutDimCellsRestInfoByUnit","layOutBodyCornerCellMerge","getBody","getCorner","dataToPoint","data","opt","out","dataToLayout","_dtpOutDataToLayout","outRect","NaN","outLocRange","matrixXYLocatorRange","process","env","NODE_ENV","clamp","none","ignoreMergeCells","corner","expandRangeByCellMerge","body","pointToData","point","pointToDataOneDimPrepareCtx","_tmpCtxPointToData","CtxPointToDataAreaType","inCorner","inBody","pointToDataOnlyHeaderFillOut","pointToDataBodyCornerFillOut","convertToPixel","finder","value","coordSys","getCoordSys","undefined","convertToLayout","convertFromPixel","pixel","containPoint","contain","_ptdLevelIt","_ptdDimCellIt","matrixRect","dimIdx","otherDimIdx","thisDim","otherDim","otherDimShow","shouldShow","it_1","resetCellIterator","next","item","wh","xy","it_2","resetLayoutIterator","restSize","restCellsCount","getLocatorCount","tmpLevelModel","it_3","resetLevelIterator","option","parentModel","layOutSpecified","get","tmpCellModel","it_4","leaf","sizeOption","size","parseSizeOption","confineSize","computedCellWH","notAlignToBigmost","currXY","maxLocator","it","layOutUnspecified","id","it_5","dimCell","layOutRectOneDimBasedOnUnit","span","nonLeaf","bodyOrCorner","travelExistingCells","cell","computedSpan","layoutRect","spanRect","locator","layoutUnit","getUnitLayoutInfo","layoutUnit2","sizeNum","sizeLimit","Math","max","min","Infinity","seriesModel","outside","ctx","bodyMaxUnit","body0Unit","cornerMinUnit","cornerMinus1Unit","coord","pxLoc0","pxMin","pxMax","partialOut","isCoordInRect","ordinal","isCoordInLayoutInfo"],"sources":["D:/code/java/program/oj/code/yuoj-frontend-master/node_modules/echarts/lib/coord/matrix/Matrix.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { getLayoutRect } from '../../util/layout.js';\nimport { ListIterator } from '../../util/model.js';\nimport { eqNaN, isArray, retrieve2 } from 'zrender/lib/core/util.js';\nimport { WH, XY } from '../../util/graphic.js';\nimport Model from '../../model/Model.js';\nimport { mathMax, mathMin, parsePositionSizeOption } from '../../util/number.js';\nimport { createNaNRectLike, MatrixClampOption, MatrixCellLayoutInfoType, parseCoordRangeOption, resetXYLocatorRange, xyLocatorRangeToRectOneDim } from './matrixCoordHelper.js';\nimport { error } from '../../util/log.js';\nimport { injectCoordSysByOption, simpleCoordSysInjectionProvider } from '../../core/CoordinateSystem.js';\nvar Matrix = /** @class */function () {\n  function Matrix(matrixModel, ecModel, api) {\n    this.dimensions = Matrix.dimensions;\n    this.type = 'matrix';\n    this._model = matrixModel;\n    var models = this._dimModels = {\n      x: matrixModel.getDimensionModel('x'),\n      y: matrixModel.getDimensionModel('y')\n    };\n    this._dims = {\n      x: models.x.dim,\n      y: models.y.dim\n    };\n    this._resize(matrixModel, api);\n  }\n  /**\n   * @see fetchers in `model/referHelper.ts`,\n   * which is used to parse data in ordinal way.\n   * In most series only 'x' and 'y' is required,\n   * but some series, such as heatmap, can specify value.\n   */\n  Matrix.getDimensionsInfo = function () {\n    return [{\n      name: 'x',\n      type: 'ordinal'\n    }, {\n      name: 'y',\n      type: 'ordinal'\n    }, {\n      name: 'value'\n    }];\n  };\n  Matrix.create = function (ecModel, api) {\n    var matrixList = [];\n    ecModel.eachComponent('matrix', function (matrixModel) {\n      var matrix = new Matrix(matrixModel, ecModel, api);\n      matrixList.push(matrix);\n      matrixModel.coordinateSystem = matrix;\n    });\n    // Inject coordinate system\n    // PENDING: optimize to not to travel all components?\n    //  (collect relevant components in ecModel only when model update?)\n    ecModel.eachComponent(function (mainType, componentModel) {\n      injectCoordSysByOption({\n        targetModel: componentModel,\n        coordSysType: 'matrix',\n        coordSysProvider: simpleCoordSysInjectionProvider\n      });\n    });\n    return matrixList;\n  };\n  Matrix.prototype.getRect = function () {\n    return this._rect;\n  };\n  Matrix.prototype._resize = function (matrixModel, api) {\n    var dims = this._dims;\n    var dimModels = this._dimModels;\n    var rect = this._rect = getLayoutRect(matrixModel.getBoxLayoutParams(), {\n      width: api.getWidth(),\n      height: api.getHeight()\n    });\n    layOutUnitsOnDimension(dimModels, dims, rect, 0);\n    layOutUnitsOnDimension(dimModels, dims, rect, 1);\n    layOutDimCellsRestInfoByUnit(0, dims);\n    layOutDimCellsRestInfoByUnit(1, dims);\n    layOutBodyCornerCellMerge(this._model.getBody(), dims);\n    layOutBodyCornerCellMerge(this._model.getCorner(), dims);\n  };\n  /**\n   * @implement\n   * - The input is allowed to be `[NaN/null/undefined, xxx]`/`[xxx, NaN/null/undefined]`;\n   *  the return is `[NaN, xxxresult]`/`[xxxresult, NaN]` or clamped boundary value if\n   *  `clamp` passed. This is for the usage that only get coord on single x or y.\n   * - Alwasy return an numeric array, but never be null/undefined.\n   *  If it can not be located or invalid, return `[NaN, NaN]`.\n   */\n  Matrix.prototype.dataToPoint = function (data, opt, out) {\n    out = out || [];\n    this.dataToLayout(data, opt, _dtpOutDataToLayout);\n    out[0] = _dtpOutDataToLayout.rect.x + _dtpOutDataToLayout.rect.width / 2;\n    out[1] = _dtpOutDataToLayout.rect.y + _dtpOutDataToLayout.rect.height / 2;\n    return out;\n  };\n  /**\n   * @implement\n   * - The input is allowed to be `[NaN/null/undefined, xxx]`/`[xxx, NaN/null/undefined]`;\n   *  the return is `{x: NaN, width: NaN, y: xxxresulty, height: xxxresulth}`/\n   *  `{y: NaN, height: NaN, x: xxxresultx, width: xxxresultw}` or clamped boundary value\n   *  if `clamp` passed. This is for the usage that only get coord on single x or y.\n   * - The returned `out.rect` and `out.matrixXYLocatorRange` is always an object or an 2d-array,\n   *  but never be null/undefined. If it cannot be located or invalid, `NaN` is in their\n   *  corresponding number props.\n   * - Do not provide `out.contentRect`, because it's allowed to input non-leaf dimension x/y or\n   *  a range of x/y, which determines a rect covering multiple cells (even not merged), in which\n   *  case the padding and borderWidth can not be determined to make a contentRect. Therefore only\n   *  return `out.rect` in any case for consistency. The caller is responsible for adding space to\n   *  avoid covering cell borders, if necessary.\n   */\n  Matrix.prototype.dataToLayout = function (data, opt, out) {\n    var dims = this._dims;\n    out = out || {};\n    var outRect = out.rect = out.rect || {};\n    outRect.x = outRect.y = outRect.width = outRect.height = NaN;\n    var outLocRange = out.matrixXYLocatorRange = resetXYLocatorRange(out.matrixXYLocatorRange);\n    if (!isArray(data)) {\n      if (process.env.NODE_ENV !== 'production') {\n        error('Input data must be an array in `convertToLayout`, `convertToPixel`');\n      }\n      return out;\n    }\n    parseCoordRangeOption(outLocRange, null, data, dims, retrieve2(opt && opt.clamp, MatrixClampOption.none));\n    if (!opt || !opt.ignoreMergeCells) {\n      if (!opt || opt.clamp !== MatrixClampOption.corner) {\n        this._model.getBody().expandRangeByCellMerge(outLocRange);\n      }\n      if (!opt || opt.clamp !== MatrixClampOption.body) {\n        this._model.getCorner().expandRangeByCellMerge(outLocRange);\n      }\n    }\n    xyLocatorRangeToRectOneDim(outRect, outLocRange, dims, 0);\n    xyLocatorRangeToRectOneDim(outRect, outLocRange, dims, 1);\n    return out;\n  };\n  /**\n   * The returned locator pair can be the input of `dataToPoint` or `dataToLayout`.\n   *\n   * If point[0] is out of the matrix rect,\n   *  the out[0] is NaN;\n   * else if it is on the right of top-left corner of body,\n   *  the out[0] is the oridinal number (>= 0).\n   * else\n   *  out[0] is the locator for corner or header (<= 0).\n   *\n   * The same rule goes for point[1] and out[1].\n   *\n   * But point[0] and point[1] are calculated separately, i.e.,\n   * the reuslt can be `[1, NaN]` or `[NaN, 1]` if only one dimension is out of boundary.\n   *\n   * @implement\n   */\n  Matrix.prototype.pointToData = function (point, opt, out) {\n    var dims = this._dims;\n    pointToDataOneDimPrepareCtx(_tmpCtxPointToData, 0, dims, point, opt && opt.clamp);\n    pointToDataOneDimPrepareCtx(_tmpCtxPointToData, 1, dims, point, opt && opt.clamp);\n    out = out || [];\n    out[0] = out[1] = NaN;\n    if (_tmpCtxPointToData.y === CtxPointToDataAreaType.inCorner && _tmpCtxPointToData.x === CtxPointToDataAreaType.inBody) {\n      pointToDataOnlyHeaderFillOut(_tmpCtxPointToData, out, 0, dims);\n    } else if (_tmpCtxPointToData.x === CtxPointToDataAreaType.inCorner && _tmpCtxPointToData.y === CtxPointToDataAreaType.inBody) {\n      pointToDataOnlyHeaderFillOut(_tmpCtxPointToData, out, 1, dims);\n    } else {\n      pointToDataBodyCornerFillOut(_tmpCtxPointToData, out, 0, dims);\n      pointToDataBodyCornerFillOut(_tmpCtxPointToData, out, 1, dims);\n    }\n    return out;\n  };\n  Matrix.prototype.convertToPixel = function (ecModel, finder, value, opt) {\n    var coordSys = getCoordSys(finder);\n    return coordSys === this ? coordSys.dataToPoint(value, opt) : undefined;\n  };\n  Matrix.prototype.convertToLayout = function (ecModel, finder, value, opt) {\n    var coordSys = getCoordSys(finder);\n    return coordSys === this ? coordSys.dataToLayout(value, opt) : undefined;\n  };\n  Matrix.prototype.convertFromPixel = function (ecModel, finder, pixel, opt) {\n    var coordSys = getCoordSys(finder);\n    return coordSys === this ? coordSys.pointToData(pixel, opt) : undefined;\n  };\n  Matrix.prototype.containPoint = function (point) {\n    return this._rect.contain(point[0], point[1]);\n  };\n  Matrix.dimensions = ['x', 'y', 'value'];\n  return Matrix;\n}();\nvar _dtpOutDataToLayout = {\n  rect: createNaNRectLike()\n};\nvar _ptdLevelIt = new ListIterator();\nvar _ptdDimCellIt = new ListIterator();\nfunction layOutUnitsOnDimension(dimModels, dims, matrixRect, dimIdx) {\n  var otherDimIdx = 1 - dimIdx;\n  var thisDim = dims[XY[dimIdx]];\n  var otherDim = dims[XY[otherDimIdx]];\n  // Notice: If matrix.x/y.show is false, still lay out, to ensure the\n  // consistent return of `dataToLayout`.\n  var otherDimShow = otherDim.shouldShow();\n  // Reset\n  for (var it_1 = thisDim.resetCellIterator(); it_1.next();) {\n    it_1.item.wh = it_1.item.xy = NaN;\n  }\n  for (var it_2 = otherDim.resetLayoutIterator(null, dimIdx); it_2.next();) {\n    it_2.item.wh = it_2.item.xy = NaN;\n  }\n  // Set specified size from option.\n  var restSize = matrixRect[WH[dimIdx]];\n  var restCellsCount = thisDim.getLocatorCount(dimIdx) + otherDim.getLocatorCount(dimIdx);\n  var tmpLevelModel = new Model();\n  for (var it_3 = otherDim.resetLevelIterator(); it_3.next();) {\n    // Consider `matrix.x.levelSize` and `matrix.x.levels[i].levelSize`.\n    tmpLevelModel.option = it_3.item.option;\n    tmpLevelModel.parentModel = dimModels[XY[otherDimIdx]];\n    layOutSpecified(it_3.item, otherDimShow ? tmpLevelModel.get('levelSize') : 0);\n  }\n  var tmpCellModel = new Model();\n  for (var it_4 = thisDim.resetCellIterator(); it_4.next();) {\n    // Only leaf support size specification, to avoid unnecessary complexity.\n    if (it_4.item.type === MatrixCellLayoutInfoType.leaf) {\n      tmpCellModel.option = it_4.item.option;\n      tmpCellModel.parentModel = undefined;\n      layOutSpecified(it_4.item, tmpCellModel.get('size'));\n    }\n  }\n  function layOutSpecified(item, sizeOption) {\n    var size = parseSizeOption(sizeOption, dimIdx, matrixRect);\n    if (!eqNaN(size)) {\n      item.wh = confineSize(size, restSize);\n      restSize = confineSize(restSize - item.wh);\n      restCellsCount--;\n    }\n  }\n  // Set all sizes and positions to levels and leaf cells of which size is unspecified.\n  // Contents lay out based on matrix, rather than inverse; therefore do not support\n  // calculating size based on content, but allocate equally.\n  var computedCellWH = restCellsCount ? restSize / restCellsCount : 0;\n  // If all size specified, but some space remain (may also caused by matrix.x/y.show: false)\n  // do not align to the big most edge.\n  var notAlignToBigmost = !restCellsCount && restSize >= 1; // `1` for cumulative precision error.\n  var currXY = matrixRect[XY[dimIdx]];\n  var maxLocator = thisDim.getLocatorCount(dimIdx) - 1;\n  var it = new ListIterator();\n  // Lay out levels of the perpendicular dim.\n  for (otherDim.resetLayoutIterator(it, dimIdx); it.next();) {\n    layOutUnspecified(it.item);\n  }\n  for (thisDim.resetLayoutIterator(it, dimIdx); it.next();) {\n    layOutUnspecified(it.item);\n  }\n  function layOutUnspecified(item) {\n    if (eqNaN(item.wh)) {\n      item.wh = computedCellWH;\n    }\n    item.xy = currXY;\n    if (item.id[XY[dimIdx]] === maxLocator && !notAlignToBigmost) {\n      // Align to the rightmost border, consider cumulative precision error.\n      item.wh = matrixRect[XY[dimIdx]] + matrixRect[WH[dimIdx]] - item.xy;\n    }\n    currXY += item.wh;\n  }\n}\nfunction layOutDimCellsRestInfoByUnit(dimIdx, dims) {\n  // Finally save layout info based on the unit leaves and levels.\n  for (var it_5 = dims[XY[dimIdx]].resetCellIterator(); it_5.next();) {\n    var dimCell = it_5.item;\n    layOutRectOneDimBasedOnUnit(dimCell.rect, dimIdx, dimCell.id, dimCell.span, dims);\n    // Consider level varitation on tree leaves, should extend the size to touch matrix body\n    // to avoid weird appearance.\n    layOutRectOneDimBasedOnUnit(dimCell.rect, 1 - dimIdx, dimCell.id, dimCell.span, dims);\n    if (dimCell.type === MatrixCellLayoutInfoType.nonLeaf) {\n      // `xy` and `wh` need to be saved in non-leaf since it supports locating by non-leaf\n      // in `dataToPoint` or `dataToLayout`.\n      dimCell.xy = dimCell.rect[XY[dimIdx]];\n      dimCell.wh = dimCell.rect[WH[dimIdx]];\n    }\n  }\n}\nfunction layOutBodyCornerCellMerge(bodyOrCorner, dims) {\n  bodyOrCorner.travelExistingCells(function (cell) {\n    var computedSpan = cell.span;\n    if (computedSpan) {\n      var layoutRect = cell.spanRect;\n      var id = cell.id;\n      layOutRectOneDimBasedOnUnit(layoutRect, 0, id, computedSpan, dims);\n      layOutRectOneDimBasedOnUnit(layoutRect, 1, id, computedSpan, dims);\n    }\n  });\n}\n// Save to rect for rendering.\nfunction layOutRectOneDimBasedOnUnit(outRect, dimIdx, id, span, dims) {\n  outRect[WH[dimIdx]] = 0;\n  var locator = id[XY[dimIdx]];\n  var dim = locator < 0 ? dims[XY[1 - dimIdx]] : dims[XY[dimIdx]];\n  var layoutUnit = dim.getUnitLayoutInfo(dimIdx, id[XY[dimIdx]]);\n  outRect[XY[dimIdx]] = layoutUnit.xy;\n  outRect[WH[dimIdx]] = layoutUnit.wh;\n  if (span[XY[dimIdx]] > 1) {\n    var layoutUnit2 = dim.getUnitLayoutInfo(dimIdx, id[XY[dimIdx]] + span[XY[dimIdx]] - 1);\n    // Be careful the cumulative error - cell must be aligned.\n    outRect[WH[dimIdx]] = layoutUnit2.xy + layoutUnit2.wh - layoutUnit.xy;\n  }\n}\n/**\n * Return NaN if not defined or invalid.\n */\nfunction parseSizeOption(sizeOption, dimIdx, matrixRect) {\n  var sizeNum = parsePositionSizeOption(sizeOption, matrixRect[WH[dimIdx]]);\n  return confineSize(sizeNum, matrixRect[WH[dimIdx]]);\n}\nfunction confineSize(sizeNum, sizeLimit) {\n  return Math.max(Math.min(sizeNum, retrieve2(sizeLimit, Infinity)), 0);\n}\nfunction getCoordSys(finder) {\n  var matrixModel = finder.matrixModel;\n  var seriesModel = finder.seriesModel;\n  var coordSys = matrixModel ? matrixModel.coordinateSystem : seriesModel ? seriesModel.coordinateSystem : null;\n  return coordSys;\n}\nvar CtxPointToDataAreaType = {\n  inBody: 1,\n  inCorner: 2,\n  outside: 3\n};\n// For handy performance optimization in pointToData.\nvar _tmpCtxPointToData = {\n  x: null,\n  y: null,\n  point: []\n};\nfunction pointToDataOneDimPrepareCtx(ctx, dimIdx, dims, point, clamp) {\n  var thisDim = dims[XY[dimIdx]];\n  var otherDim = dims[XY[1 - dimIdx]];\n  // Notice: considered cases: `matrix.x/y.show: false`, `matrix.x/y.data` is empty.\n  // In this cases the `layout.xy` is on the edge and `layout.wh` is `0`; they still can be\n  // use to calculate clampping.\n  var bodyMaxUnit = thisDim.getUnitLayoutInfo(dimIdx, thisDim.getLocatorCount(dimIdx) - 1);\n  var body0Unit = thisDim.getUnitLayoutInfo(dimIdx, 0);\n  var cornerMinUnit = otherDim.getUnitLayoutInfo(dimIdx, -otherDim.getLocatorCount(dimIdx));\n  var cornerMinus1Unit = otherDim.shouldShow() ? otherDim.getUnitLayoutInfo(dimIdx, -1) : null;\n  var coord = ctx.point[dimIdx] = point[dimIdx]; // Transfer the oridinal coord.\n  if (!body0Unit && !cornerMinus1Unit) {\n    ctx[XY[dimIdx]] = CtxPointToDataAreaType.outside;\n    return;\n  }\n  if (clamp === MatrixClampOption.body) {\n    if (body0Unit) {\n      ctx[XY[dimIdx]] = CtxPointToDataAreaType.inBody;\n      coord = mathMin(bodyMaxUnit.xy + bodyMaxUnit.wh, mathMax(body0Unit.xy, coord));\n      ctx.point[dimIdx] = coord;\n    } else {\n      // If clamp to body, the result must not be in header.\n      ctx[XY[dimIdx]] = CtxPointToDataAreaType.outside;\n    }\n    return;\n  } else if (clamp === MatrixClampOption.corner) {\n    if (cornerMinus1Unit) {\n      ctx[XY[dimIdx]] = CtxPointToDataAreaType.inCorner;\n      coord = mathMin(cornerMinus1Unit.xy + cornerMinus1Unit.wh, mathMax(cornerMinUnit.xy, coord));\n      ctx.point[dimIdx] = coord;\n    } else {\n      // If clamp to corner, the result must not be in body.\n      ctx[XY[dimIdx]] = CtxPointToDataAreaType.outside;\n    }\n    return;\n  }\n  var pxLoc0 = body0Unit ? body0Unit.xy : cornerMinus1Unit ? cornerMinus1Unit.xy + cornerMinus1Unit.wh : NaN;\n  var pxMin = cornerMinUnit ? cornerMinUnit.xy : pxLoc0;\n  var pxMax = bodyMaxUnit ? bodyMaxUnit.xy + bodyMaxUnit.wh : pxLoc0;\n  if (coord < pxMin) {\n    if (!clamp) {\n      // Quick pass for later calc, since mouse event on any place will enter this method if use `pointToData`.\n      ctx[XY[dimIdx]] = CtxPointToDataAreaType.outside;\n      return;\n    }\n    coord = pxMin;\n  } else if (coord > pxMax) {\n    if (!clamp) {\n      ctx[XY[dimIdx]] = CtxPointToDataAreaType.outside;\n      return;\n    }\n    coord = pxMax;\n  }\n  ctx.point[dimIdx] = coord; // Save the updated coord.\n  ctx[XY[dimIdx]] = pxLoc0 <= coord && coord <= pxMax ? CtxPointToDataAreaType.inBody : pxMin <= coord && coord <= pxLoc0 ? CtxPointToDataAreaType.inCorner : CtxPointToDataAreaType.outside;\n  // Every props in ctx must be set in every branch of this method.\n}\n// Assume partialOut has been set to NaN outside.\n// This method may fill out[0] and out[1] in one call.\nfunction pointToDataOnlyHeaderFillOut(ctx, partialOut, dimIdx, dims) {\n  var otherDimIdx = 1 - dimIdx;\n  if (ctx[XY[dimIdx]] === CtxPointToDataAreaType.outside) {\n    return;\n  }\n  for (dims[XY[dimIdx]].resetCellIterator(_ptdDimCellIt); _ptdDimCellIt.next();) {\n    var cell = _ptdDimCellIt.item;\n    if (isCoordInRect(ctx.point[dimIdx], cell.rect, dimIdx) && isCoordInRect(ctx.point[otherDimIdx], cell.rect, otherDimIdx)) {\n      // non-leaves are also allowed to be located.\n      // If the point is in x or y dimension cell area, should check both x and y coord to\n      // determine a cell; in this way a non-leaf cell can be determined.\n      partialOut[dimIdx] = cell.ordinal;\n      partialOut[otherDimIdx] = cell.id[XY[otherDimIdx]];\n      return;\n    }\n  }\n}\n// Assume partialOut has been set to NaN outside.\n// This method may fill out[0] and out[1] in one call.\nfunction pointToDataBodyCornerFillOut(ctx, partialOut, dimIdx, dims) {\n  if (ctx[XY[dimIdx]] === CtxPointToDataAreaType.outside) {\n    return;\n  }\n  var dim = ctx[XY[dimIdx]] === CtxPointToDataAreaType.inCorner ? dims[XY[1 - dimIdx]] : dims[XY[dimIdx]];\n  for (dim.resetLayoutIterator(_ptdLevelIt, dimIdx); _ptdLevelIt.next();) {\n    if (isCoordInLayoutInfo(ctx.point[dimIdx], _ptdLevelIt.item)) {\n      partialOut[dimIdx] = _ptdLevelIt.item.id[XY[dimIdx]];\n      return;\n    }\n  }\n}\nfunction isCoordInLayoutInfo(coord, cell) {\n  return cell.xy <= coord && coord <= cell.xy + cell.wh;\n}\nfunction isCoordInRect(coord, rect, dimIdx) {\n  return rect[XY[dimIdx]] <= coord && coord <= rect[XY[dimIdx]] + rect[WH[dimIdx]];\n}\nexport default Matrix;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
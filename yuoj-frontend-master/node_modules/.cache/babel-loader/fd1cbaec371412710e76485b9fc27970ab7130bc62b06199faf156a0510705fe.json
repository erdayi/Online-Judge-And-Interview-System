{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nimport { Range } from './range.js';\n/**\n * A range of lines (1-based).\n */\nexport class LineRange {\n  static fromRange(range) {\n    return new LineRange(range.startLineNumber, range.endLineNumber);\n  }\n  static subtract(a, b) {\n    if (!b) {\n      return [a];\n    }\n    if (a.startLineNumber < b.startLineNumber && b.endLineNumberExclusive < a.endLineNumberExclusive) {\n      return [new LineRange(a.startLineNumber, b.startLineNumber), new LineRange(b.endLineNumberExclusive, a.endLineNumberExclusive)];\n    } else if (b.startLineNumber <= a.startLineNumber && a.endLineNumberExclusive <= b.endLineNumberExclusive) {\n      return [];\n    } else if (b.endLineNumberExclusive < a.endLineNumberExclusive) {\n      return [new LineRange(Math.max(b.endLineNumberExclusive, a.startLineNumber), a.endLineNumberExclusive)];\n    } else {\n      return [new LineRange(a.startLineNumber, Math.min(b.startLineNumber, a.endLineNumberExclusive))];\n    }\n  }\n  /**\n   * @param lineRanges An array of sorted line ranges.\n   */\n  static joinMany(lineRanges) {\n    if (lineRanges.length === 0) {\n      return [];\n    }\n    let result = lineRanges[0];\n    for (let i = 1; i < lineRanges.length; i++) {\n      result = this.join(result, lineRanges[i]);\n    }\n    return result;\n  }\n  /**\n   * @param lineRanges1 Must be sorted.\n   * @param lineRanges2 Must be sorted.\n   */\n  static join(lineRanges1, lineRanges2) {\n    if (lineRanges1.length === 0) {\n      return lineRanges2;\n    }\n    if (lineRanges2.length === 0) {\n      return lineRanges1;\n    }\n    const result = [];\n    let i1 = 0;\n    let i2 = 0;\n    let current = null;\n    while (i1 < lineRanges1.length || i2 < lineRanges2.length) {\n      let next = null;\n      if (i1 < lineRanges1.length && i2 < lineRanges2.length) {\n        const lineRange1 = lineRanges1[i1];\n        const lineRange2 = lineRanges2[i2];\n        if (lineRange1.startLineNumber < lineRange2.startLineNumber) {\n          next = lineRange1;\n          i1++;\n        } else {\n          next = lineRange2;\n          i2++;\n        }\n      } else if (i1 < lineRanges1.length) {\n        next = lineRanges1[i1];\n        i1++;\n      } else {\n        next = lineRanges2[i2];\n        i2++;\n      }\n      if (current === null) {\n        current = next;\n      } else {\n        if (current.endLineNumberExclusive >= next.startLineNumber) {\n          // merge\n          current = new LineRange(current.startLineNumber, Math.max(current.endLineNumberExclusive, next.endLineNumberExclusive));\n        } else {\n          // push\n          result.push(current);\n          current = next;\n        }\n      }\n    }\n    if (current !== null) {\n      result.push(current);\n    }\n    return result;\n  }\n  static ofLength(startLineNumber, length) {\n    return new LineRange(startLineNumber, startLineNumber + length);\n  }\n  /**\n   * @internal\n   */\n  static deserialize(lineRange) {\n    return new LineRange(lineRange[0], lineRange[1]);\n  }\n  constructor(startLineNumber, endLineNumberExclusive) {\n    if (startLineNumber > endLineNumberExclusive) {\n      throw new BugIndicatingError(`startLineNumber ${startLineNumber} cannot be after endLineNumberExclusive ${endLineNumberExclusive}`);\n    }\n    this.startLineNumber = startLineNumber;\n    this.endLineNumberExclusive = endLineNumberExclusive;\n  }\n  /**\n   * Indicates if this line range contains the given line number.\n   */\n  contains(lineNumber) {\n    return this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;\n  }\n  /**\n   * Indicates if this line range is empty.\n   */\n  get isEmpty() {\n    return this.startLineNumber === this.endLineNumberExclusive;\n  }\n  /**\n   * Moves this line range by the given offset of line numbers.\n   */\n  delta(offset) {\n    return new LineRange(this.startLineNumber + offset, this.endLineNumberExclusive + offset);\n  }\n  /**\n   * The number of lines this line range spans.\n   */\n  get length() {\n    return this.endLineNumberExclusive - this.startLineNumber;\n  }\n  /**\n   * Creates a line range that combines this and the given line range.\n   */\n  join(other) {\n    return new LineRange(Math.min(this.startLineNumber, other.startLineNumber), Math.max(this.endLineNumberExclusive, other.endLineNumberExclusive));\n  }\n  toString() {\n    return `[${this.startLineNumber},${this.endLineNumberExclusive})`;\n  }\n  /**\n   * The resulting range is empty if the ranges do not intersect, but touch.\n   * If the ranges don't even touch, the result is undefined.\n   */\n  intersect(other) {\n    const startLineNumber = Math.max(this.startLineNumber, other.startLineNumber);\n    const endLineNumberExclusive = Math.min(this.endLineNumberExclusive, other.endLineNumberExclusive);\n    if (startLineNumber <= endLineNumberExclusive) {\n      return new LineRange(startLineNumber, endLineNumberExclusive);\n    }\n    return undefined;\n  }\n  intersectsStrict(other) {\n    return this.startLineNumber < other.endLineNumberExclusive && other.startLineNumber < this.endLineNumberExclusive;\n  }\n  overlapOrTouch(other) {\n    return this.startLineNumber <= other.endLineNumberExclusive && other.startLineNumber <= this.endLineNumberExclusive;\n  }\n  equals(b) {\n    return this.startLineNumber === b.startLineNumber && this.endLineNumberExclusive === b.endLineNumberExclusive;\n  }\n  toInclusiveRange() {\n    if (this.isEmpty) {\n      return null;\n    }\n    return new Range(this.startLineNumber, 1, this.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER);\n  }\n  toExclusiveRange() {\n    return new Range(this.startLineNumber, 1, this.endLineNumberExclusive, 1);\n  }\n  mapToLineArray(f) {\n    const result = [];\n    for (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {\n      result.push(f(lineNumber));\n    }\n    return result;\n  }\n  forEach(f) {\n    for (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {\n      f(lineNumber);\n    }\n  }\n  /**\n   * @internal\n   */\n  serialize() {\n    return [this.startLineNumber, this.endLineNumberExclusive];\n  }\n  includes(lineNumber) {\n    return this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;\n  }\n}","map":{"version":3,"names":["BugIndicatingError","Range","LineRange","fromRange","range","startLineNumber","endLineNumber","subtract","a","b","endLineNumberExclusive","Math","max","min","joinMany","lineRanges","length","result","i","join","lineRanges1","lineRanges2","i1","i2","current","next","lineRange1","lineRange2","push","ofLength","deserialize","lineRange","constructor","contains","lineNumber","isEmpty","delta","offset","other","toString","intersect","undefined","intersectsStrict","overlapOrTouch","equals","toInclusiveRange","Number","MAX_SAFE_INTEGER","toExclusiveRange","mapToLineArray","f","forEach","serialize","includes"],"sources":["D:/code/java/program/oj/code/yuoj-frontend-master/node_modules/monaco-editor/esm/vs/editor/common/core/lineRange.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nimport { Range } from './range.js';\n/**\n * A range of lines (1-based).\n */\nexport class LineRange {\n    static fromRange(range) {\n        return new LineRange(range.startLineNumber, range.endLineNumber);\n    }\n    static subtract(a, b) {\n        if (!b) {\n            return [a];\n        }\n        if (a.startLineNumber < b.startLineNumber && b.endLineNumberExclusive < a.endLineNumberExclusive) {\n            return [\n                new LineRange(a.startLineNumber, b.startLineNumber),\n                new LineRange(b.endLineNumberExclusive, a.endLineNumberExclusive)\n            ];\n        }\n        else if (b.startLineNumber <= a.startLineNumber && a.endLineNumberExclusive <= b.endLineNumberExclusive) {\n            return [];\n        }\n        else if (b.endLineNumberExclusive < a.endLineNumberExclusive) {\n            return [new LineRange(Math.max(b.endLineNumberExclusive, a.startLineNumber), a.endLineNumberExclusive)];\n        }\n        else {\n            return [new LineRange(a.startLineNumber, Math.min(b.startLineNumber, a.endLineNumberExclusive))];\n        }\n    }\n    /**\n     * @param lineRanges An array of sorted line ranges.\n     */\n    static joinMany(lineRanges) {\n        if (lineRanges.length === 0) {\n            return [];\n        }\n        let result = lineRanges[0];\n        for (let i = 1; i < lineRanges.length; i++) {\n            result = this.join(result, lineRanges[i]);\n        }\n        return result;\n    }\n    /**\n     * @param lineRanges1 Must be sorted.\n     * @param lineRanges2 Must be sorted.\n     */\n    static join(lineRanges1, lineRanges2) {\n        if (lineRanges1.length === 0) {\n            return lineRanges2;\n        }\n        if (lineRanges2.length === 0) {\n            return lineRanges1;\n        }\n        const result = [];\n        let i1 = 0;\n        let i2 = 0;\n        let current = null;\n        while (i1 < lineRanges1.length || i2 < lineRanges2.length) {\n            let next = null;\n            if (i1 < lineRanges1.length && i2 < lineRanges2.length) {\n                const lineRange1 = lineRanges1[i1];\n                const lineRange2 = lineRanges2[i2];\n                if (lineRange1.startLineNumber < lineRange2.startLineNumber) {\n                    next = lineRange1;\n                    i1++;\n                }\n                else {\n                    next = lineRange2;\n                    i2++;\n                }\n            }\n            else if (i1 < lineRanges1.length) {\n                next = lineRanges1[i1];\n                i1++;\n            }\n            else {\n                next = lineRanges2[i2];\n                i2++;\n            }\n            if (current === null) {\n                current = next;\n            }\n            else {\n                if (current.endLineNumberExclusive >= next.startLineNumber) {\n                    // merge\n                    current = new LineRange(current.startLineNumber, Math.max(current.endLineNumberExclusive, next.endLineNumberExclusive));\n                }\n                else {\n                    // push\n                    result.push(current);\n                    current = next;\n                }\n            }\n        }\n        if (current !== null) {\n            result.push(current);\n        }\n        return result;\n    }\n    static ofLength(startLineNumber, length) {\n        return new LineRange(startLineNumber, startLineNumber + length);\n    }\n    /**\n     * @internal\n     */\n    static deserialize(lineRange) {\n        return new LineRange(lineRange[0], lineRange[1]);\n    }\n    constructor(startLineNumber, endLineNumberExclusive) {\n        if (startLineNumber > endLineNumberExclusive) {\n            throw new BugIndicatingError(`startLineNumber ${startLineNumber} cannot be after endLineNumberExclusive ${endLineNumberExclusive}`);\n        }\n        this.startLineNumber = startLineNumber;\n        this.endLineNumberExclusive = endLineNumberExclusive;\n    }\n    /**\n     * Indicates if this line range contains the given line number.\n     */\n    contains(lineNumber) {\n        return this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;\n    }\n    /**\n     * Indicates if this line range is empty.\n     */\n    get isEmpty() {\n        return this.startLineNumber === this.endLineNumberExclusive;\n    }\n    /**\n     * Moves this line range by the given offset of line numbers.\n     */\n    delta(offset) {\n        return new LineRange(this.startLineNumber + offset, this.endLineNumberExclusive + offset);\n    }\n    /**\n     * The number of lines this line range spans.\n     */\n    get length() {\n        return this.endLineNumberExclusive - this.startLineNumber;\n    }\n    /**\n     * Creates a line range that combines this and the given line range.\n     */\n    join(other) {\n        return new LineRange(Math.min(this.startLineNumber, other.startLineNumber), Math.max(this.endLineNumberExclusive, other.endLineNumberExclusive));\n    }\n    toString() {\n        return `[${this.startLineNumber},${this.endLineNumberExclusive})`;\n    }\n    /**\n     * The resulting range is empty if the ranges do not intersect, but touch.\n     * If the ranges don't even touch, the result is undefined.\n     */\n    intersect(other) {\n        const startLineNumber = Math.max(this.startLineNumber, other.startLineNumber);\n        const endLineNumberExclusive = Math.min(this.endLineNumberExclusive, other.endLineNumberExclusive);\n        if (startLineNumber <= endLineNumberExclusive) {\n            return new LineRange(startLineNumber, endLineNumberExclusive);\n        }\n        return undefined;\n    }\n    intersectsStrict(other) {\n        return this.startLineNumber < other.endLineNumberExclusive && other.startLineNumber < this.endLineNumberExclusive;\n    }\n    overlapOrTouch(other) {\n        return this.startLineNumber <= other.endLineNumberExclusive && other.startLineNumber <= this.endLineNumberExclusive;\n    }\n    equals(b) {\n        return this.startLineNumber === b.startLineNumber && this.endLineNumberExclusive === b.endLineNumberExclusive;\n    }\n    toInclusiveRange() {\n        if (this.isEmpty) {\n            return null;\n        }\n        return new Range(this.startLineNumber, 1, this.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER);\n    }\n    toExclusiveRange() {\n        return new Range(this.startLineNumber, 1, this.endLineNumberExclusive, 1);\n    }\n    mapToLineArray(f) {\n        const result = [];\n        for (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {\n            result.push(f(lineNumber));\n        }\n        return result;\n    }\n    forEach(f) {\n        for (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {\n            f(lineNumber);\n        }\n    }\n    /**\n     * @internal\n     */\n    serialize() {\n        return [this.startLineNumber, this.endLineNumberExclusive];\n    }\n    includes(lineNumber) {\n        return this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
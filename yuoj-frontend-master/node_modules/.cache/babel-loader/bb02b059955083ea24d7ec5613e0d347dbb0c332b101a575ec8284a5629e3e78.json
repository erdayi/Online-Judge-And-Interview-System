{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { RunOnceScheduler } from '../../../../base/common/async.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { derived, observableSignal, observableSignalFromEvent, observableValue, transaction, waitForState } from '../../../../base/common/observable.js';\nimport { autorunWithStore2 } from '../../../../base/common/observableImpl/autorun.js';\nimport { isDefined } from '../../../../base/common/types.js';\nimport { LineRange } from '../../../common/core/lineRange.js';\nimport { Range } from '../../../common/core/range.js';\nimport { LineRangeMapping, MovedText, RangeMapping, SimpleLineRangeMapping } from '../../../common/diff/linesDiffComputer.js';\nimport { lineRangeMappingFromRangeMappings } from '../../../common/diff/standardLinesDiffComputer.js';\nimport { TextEditInfo } from '../../../common/model/bracketPairsTextModelPart/bracketPairsTree/beforeEditPositionMapper.js';\nimport { combineTextEditInfos } from '../../../common/model/bracketPairsTextModelPart/bracketPairsTree/combineTextEditInfos.js';\nimport { lengthAdd, lengthDiffNonNegative, lengthGetLineCount, lengthOfRange, lengthToPosition, lengthZero, positionToLength } from '../../../common/model/bracketPairsTextModelPart/bracketPairsTree/length.js';\nexport class DiffEditorViewModel extends Disposable {\n  constructor(model, _options, documentDiffProvider) {\n    super();\n    this.model = model;\n    this._options = _options;\n    this._isDiffUpToDate = observableValue('isDiffUpToDate', false);\n    this.isDiffUpToDate = this._isDiffUpToDate;\n    this._diff = observableValue('diff', undefined);\n    this.diff = this._diff;\n    this._unchangedRegions = observableValue('unchangedRegion', {\n      regions: [],\n      originalDecorationIds: [],\n      modifiedDecorationIds: []\n    });\n    this.unchangedRegions = derived('unchangedRegions', r => {\n      if (this._options.collapseUnchangedRegions.read(r)) {\n        return this._unchangedRegions.read(r).regions;\n      } else {\n        // Reset state\n        transaction(tx => {\n          for (const r of this._unchangedRegions.get().regions) {\n            r.setState(0, 0, tx);\n          }\n        });\n        return [];\n      }\n    });\n    this.syncedMovedTexts = observableValue('syncedMovedText', undefined);\n    const contentChangedSignal = observableSignal('contentChangedSignal');\n    const debouncer = this._register(new RunOnceScheduler(() => contentChangedSignal.trigger(undefined), 200));\n    const updateUnchangedRegions = (result, tx) => {\n      const newUnchangedRegions = UnchangedRegion.fromDiffs(result.changes, model.original.getLineCount(), model.modified.getLineCount());\n      // Transfer state from cur state\n      const lastUnchangedRegions = this._unchangedRegions.get();\n      const lastUnchangedRegionsOrigRanges = lastUnchangedRegions.originalDecorationIds.map(id => model.original.getDecorationRange(id)).filter(r => !!r).map(r => LineRange.fromRange(r));\n      const lastUnchangedRegionsModRanges = lastUnchangedRegions.modifiedDecorationIds.map(id => model.modified.getDecorationRange(id)).filter(r => !!r).map(r => LineRange.fromRange(r));\n      const originalDecorationIds = model.original.deltaDecorations(lastUnchangedRegions.originalDecorationIds, newUnchangedRegions.map(r => ({\n        range: r.originalRange.toInclusiveRange(),\n        options: {\n          description: 'unchanged'\n        }\n      })));\n      const modifiedDecorationIds = model.modified.deltaDecorations(lastUnchangedRegions.modifiedDecorationIds, newUnchangedRegions.map(r => ({\n        range: r.modifiedRange.toInclusiveRange(),\n        options: {\n          description: 'unchanged'\n        }\n      })));\n      for (const r of newUnchangedRegions) {\n        for (let i = 0; i < lastUnchangedRegions.regions.length; i++) {\n          if (r.originalRange.intersectsStrict(lastUnchangedRegionsOrigRanges[i]) && r.modifiedRange.intersectsStrict(lastUnchangedRegionsModRanges[i])) {\n            r.setHiddenModifiedRange(lastUnchangedRegions.regions[i].getHiddenModifiedRange(undefined), tx);\n            break;\n          }\n        }\n      }\n      this._unchangedRegions.set({\n        regions: newUnchangedRegions,\n        originalDecorationIds,\n        modifiedDecorationIds\n      }, tx);\n    };\n    this._register(model.modified.onDidChangeContent(e => {\n      const diff = this._diff.get();\n      if (!diff) {\n        return;\n      }\n      const textEdits = TextEditInfo.fromModelContentChanges(e.changes);\n      const result = applyModifiedEdits(this._lastDiff, textEdits, model.original, model.modified);\n      if (result) {\n        this._lastDiff = result;\n        transaction(tx => {\n          this._diff.set(DiffState.fromDiffResult(this._lastDiff), tx);\n          updateUnchangedRegions(result, tx);\n          const currentSyncedMovedText = this.syncedMovedTexts.get();\n          this.syncedMovedTexts.set(currentSyncedMovedText ? this._lastDiff.moves.find(m => m.lineRangeMapping.modified.intersect(currentSyncedMovedText.lineRangeMapping.modified)) : undefined, tx);\n        });\n      }\n      debouncer.schedule();\n    }));\n    this._register(model.original.onDidChangeContent(e => {\n      const diff = this._diff.get();\n      if (!diff) {\n        return;\n      }\n      const textEdits = TextEditInfo.fromModelContentChanges(e.changes);\n      const result = applyOriginalEdits(this._lastDiff, textEdits, model.original, model.modified);\n      if (result) {\n        this._lastDiff = result;\n        transaction(tx => {\n          this._diff.set(DiffState.fromDiffResult(this._lastDiff), tx);\n          updateUnchangedRegions(result, tx);\n          const currentSyncedMovedText = this.syncedMovedTexts.get();\n          this.syncedMovedTexts.set(currentSyncedMovedText ? this._lastDiff.moves.find(m => m.lineRangeMapping.modified.intersect(currentSyncedMovedText.lineRangeMapping.modified)) : undefined, tx);\n        });\n      }\n      debouncer.schedule();\n    }));\n    const documentDiffProviderOptionChanged = observableSignalFromEvent('documentDiffProviderOptionChanged', documentDiffProvider.onDidChange);\n    this._register(autorunWithStore2('compute diff', (reader, store) => __awaiter(this, void 0, void 0, function* () {\n      var _a, _b;\n      debouncer.cancel();\n      contentChangedSignal.read(reader);\n      documentDiffProviderOptionChanged.read(reader);\n      this._isDiffUpToDate.set(false, undefined);\n      let originalTextEditInfos = [];\n      store.add(model.original.onDidChangeContent(e => {\n        const edits = TextEditInfo.fromModelContentChanges(e.changes);\n        originalTextEditInfos = combineTextEditInfos(originalTextEditInfos, edits);\n      }));\n      let modifiedTextEditInfos = [];\n      store.add(model.modified.onDidChangeContent(e => {\n        const edits = TextEditInfo.fromModelContentChanges(e.changes);\n        modifiedTextEditInfos = combineTextEditInfos(modifiedTextEditInfos, edits);\n      }));\n      let result = yield documentDiffProvider.computeDiff(model.original, model.modified, {\n        ignoreTrimWhitespace: this._options.ignoreTrimWhitespace.read(reader),\n        maxComputationTimeMs: this._options.maxComputationTimeMs.read(reader),\n        computeMoves: this._options.showMoves.read(reader)\n      });\n      result = (_a = applyOriginalEdits(result, originalTextEditInfos, model.original, model.modified)) !== null && _a !== void 0 ? _a : result;\n      result = (_b = applyModifiedEdits(result, modifiedTextEditInfos, model.original, model.modified)) !== null && _b !== void 0 ? _b : result;\n      transaction(tx => {\n        updateUnchangedRegions(result, tx);\n        this._lastDiff = result;\n        const state = DiffState.fromDiffResult(result);\n        this._diff.set(state, tx);\n        this._isDiffUpToDate.set(true, tx);\n        const currentSyncedMovedText = this.syncedMovedTexts.get();\n        this.syncedMovedTexts.set(currentSyncedMovedText ? this._lastDiff.moves.find(m => m.lineRangeMapping.modified.intersect(currentSyncedMovedText.lineRangeMapping.modified)) : undefined, tx);\n      });\n    })));\n  }\n  ensureModifiedLineIsVisible(lineNumber, tx) {\n    var _a;\n    if (((_a = this.diff.get()) === null || _a === void 0 ? void 0 : _a.mappings.length) === 0) {\n      return;\n    }\n    const unchangedRegions = this._unchangedRegions.get().regions;\n    for (const r of unchangedRegions) {\n      if (r.getHiddenModifiedRange(undefined).contains(lineNumber)) {\n        r.showAll(tx); // TODO only unhide what is needed\n        return;\n      }\n    }\n  }\n  ensureOriginalLineIsVisible(lineNumber, tx) {\n    var _a;\n    if (((_a = this.diff.get()) === null || _a === void 0 ? void 0 : _a.mappings.length) === 0) {\n      return;\n    }\n    const unchangedRegions = this._unchangedRegions.get().regions;\n    for (const r of unchangedRegions) {\n      if (r.getHiddenOriginalRange(undefined).contains(lineNumber)) {\n        r.showAll(tx); // TODO only unhide what is needed\n        return;\n      }\n    }\n  }\n  waitForDiff() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield waitForState(this.isDiffUpToDate, s => s);\n    });\n  }\n  serializeState() {\n    const regions = this._unchangedRegions.get();\n    return {\n      collapsedRegions: regions.regions.map(r => ({\n        range: r.getHiddenModifiedRange(undefined).serialize()\n      }))\n    };\n  }\n  restoreSerializedState(state) {\n    const ranges = state.collapsedRegions.map(r => LineRange.deserialize(r.range));\n    const regions = this._unchangedRegions.get();\n    transaction(tx => {\n      for (const r of regions.regions) {\n        for (const range of ranges) {\n          if (r.modifiedRange.intersect(range)) {\n            r.setHiddenModifiedRange(range, tx);\n            break;\n          }\n        }\n      }\n    });\n  }\n}\nexport class DiffState {\n  static fromDiffResult(result) {\n    return new DiffState(result.changes.map(c => new DiffMapping(c)), result.moves || [], result.identical, result.quitEarly);\n  }\n  constructor(mappings, movedTexts, identical, quitEarly) {\n    this.mappings = mappings;\n    this.movedTexts = movedTexts;\n    this.identical = identical;\n    this.quitEarly = quitEarly;\n  }\n}\nexport class DiffMapping {\n  constructor(lineRangeMapping) {\n    this.lineRangeMapping = lineRangeMapping;\n    /*\n    readonly movedTo: MovedText | undefined,\n    readonly movedFrom: MovedText | undefined,\n     if (movedTo) {\n        assertFn(() =>\n            movedTo.lineRangeMapping.modifiedRange.equals(lineRangeMapping.modifiedRange)\n            && lineRangeMapping.originalRange.isEmpty\n            && !movedFrom\n        );\n    } else if (movedFrom) {\n        assertFn(() =>\n            movedFrom.lineRangeMapping.originalRange.equals(lineRangeMapping.originalRange)\n            && lineRangeMapping.modifiedRange.isEmpty\n            && !movedTo\n        );\n    }\n    */\n  }\n}\n\nexport class UnchangedRegion {\n  static fromDiffs(changes, originalLineCount, modifiedLineCount) {\n    const inversedMappings = LineRangeMapping.inverse(changes, originalLineCount, modifiedLineCount);\n    const result = [];\n    const minHiddenLineCount = 3;\n    const minContext = 3;\n    for (const mapping of inversedMappings) {\n      let origStart = mapping.originalRange.startLineNumber;\n      let modStart = mapping.modifiedRange.startLineNumber;\n      let length = mapping.originalRange.length;\n      const atStart = origStart === 1 && modStart === 1;\n      const atEnd = origStart + length === originalLineCount + 1 && modStart + length === modifiedLineCount + 1;\n      if ((atStart || atEnd) && length > minContext + minHiddenLineCount) {\n        if (atStart && !atEnd) {\n          length -= minContext;\n        }\n        if (atEnd && !atStart) {\n          origStart += minContext;\n          modStart += minContext;\n          length -= minContext;\n        }\n        result.push(new UnchangedRegion(origStart, modStart, length, 0, 0));\n      } else if (length > minContext * 2 + minHiddenLineCount) {\n        origStart += minContext;\n        modStart += minContext;\n        length -= minContext * 2;\n        result.push(new UnchangedRegion(origStart, modStart, length, 0, 0));\n      }\n    }\n    return result;\n  }\n  get originalRange() {\n    return LineRange.ofLength(this.originalLineNumber, this.lineCount);\n  }\n  get modifiedRange() {\n    return LineRange.ofLength(this.modifiedLineNumber, this.lineCount);\n  }\n  constructor(originalLineNumber, modifiedLineNumber, lineCount, visibleLineCountTop, visibleLineCountBottom) {\n    this.originalLineNumber = originalLineNumber;\n    this.modifiedLineNumber = modifiedLineNumber;\n    this.lineCount = lineCount;\n    this._visibleLineCountTop = observableValue('visibleLineCountTop', 0);\n    this.visibleLineCountTop = this._visibleLineCountTop;\n    this._visibleLineCountBottom = observableValue('visibleLineCountBottom', 0);\n    this.visibleLineCountBottom = this._visibleLineCountBottom;\n    this._shouldHideControls = derived('isVisible', reader => this.visibleLineCountTop.read(reader) + this.visibleLineCountBottom.read(reader) === this.lineCount && !this.isDragged.read(reader));\n    this.isDragged = observableValue('isDragged', false);\n    this._visibleLineCountTop.set(visibleLineCountTop, undefined);\n    this._visibleLineCountBottom.set(visibleLineCountBottom, undefined);\n  }\n  shouldHideControls(reader) {\n    return this._shouldHideControls.read(reader);\n  }\n  getHiddenOriginalRange(reader) {\n    return LineRange.ofLength(this.originalLineNumber + this._visibleLineCountTop.read(reader), this.lineCount - this._visibleLineCountTop.read(reader) - this._visibleLineCountBottom.read(reader));\n  }\n  getHiddenModifiedRange(reader) {\n    return LineRange.ofLength(this.modifiedLineNumber + this._visibleLineCountTop.read(reader), this.lineCount - this._visibleLineCountTop.read(reader) - this._visibleLineCountBottom.read(reader));\n  }\n  setHiddenModifiedRange(range, tx) {\n    const visibleLineCountTop = range.startLineNumber - this.modifiedLineNumber;\n    const visibleLineCountBottom = this.modifiedLineNumber + this.lineCount - range.endLineNumberExclusive;\n    this.setState(visibleLineCountTop, visibleLineCountBottom, tx);\n  }\n  getMaxVisibleLineCountTop() {\n    return this.lineCount - this._visibleLineCountBottom.get();\n  }\n  getMaxVisibleLineCountBottom() {\n    return this.lineCount - this._visibleLineCountTop.get();\n  }\n  showMoreAbove(count = 10, tx) {\n    const maxVisibleLineCountTop = this.getMaxVisibleLineCountTop();\n    this._visibleLineCountTop.set(Math.min(this._visibleLineCountTop.get() + count, maxVisibleLineCountTop), tx);\n  }\n  showMoreBelow(count = 10, tx) {\n    const maxVisibleLineCountBottom = this.lineCount - this._visibleLineCountTop.get();\n    this._visibleLineCountBottom.set(Math.min(this._visibleLineCountBottom.get() + count, maxVisibleLineCountBottom), tx);\n  }\n  showAll(tx) {\n    this._visibleLineCountBottom.set(this.lineCount - this._visibleLineCountTop.get(), tx);\n  }\n  setState(visibleLineCountTop, visibleLineCountBottom, tx) {\n    visibleLineCountTop = Math.max(Math.min(visibleLineCountTop, this.lineCount), 0);\n    visibleLineCountBottom = Math.max(Math.min(visibleLineCountBottom, this.lineCount - visibleLineCountTop), 0);\n    this._visibleLineCountTop.set(visibleLineCountTop, tx);\n    this._visibleLineCountBottom.set(visibleLineCountBottom, tx);\n  }\n}\nfunction applyOriginalEdits(diff, textEdits, originalTextModel, modifiedTextModel) {\n  if (textEdits.length === 0) {\n    return diff;\n  }\n  const diff2 = flip(diff);\n  const diff3 = applyModifiedEdits(diff2, textEdits, modifiedTextModel, originalTextModel);\n  if (!diff3) {\n    return undefined;\n  }\n  return flip(diff3);\n}\nfunction flip(diff) {\n  return {\n    changes: diff.changes.map(c => c.flip()),\n    moves: diff.moves.map(m => m.flip()),\n    identical: diff.identical,\n    quitEarly: diff.quitEarly\n  };\n}\nfunction applyModifiedEdits(diff, textEdits, originalTextModel, modifiedTextModel) {\n  if (textEdits.length === 0) {\n    return diff;\n  }\n  if (diff.changes.some(c => !c.innerChanges) || diff.moves.length > 0) {\n    // TODO support these cases\n    return undefined;\n  }\n  const changes = applyModifiedEditsToLineRangeMappings(diff.changes, textEdits, originalTextModel, modifiedTextModel);\n  const moves = diff.moves.map(m => {\n    const newModifiedRange = applyEditToLineRange(m.lineRangeMapping.modified, textEdits);\n    return newModifiedRange ? new MovedText(new SimpleLineRangeMapping(m.lineRangeMapping.original, newModifiedRange), applyModifiedEditsToLineRangeMappings(m.changes, textEdits, originalTextModel, modifiedTextModel)) : undefined;\n  }).filter(isDefined);\n  return {\n    identical: false,\n    quitEarly: false,\n    changes,\n    moves\n  };\n}\nfunction applyEditToLineRange(range, textEdits) {\n  let rangeStartLineNumber = range.startLineNumber;\n  let rangeEndLineNumberEx = range.endLineNumberExclusive;\n  for (let i = textEdits.length - 1; i >= 0; i--) {\n    const textEdit = textEdits[i];\n    const textEditStartLineNumber = lengthGetLineCount(textEdit.startOffset) + 1;\n    const textEditEndLineNumber = lengthGetLineCount(textEdit.endOffset) + 1;\n    const newLengthLineCount = lengthGetLineCount(textEdit.newLength);\n    const delta = newLengthLineCount - (textEditEndLineNumber - textEditStartLineNumber);\n    if (textEditEndLineNumber < rangeStartLineNumber) {\n      // the text edit is before us\n      rangeStartLineNumber += delta;\n      rangeEndLineNumberEx += delta;\n    } else if (textEditStartLineNumber > rangeEndLineNumberEx) {\n      // the text edit is after us\n      // NOOP\n    } else if (textEditStartLineNumber < rangeStartLineNumber && rangeEndLineNumberEx < textEditEndLineNumber) {\n      // the range is fully contained in the text edit\n      return undefined;\n    } else if (textEditStartLineNumber < rangeStartLineNumber && textEditEndLineNumber <= rangeEndLineNumberEx) {\n      // the text edit ends inside our range\n      rangeStartLineNumber = textEditEndLineNumber + 1;\n      rangeStartLineNumber += delta;\n      rangeEndLineNumberEx += delta;\n    } else if (rangeStartLineNumber <= textEditStartLineNumber && textEditEndLineNumber < rangeStartLineNumber) {\n      // the text edit starts inside our range\n      rangeEndLineNumberEx = textEditStartLineNumber;\n    } else {\n      rangeEndLineNumberEx += delta;\n    }\n  }\n  return new LineRange(rangeStartLineNumber, rangeEndLineNumberEx);\n}\nfunction applyModifiedEditsToLineRangeMappings(changes, textEdits, originalTextModel, modifiedTextModel) {\n  const diffTextEdits = changes.flatMap(c => c.innerChanges.map(c => new TextEditInfo(positionToLength(c.originalRange.getStartPosition()), positionToLength(c.originalRange.getEndPosition()), lengthOfRange(c.modifiedRange).toLength())));\n  const combined = combineTextEditInfos(diffTextEdits, textEdits);\n  let lastOriginalEndOffset = lengthZero;\n  let lastModifiedEndOffset = lengthZero;\n  const rangeMappings = combined.map(c => {\n    const modifiedStartOffset = lengthAdd(lastModifiedEndOffset, lengthDiffNonNegative(lastOriginalEndOffset, c.startOffset));\n    lastOriginalEndOffset = c.endOffset;\n    lastModifiedEndOffset = lengthAdd(modifiedStartOffset, c.newLength);\n    return new RangeMapping(Range.fromPositions(lengthToPosition(c.startOffset), lengthToPosition(c.endOffset)), Range.fromPositions(lengthToPosition(modifiedStartOffset), lengthToPosition(lastModifiedEndOffset)));\n  });\n  const newChanges = lineRangeMappingFromRangeMappings(rangeMappings, originalTextModel.getLinesContent(), modifiedTextModel.getLinesContent());\n  return newChanges;\n}","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","RunOnceScheduler","Disposable","derived","observableSignal","observableSignalFromEvent","observableValue","transaction","waitForState","autorunWithStore2","isDefined","LineRange","Range","LineRangeMapping","MovedText","RangeMapping","SimpleLineRangeMapping","lineRangeMappingFromRangeMappings","TextEditInfo","combineTextEditInfos","lengthAdd","lengthDiffNonNegative","lengthGetLineCount","lengthOfRange","lengthToPosition","lengthZero","positionToLength","DiffEditorViewModel","constructor","model","_options","documentDiffProvider","_isDiffUpToDate","isDiffUpToDate","_diff","undefined","diff","_unchangedRegions","regions","originalDecorationIds","modifiedDecorationIds","unchangedRegions","r","collapseUnchangedRegions","read","tx","get","setState","syncedMovedTexts","contentChangedSignal","debouncer","_register","trigger","updateUnchangedRegions","newUnchangedRegions","UnchangedRegion","fromDiffs","changes","original","getLineCount","modified","lastUnchangedRegions","lastUnchangedRegionsOrigRanges","map","id","getDecorationRange","filter","fromRange","lastUnchangedRegionsModRanges","deltaDecorations","range","originalRange","toInclusiveRange","options","description","modifiedRange","i","length","intersectsStrict","setHiddenModifiedRange","getHiddenModifiedRange","set","onDidChangeContent","textEdits","fromModelContentChanges","applyModifiedEdits","_lastDiff","DiffState","fromDiffResult","currentSyncedMovedText","moves","find","m","lineRangeMapping","intersect","schedule","applyOriginalEdits","documentDiffProviderOptionChanged","onDidChange","reader","store","_a","_b","cancel","originalTextEditInfos","add","edits","modifiedTextEditInfos","computeDiff","ignoreTrimWhitespace","maxComputationTimeMs","computeMoves","showMoves","state","ensureModifiedLineIsVisible","lineNumber","mappings","contains","showAll","ensureOriginalLineIsVisible","getHiddenOriginalRange","waitForDiff","s","serializeState","collapsedRegions","serialize","restoreSerializedState","ranges","deserialize","c","DiffMapping","identical","quitEarly","movedTexts","originalLineCount","modifiedLineCount","inversedMappings","inverse","minHiddenLineCount","minContext","mapping","origStart","startLineNumber","modStart","atStart","atEnd","push","ofLength","originalLineNumber","lineCount","modifiedLineNumber","visibleLineCountTop","visibleLineCountBottom","_visibleLineCountTop","_visibleLineCountBottom","_shouldHideControls","isDragged","shouldHideControls","endLineNumberExclusive","getMaxVisibleLineCountTop","getMaxVisibleLineCountBottom","showMoreAbove","count","maxVisibleLineCountTop","Math","min","showMoreBelow","maxVisibleLineCountBottom","max","originalTextModel","modifiedTextModel","diff2","flip","diff3","some","innerChanges","applyModifiedEditsToLineRangeMappings","newModifiedRange","applyEditToLineRange","rangeStartLineNumber","rangeEndLineNumberEx","textEdit","textEditStartLineNumber","startOffset","textEditEndLineNumber","endOffset","newLengthLineCount","newLength","delta","diffTextEdits","flatMap","getStartPosition","getEndPosition","toLength","combined","lastOriginalEndOffset","lastModifiedEndOffset","rangeMappings","modifiedStartOffset","fromPositions","newChanges","getLinesContent"],"sources":["D:/code/java/program/oj/code/yuoj-frontend-master/node_modules/monaco-editor/esm/vs/editor/browser/widget/diffEditorWidget2/diffEditorViewModel.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { RunOnceScheduler } from '../../../../base/common/async.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { derived, observableSignal, observableSignalFromEvent, observableValue, transaction, waitForState } from '../../../../base/common/observable.js';\nimport { autorunWithStore2 } from '../../../../base/common/observableImpl/autorun.js';\nimport { isDefined } from '../../../../base/common/types.js';\nimport { LineRange } from '../../../common/core/lineRange.js';\nimport { Range } from '../../../common/core/range.js';\nimport { LineRangeMapping, MovedText, RangeMapping, SimpleLineRangeMapping } from '../../../common/diff/linesDiffComputer.js';\nimport { lineRangeMappingFromRangeMappings } from '../../../common/diff/standardLinesDiffComputer.js';\nimport { TextEditInfo } from '../../../common/model/bracketPairsTextModelPart/bracketPairsTree/beforeEditPositionMapper.js';\nimport { combineTextEditInfos } from '../../../common/model/bracketPairsTextModelPart/bracketPairsTree/combineTextEditInfos.js';\nimport { lengthAdd, lengthDiffNonNegative, lengthGetLineCount, lengthOfRange, lengthToPosition, lengthZero, positionToLength } from '../../../common/model/bracketPairsTextModelPart/bracketPairsTree/length.js';\nexport class DiffEditorViewModel extends Disposable {\n    constructor(model, _options, documentDiffProvider) {\n        super();\n        this.model = model;\n        this._options = _options;\n        this._isDiffUpToDate = observableValue('isDiffUpToDate', false);\n        this.isDiffUpToDate = this._isDiffUpToDate;\n        this._diff = observableValue('diff', undefined);\n        this.diff = this._diff;\n        this._unchangedRegions = observableValue('unchangedRegion', { regions: [], originalDecorationIds: [], modifiedDecorationIds: [] });\n        this.unchangedRegions = derived('unchangedRegions', r => {\n            if (this._options.collapseUnchangedRegions.read(r)) {\n                return this._unchangedRegions.read(r).regions;\n            }\n            else {\n                // Reset state\n                transaction(tx => {\n                    for (const r of this._unchangedRegions.get().regions) {\n                        r.setState(0, 0, tx);\n                    }\n                });\n                return [];\n            }\n        });\n        this.syncedMovedTexts = observableValue('syncedMovedText', undefined);\n        const contentChangedSignal = observableSignal('contentChangedSignal');\n        const debouncer = this._register(new RunOnceScheduler(() => contentChangedSignal.trigger(undefined), 200));\n        const updateUnchangedRegions = (result, tx) => {\n            const newUnchangedRegions = UnchangedRegion.fromDiffs(result.changes, model.original.getLineCount(), model.modified.getLineCount());\n            // Transfer state from cur state\n            const lastUnchangedRegions = this._unchangedRegions.get();\n            const lastUnchangedRegionsOrigRanges = lastUnchangedRegions.originalDecorationIds\n                .map(id => model.original.getDecorationRange(id))\n                .filter(r => !!r)\n                .map(r => LineRange.fromRange(r));\n            const lastUnchangedRegionsModRanges = lastUnchangedRegions.modifiedDecorationIds\n                .map(id => model.modified.getDecorationRange(id))\n                .filter(r => !!r)\n                .map(r => LineRange.fromRange(r));\n            const originalDecorationIds = model.original.deltaDecorations(lastUnchangedRegions.originalDecorationIds, newUnchangedRegions.map(r => ({ range: r.originalRange.toInclusiveRange(), options: { description: 'unchanged' } })));\n            const modifiedDecorationIds = model.modified.deltaDecorations(lastUnchangedRegions.modifiedDecorationIds, newUnchangedRegions.map(r => ({ range: r.modifiedRange.toInclusiveRange(), options: { description: 'unchanged' } })));\n            for (const r of newUnchangedRegions) {\n                for (let i = 0; i < lastUnchangedRegions.regions.length; i++) {\n                    if (r.originalRange.intersectsStrict(lastUnchangedRegionsOrigRanges[i])\n                        && r.modifiedRange.intersectsStrict(lastUnchangedRegionsModRanges[i])) {\n                        r.setHiddenModifiedRange(lastUnchangedRegions.regions[i].getHiddenModifiedRange(undefined), tx);\n                        break;\n                    }\n                }\n            }\n            this._unchangedRegions.set({\n                regions: newUnchangedRegions,\n                originalDecorationIds,\n                modifiedDecorationIds\n            }, tx);\n        };\n        this._register(model.modified.onDidChangeContent((e) => {\n            const diff = this._diff.get();\n            if (!diff) {\n                return;\n            }\n            const textEdits = TextEditInfo.fromModelContentChanges(e.changes);\n            const result = applyModifiedEdits(this._lastDiff, textEdits, model.original, model.modified);\n            if (result) {\n                this._lastDiff = result;\n                transaction(tx => {\n                    this._diff.set(DiffState.fromDiffResult(this._lastDiff), tx);\n                    updateUnchangedRegions(result, tx);\n                    const currentSyncedMovedText = this.syncedMovedTexts.get();\n                    this.syncedMovedTexts.set(currentSyncedMovedText ? this._lastDiff.moves.find(m => m.lineRangeMapping.modified.intersect(currentSyncedMovedText.lineRangeMapping.modified)) : undefined, tx);\n                });\n            }\n            debouncer.schedule();\n        }));\n        this._register(model.original.onDidChangeContent((e) => {\n            const diff = this._diff.get();\n            if (!diff) {\n                return;\n            }\n            const textEdits = TextEditInfo.fromModelContentChanges(e.changes);\n            const result = applyOriginalEdits(this._lastDiff, textEdits, model.original, model.modified);\n            if (result) {\n                this._lastDiff = result;\n                transaction(tx => {\n                    this._diff.set(DiffState.fromDiffResult(this._lastDiff), tx);\n                    updateUnchangedRegions(result, tx);\n                    const currentSyncedMovedText = this.syncedMovedTexts.get();\n                    this.syncedMovedTexts.set(currentSyncedMovedText ? this._lastDiff.moves.find(m => m.lineRangeMapping.modified.intersect(currentSyncedMovedText.lineRangeMapping.modified)) : undefined, tx);\n                });\n            }\n            debouncer.schedule();\n        }));\n        const documentDiffProviderOptionChanged = observableSignalFromEvent('documentDiffProviderOptionChanged', documentDiffProvider.onDidChange);\n        this._register(autorunWithStore2('compute diff', (reader, store) => __awaiter(this, void 0, void 0, function* () {\n            var _a, _b;\n            debouncer.cancel();\n            contentChangedSignal.read(reader);\n            documentDiffProviderOptionChanged.read(reader);\n            this._isDiffUpToDate.set(false, undefined);\n            let originalTextEditInfos = [];\n            store.add(model.original.onDidChangeContent((e) => {\n                const edits = TextEditInfo.fromModelContentChanges(e.changes);\n                originalTextEditInfos = combineTextEditInfos(originalTextEditInfos, edits);\n            }));\n            let modifiedTextEditInfos = [];\n            store.add(model.modified.onDidChangeContent((e) => {\n                const edits = TextEditInfo.fromModelContentChanges(e.changes);\n                modifiedTextEditInfos = combineTextEditInfos(modifiedTextEditInfos, edits);\n            }));\n            let result = yield documentDiffProvider.computeDiff(model.original, model.modified, {\n                ignoreTrimWhitespace: this._options.ignoreTrimWhitespace.read(reader),\n                maxComputationTimeMs: this._options.maxComputationTimeMs.read(reader),\n                computeMoves: this._options.showMoves.read(reader),\n            });\n            result = (_a = applyOriginalEdits(result, originalTextEditInfos, model.original, model.modified)) !== null && _a !== void 0 ? _a : result;\n            result = (_b = applyModifiedEdits(result, modifiedTextEditInfos, model.original, model.modified)) !== null && _b !== void 0 ? _b : result;\n            transaction(tx => {\n                updateUnchangedRegions(result, tx);\n                this._lastDiff = result;\n                const state = DiffState.fromDiffResult(result);\n                this._diff.set(state, tx);\n                this._isDiffUpToDate.set(true, tx);\n                const currentSyncedMovedText = this.syncedMovedTexts.get();\n                this.syncedMovedTexts.set(currentSyncedMovedText ? this._lastDiff.moves.find(m => m.lineRangeMapping.modified.intersect(currentSyncedMovedText.lineRangeMapping.modified)) : undefined, tx);\n            });\n        })));\n    }\n    ensureModifiedLineIsVisible(lineNumber, tx) {\n        var _a;\n        if (((_a = this.diff.get()) === null || _a === void 0 ? void 0 : _a.mappings.length) === 0) {\n            return;\n        }\n        const unchangedRegions = this._unchangedRegions.get().regions;\n        for (const r of unchangedRegions) {\n            if (r.getHiddenModifiedRange(undefined).contains(lineNumber)) {\n                r.showAll(tx); // TODO only unhide what is needed\n                return;\n            }\n        }\n    }\n    ensureOriginalLineIsVisible(lineNumber, tx) {\n        var _a;\n        if (((_a = this.diff.get()) === null || _a === void 0 ? void 0 : _a.mappings.length) === 0) {\n            return;\n        }\n        const unchangedRegions = this._unchangedRegions.get().regions;\n        for (const r of unchangedRegions) {\n            if (r.getHiddenOriginalRange(undefined).contains(lineNumber)) {\n                r.showAll(tx); // TODO only unhide what is needed\n                return;\n            }\n        }\n    }\n    waitForDiff() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield waitForState(this.isDiffUpToDate, s => s);\n        });\n    }\n    serializeState() {\n        const regions = this._unchangedRegions.get();\n        return {\n            collapsedRegions: regions.regions.map(r => ({ range: r.getHiddenModifiedRange(undefined).serialize() }))\n        };\n    }\n    restoreSerializedState(state) {\n        const ranges = state.collapsedRegions.map(r => LineRange.deserialize(r.range));\n        const regions = this._unchangedRegions.get();\n        transaction(tx => {\n            for (const r of regions.regions) {\n                for (const range of ranges) {\n                    if (r.modifiedRange.intersect(range)) {\n                        r.setHiddenModifiedRange(range, tx);\n                        break;\n                    }\n                }\n            }\n        });\n    }\n}\nexport class DiffState {\n    static fromDiffResult(result) {\n        return new DiffState(result.changes.map(c => new DiffMapping(c)), result.moves || [], result.identical, result.quitEarly);\n    }\n    constructor(mappings, movedTexts, identical, quitEarly) {\n        this.mappings = mappings;\n        this.movedTexts = movedTexts;\n        this.identical = identical;\n        this.quitEarly = quitEarly;\n    }\n}\nexport class DiffMapping {\n    constructor(lineRangeMapping) {\n        this.lineRangeMapping = lineRangeMapping;\n        /*\n        readonly movedTo: MovedText | undefined,\n        readonly movedFrom: MovedText | undefined,\n\n        if (movedTo) {\n            assertFn(() =>\n                movedTo.lineRangeMapping.modifiedRange.equals(lineRangeMapping.modifiedRange)\n                && lineRangeMapping.originalRange.isEmpty\n                && !movedFrom\n            );\n        } else if (movedFrom) {\n            assertFn(() =>\n                movedFrom.lineRangeMapping.originalRange.equals(lineRangeMapping.originalRange)\n                && lineRangeMapping.modifiedRange.isEmpty\n                && !movedTo\n            );\n        }\n        */\n    }\n}\nexport class UnchangedRegion {\n    static fromDiffs(changes, originalLineCount, modifiedLineCount) {\n        const inversedMappings = LineRangeMapping.inverse(changes, originalLineCount, modifiedLineCount);\n        const result = [];\n        const minHiddenLineCount = 3;\n        const minContext = 3;\n        for (const mapping of inversedMappings) {\n            let origStart = mapping.originalRange.startLineNumber;\n            let modStart = mapping.modifiedRange.startLineNumber;\n            let length = mapping.originalRange.length;\n            const atStart = origStart === 1 && modStart === 1;\n            const atEnd = origStart + length === originalLineCount + 1 && modStart + length === modifiedLineCount + 1;\n            if ((atStart || atEnd) && length > minContext + minHiddenLineCount) {\n                if (atStart && !atEnd) {\n                    length -= minContext;\n                }\n                if (atEnd && !atStart) {\n                    origStart += minContext;\n                    modStart += minContext;\n                    length -= minContext;\n                }\n                result.push(new UnchangedRegion(origStart, modStart, length, 0, 0));\n            }\n            else if (length > minContext * 2 + minHiddenLineCount) {\n                origStart += minContext;\n                modStart += minContext;\n                length -= minContext * 2;\n                result.push(new UnchangedRegion(origStart, modStart, length, 0, 0));\n            }\n        }\n        return result;\n    }\n    get originalRange() {\n        return LineRange.ofLength(this.originalLineNumber, this.lineCount);\n    }\n    get modifiedRange() {\n        return LineRange.ofLength(this.modifiedLineNumber, this.lineCount);\n    }\n    constructor(originalLineNumber, modifiedLineNumber, lineCount, visibleLineCountTop, visibleLineCountBottom) {\n        this.originalLineNumber = originalLineNumber;\n        this.modifiedLineNumber = modifiedLineNumber;\n        this.lineCount = lineCount;\n        this._visibleLineCountTop = observableValue('visibleLineCountTop', 0);\n        this.visibleLineCountTop = this._visibleLineCountTop;\n        this._visibleLineCountBottom = observableValue('visibleLineCountBottom', 0);\n        this.visibleLineCountBottom = this._visibleLineCountBottom;\n        this._shouldHideControls = derived('isVisible', reader => this.visibleLineCountTop.read(reader) + this.visibleLineCountBottom.read(reader) === this.lineCount && !this.isDragged.read(reader));\n        this.isDragged = observableValue('isDragged', false);\n        this._visibleLineCountTop.set(visibleLineCountTop, undefined);\n        this._visibleLineCountBottom.set(visibleLineCountBottom, undefined);\n    }\n    shouldHideControls(reader) {\n        return this._shouldHideControls.read(reader);\n    }\n    getHiddenOriginalRange(reader) {\n        return LineRange.ofLength(this.originalLineNumber + this._visibleLineCountTop.read(reader), this.lineCount - this._visibleLineCountTop.read(reader) - this._visibleLineCountBottom.read(reader));\n    }\n    getHiddenModifiedRange(reader) {\n        return LineRange.ofLength(this.modifiedLineNumber + this._visibleLineCountTop.read(reader), this.lineCount - this._visibleLineCountTop.read(reader) - this._visibleLineCountBottom.read(reader));\n    }\n    setHiddenModifiedRange(range, tx) {\n        const visibleLineCountTop = range.startLineNumber - this.modifiedLineNumber;\n        const visibleLineCountBottom = (this.modifiedLineNumber + this.lineCount) - range.endLineNumberExclusive;\n        this.setState(visibleLineCountTop, visibleLineCountBottom, tx);\n    }\n    getMaxVisibleLineCountTop() {\n        return this.lineCount - this._visibleLineCountBottom.get();\n    }\n    getMaxVisibleLineCountBottom() {\n        return this.lineCount - this._visibleLineCountTop.get();\n    }\n    showMoreAbove(count = 10, tx) {\n        const maxVisibleLineCountTop = this.getMaxVisibleLineCountTop();\n        this._visibleLineCountTop.set(Math.min(this._visibleLineCountTop.get() + count, maxVisibleLineCountTop), tx);\n    }\n    showMoreBelow(count = 10, tx) {\n        const maxVisibleLineCountBottom = this.lineCount - this._visibleLineCountTop.get();\n        this._visibleLineCountBottom.set(Math.min(this._visibleLineCountBottom.get() + count, maxVisibleLineCountBottom), tx);\n    }\n    showAll(tx) {\n        this._visibleLineCountBottom.set(this.lineCount - this._visibleLineCountTop.get(), tx);\n    }\n    setState(visibleLineCountTop, visibleLineCountBottom, tx) {\n        visibleLineCountTop = Math.max(Math.min(visibleLineCountTop, this.lineCount), 0);\n        visibleLineCountBottom = Math.max(Math.min(visibleLineCountBottom, this.lineCount - visibleLineCountTop), 0);\n        this._visibleLineCountTop.set(visibleLineCountTop, tx);\n        this._visibleLineCountBottom.set(visibleLineCountBottom, tx);\n    }\n}\nfunction applyOriginalEdits(diff, textEdits, originalTextModel, modifiedTextModel) {\n    if (textEdits.length === 0) {\n        return diff;\n    }\n    const diff2 = flip(diff);\n    const diff3 = applyModifiedEdits(diff2, textEdits, modifiedTextModel, originalTextModel);\n    if (!diff3) {\n        return undefined;\n    }\n    return flip(diff3);\n}\nfunction flip(diff) {\n    return {\n        changes: diff.changes.map(c => c.flip()),\n        moves: diff.moves.map(m => m.flip()),\n        identical: diff.identical,\n        quitEarly: diff.quitEarly,\n    };\n}\nfunction applyModifiedEdits(diff, textEdits, originalTextModel, modifiedTextModel) {\n    if (textEdits.length === 0) {\n        return diff;\n    }\n    if (diff.changes.some(c => !c.innerChanges) || diff.moves.length > 0) {\n        // TODO support these cases\n        return undefined;\n    }\n    const changes = applyModifiedEditsToLineRangeMappings(diff.changes, textEdits, originalTextModel, modifiedTextModel);\n    const moves = diff.moves.map(m => {\n        const newModifiedRange = applyEditToLineRange(m.lineRangeMapping.modified, textEdits);\n        return newModifiedRange ? new MovedText(new SimpleLineRangeMapping(m.lineRangeMapping.original, newModifiedRange), applyModifiedEditsToLineRangeMappings(m.changes, textEdits, originalTextModel, modifiedTextModel)) : undefined;\n    }).filter(isDefined);\n    return {\n        identical: false,\n        quitEarly: false,\n        changes,\n        moves,\n    };\n}\nfunction applyEditToLineRange(range, textEdits) {\n    let rangeStartLineNumber = range.startLineNumber;\n    let rangeEndLineNumberEx = range.endLineNumberExclusive;\n    for (let i = textEdits.length - 1; i >= 0; i--) {\n        const textEdit = textEdits[i];\n        const textEditStartLineNumber = lengthGetLineCount(textEdit.startOffset) + 1;\n        const textEditEndLineNumber = lengthGetLineCount(textEdit.endOffset) + 1;\n        const newLengthLineCount = lengthGetLineCount(textEdit.newLength);\n        const delta = newLengthLineCount - (textEditEndLineNumber - textEditStartLineNumber);\n        if (textEditEndLineNumber < rangeStartLineNumber) {\n            // the text edit is before us\n            rangeStartLineNumber += delta;\n            rangeEndLineNumberEx += delta;\n        }\n        else if (textEditStartLineNumber > rangeEndLineNumberEx) {\n            // the text edit is after us\n            // NOOP\n        }\n        else if (textEditStartLineNumber < rangeStartLineNumber && rangeEndLineNumberEx < textEditEndLineNumber) {\n            // the range is fully contained in the text edit\n            return undefined;\n        }\n        else if (textEditStartLineNumber < rangeStartLineNumber && textEditEndLineNumber <= rangeEndLineNumberEx) {\n            // the text edit ends inside our range\n            rangeStartLineNumber = textEditEndLineNumber + 1;\n            rangeStartLineNumber += delta;\n            rangeEndLineNumberEx += delta;\n        }\n        else if (rangeStartLineNumber <= textEditStartLineNumber && textEditEndLineNumber < rangeStartLineNumber) {\n            // the text edit starts inside our range\n            rangeEndLineNumberEx = textEditStartLineNumber;\n        }\n        else {\n            rangeEndLineNumberEx += delta;\n        }\n    }\n    return new LineRange(rangeStartLineNumber, rangeEndLineNumberEx);\n}\nfunction applyModifiedEditsToLineRangeMappings(changes, textEdits, originalTextModel, modifiedTextModel) {\n    const diffTextEdits = changes.flatMap(c => c.innerChanges.map(c => new TextEditInfo(positionToLength(c.originalRange.getStartPosition()), positionToLength(c.originalRange.getEndPosition()), lengthOfRange(c.modifiedRange).toLength())));\n    const combined = combineTextEditInfos(diffTextEdits, textEdits);\n    let lastOriginalEndOffset = lengthZero;\n    let lastModifiedEndOffset = lengthZero;\n    const rangeMappings = combined.map(c => {\n        const modifiedStartOffset = lengthAdd(lastModifiedEndOffset, lengthDiffNonNegative(lastOriginalEndOffset, c.startOffset));\n        lastOriginalEndOffset = c.endOffset;\n        lastModifiedEndOffset = lengthAdd(modifiedStartOffset, c.newLength);\n        return new RangeMapping(Range.fromPositions(lengthToPosition(c.startOffset), lengthToPosition(c.endOffset)), Range.fromPositions(lengthToPosition(modifiedStartOffset), lengthToPosition(lastModifiedEndOffset)));\n    });\n    const newChanges = lineRangeMappingFromRangeMappings(rangeMappings, originalTextModel.getLinesContent(), modifiedTextModel.getLinesContent());\n    return newChanges;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
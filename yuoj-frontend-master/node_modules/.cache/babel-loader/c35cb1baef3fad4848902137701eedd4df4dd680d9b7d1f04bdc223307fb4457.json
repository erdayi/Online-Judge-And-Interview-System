{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { toDisposable } from '../lifecycle.js';\nimport { autorun } from './autorun.js';\nimport { BaseObservable, ConvenientObservable, getFunctionName, transaction } from './base.js';\nimport { getLogger } from './logging.js';\nexport function constObservable(value) {\n  return new ConstObservable(value);\n}\nclass ConstObservable extends ConvenientObservable {\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n  get debugName() {\n    return this.toString();\n  }\n  get() {\n    return this.value;\n  }\n  addObserver(observer) {\n    // NO OP\n  }\n  removeObserver(observer) {\n    // NO OP\n  }\n  toString() {\n    return `Const: ${this.value}`;\n  }\n}\nexport function waitForState(observable, predicate) {\n  return new Promise(resolve => {\n    let didRun = false;\n    let shouldDispose = false;\n    const d = autorun('waitForState', reader => {\n      const currentState = observable.read(reader);\n      if (predicate(currentState)) {\n        if (!didRun) {\n          shouldDispose = true;\n        } else {\n          d.dispose();\n        }\n        resolve(currentState);\n      }\n    });\n    didRun = true;\n    if (shouldDispose) {\n      d.dispose();\n    }\n  });\n}\nexport function observableFromEvent(event, getValue) {\n  return new FromEventObservable(event, getValue);\n}\nexport class FromEventObservable extends BaseObservable {\n  constructor(event, getValue) {\n    super();\n    this.event = event;\n    this.getValue = getValue;\n    this.hasValue = false;\n    this.handleEvent = args => {\n      var _a;\n      const newValue = this.getValue(args);\n      const didChange = !this.hasValue || this.value !== newValue;\n      (_a = getLogger()) === null || _a === void 0 ? void 0 : _a.handleFromEventObservableTriggered(this, {\n        oldValue: this.value,\n        newValue,\n        change: undefined,\n        didChange\n      });\n      if (didChange) {\n        this.value = newValue;\n        if (this.hasValue) {\n          transaction(tx => {\n            for (const o of this.observers) {\n              tx.updateObserver(o, this);\n              o.handleChange(this, undefined);\n            }\n          }, () => {\n            const name = this.getDebugName();\n            return 'Event fired' + (name ? `: ${name}` : '');\n          });\n        }\n        this.hasValue = true;\n      }\n    };\n  }\n  getDebugName() {\n    return getFunctionName(this.getValue);\n  }\n  get debugName() {\n    const name = this.getDebugName();\n    return 'From Event' + (name ? `: ${name}` : '');\n  }\n  onFirstObserverAdded() {\n    this.subscription = this.event(this.handleEvent);\n  }\n  onLastObserverRemoved() {\n    this.subscription.dispose();\n    this.subscription = undefined;\n    this.hasValue = false;\n    this.value = undefined;\n  }\n  get() {\n    if (this.subscription) {\n      if (!this.hasValue) {\n        this.handleEvent(undefined);\n      }\n      return this.value;\n    } else {\n      // no cache, as there are no subscribers to keep it updated\n      return this.getValue(undefined);\n    }\n  }\n}\n(function (observableFromEvent) {\n  observableFromEvent.Observer = FromEventObservable;\n})(observableFromEvent || (observableFromEvent = {}));\nexport function observableSignalFromEvent(debugName, event) {\n  return new FromEventObservableSignal(debugName, event);\n}\nclass FromEventObservableSignal extends BaseObservable {\n  constructor(debugName, event) {\n    super();\n    this.debugName = debugName;\n    this.event = event;\n    this.handleEvent = () => {\n      transaction(tx => {\n        for (const o of this.observers) {\n          tx.updateObserver(o, this);\n          o.handleChange(this, undefined);\n        }\n      }, () => this.debugName);\n    };\n  }\n  onFirstObserverAdded() {\n    this.subscription = this.event(this.handleEvent);\n  }\n  onLastObserverRemoved() {\n    this.subscription.dispose();\n    this.subscription = undefined;\n  }\n  get() {\n    // NO OP\n  }\n}\n/**\n * Creates a signal that can be triggered to invalidate observers.\n */\nexport function observableSignal(debugName) {\n  return new ObservableSignal(debugName);\n}\nclass ObservableSignal extends BaseObservable {\n  constructor(debugName) {\n    super();\n    this.debugName = debugName;\n  }\n  trigger(tx, change) {\n    if (!tx) {\n      transaction(tx => {\n        this.trigger(tx, change);\n      }, () => `Trigger signal ${this.debugName}`);\n      return;\n    }\n    for (const o of this.observers) {\n      tx.updateObserver(o, this);\n      o.handleChange(this, change);\n    }\n  }\n  get() {\n    // NO OP\n  }\n}\n// TODO@hediet: Have `keepCacheAlive` and `recomputeOnChange` instead of forceRecompute\n/**\n * This ensures the observable is being observed.\n * Observed observables (such as {@link derived}s) can maintain a cache, as they receive invalidation events.\n * Unobserved observables are forced to recompute their value from scratch every time they are read.\n *\n * @param observable the observable to keep alive\n * @param forceRecompute if true, the observable will be eagerly recomputed after it changed.\n * Use this if recomputing the observables causes side-effects.\n*/\nexport function keepAlive(observable, forceRecompute) {\n  const o = new KeepAliveObserver(forceRecompute !== null && forceRecompute !== void 0 ? forceRecompute : false);\n  observable.addObserver(o);\n  if (forceRecompute) {\n    observable.reportChanges();\n  }\n  return toDisposable(() => {\n    observable.removeObserver(o);\n  });\n}\nclass KeepAliveObserver {\n  constructor(forceRecompute) {\n    this.forceRecompute = forceRecompute;\n    this.counter = 0;\n  }\n  beginUpdate(observable) {\n    this.counter++;\n  }\n  endUpdate(observable) {\n    this.counter--;\n    if (this.counter === 0 && this.forceRecompute) {\n      observable.reportChanges();\n    }\n  }\n  handlePossibleChange(observable) {\n    // NO OP\n  }\n  handleChange(observable, change) {\n    // NO OP\n  }\n}","map":{"version":3,"names":["toDisposable","autorun","BaseObservable","ConvenientObservable","getFunctionName","transaction","getLogger","constObservable","value","ConstObservable","constructor","debugName","toString","get","addObserver","observer","removeObserver","waitForState","observable","predicate","Promise","resolve","didRun","shouldDispose","d","reader","currentState","read","dispose","observableFromEvent","event","getValue","FromEventObservable","hasValue","handleEvent","args","_a","newValue","didChange","handleFromEventObservableTriggered","oldValue","change","undefined","tx","o","observers","updateObserver","handleChange","name","getDebugName","onFirstObserverAdded","subscription","onLastObserverRemoved","Observer","observableSignalFromEvent","FromEventObservableSignal","observableSignal","ObservableSignal","trigger","keepAlive","forceRecompute","KeepAliveObserver","reportChanges","counter","beginUpdate","endUpdate","handlePossibleChange"],"sources":["D:/code/java/program/oj/code/yuoj-frontend-master/node_modules/monaco-editor/esm/vs/base/common/observableImpl/utils.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { toDisposable } from '../lifecycle.js';\nimport { autorun } from './autorun.js';\nimport { BaseObservable, ConvenientObservable, getFunctionName, transaction } from './base.js';\nimport { getLogger } from './logging.js';\nexport function constObservable(value) {\n    return new ConstObservable(value);\n}\nclass ConstObservable extends ConvenientObservable {\n    constructor(value) {\n        super();\n        this.value = value;\n    }\n    get debugName() {\n        return this.toString();\n    }\n    get() {\n        return this.value;\n    }\n    addObserver(observer) {\n        // NO OP\n    }\n    removeObserver(observer) {\n        // NO OP\n    }\n    toString() {\n        return `Const: ${this.value}`;\n    }\n}\nexport function waitForState(observable, predicate) {\n    return new Promise(resolve => {\n        let didRun = false;\n        let shouldDispose = false;\n        const d = autorun('waitForState', reader => {\n            const currentState = observable.read(reader);\n            if (predicate(currentState)) {\n                if (!didRun) {\n                    shouldDispose = true;\n                }\n                else {\n                    d.dispose();\n                }\n                resolve(currentState);\n            }\n        });\n        didRun = true;\n        if (shouldDispose) {\n            d.dispose();\n        }\n    });\n}\nexport function observableFromEvent(event, getValue) {\n    return new FromEventObservable(event, getValue);\n}\nexport class FromEventObservable extends BaseObservable {\n    constructor(event, getValue) {\n        super();\n        this.event = event;\n        this.getValue = getValue;\n        this.hasValue = false;\n        this.handleEvent = (args) => {\n            var _a;\n            const newValue = this.getValue(args);\n            const didChange = !this.hasValue || this.value !== newValue;\n            (_a = getLogger()) === null || _a === void 0 ? void 0 : _a.handleFromEventObservableTriggered(this, { oldValue: this.value, newValue, change: undefined, didChange });\n            if (didChange) {\n                this.value = newValue;\n                if (this.hasValue) {\n                    transaction((tx) => {\n                        for (const o of this.observers) {\n                            tx.updateObserver(o, this);\n                            o.handleChange(this, undefined);\n                        }\n                    }, () => {\n                        const name = this.getDebugName();\n                        return 'Event fired' + (name ? `: ${name}` : '');\n                    });\n                }\n                this.hasValue = true;\n            }\n        };\n    }\n    getDebugName() {\n        return getFunctionName(this.getValue);\n    }\n    get debugName() {\n        const name = this.getDebugName();\n        return 'From Event' + (name ? `: ${name}` : '');\n    }\n    onFirstObserverAdded() {\n        this.subscription = this.event(this.handleEvent);\n    }\n    onLastObserverRemoved() {\n        this.subscription.dispose();\n        this.subscription = undefined;\n        this.hasValue = false;\n        this.value = undefined;\n    }\n    get() {\n        if (this.subscription) {\n            if (!this.hasValue) {\n                this.handleEvent(undefined);\n            }\n            return this.value;\n        }\n        else {\n            // no cache, as there are no subscribers to keep it updated\n            return this.getValue(undefined);\n        }\n    }\n}\n(function (observableFromEvent) {\n    observableFromEvent.Observer = FromEventObservable;\n})(observableFromEvent || (observableFromEvent = {}));\nexport function observableSignalFromEvent(debugName, event) {\n    return new FromEventObservableSignal(debugName, event);\n}\nclass FromEventObservableSignal extends BaseObservable {\n    constructor(debugName, event) {\n        super();\n        this.debugName = debugName;\n        this.event = event;\n        this.handleEvent = () => {\n            transaction((tx) => {\n                for (const o of this.observers) {\n                    tx.updateObserver(o, this);\n                    o.handleChange(this, undefined);\n                }\n            }, () => this.debugName);\n        };\n    }\n    onFirstObserverAdded() {\n        this.subscription = this.event(this.handleEvent);\n    }\n    onLastObserverRemoved() {\n        this.subscription.dispose();\n        this.subscription = undefined;\n    }\n    get() {\n        // NO OP\n    }\n}\n/**\n * Creates a signal that can be triggered to invalidate observers.\n */\nexport function observableSignal(debugName) {\n    return new ObservableSignal(debugName);\n}\nclass ObservableSignal extends BaseObservable {\n    constructor(debugName) {\n        super();\n        this.debugName = debugName;\n    }\n    trigger(tx, change) {\n        if (!tx) {\n            transaction(tx => {\n                this.trigger(tx, change);\n            }, () => `Trigger signal ${this.debugName}`);\n            return;\n        }\n        for (const o of this.observers) {\n            tx.updateObserver(o, this);\n            o.handleChange(this, change);\n        }\n    }\n    get() {\n        // NO OP\n    }\n}\n// TODO@hediet: Have `keepCacheAlive` and `recomputeOnChange` instead of forceRecompute\n/**\n * This ensures the observable is being observed.\n * Observed observables (such as {@link derived}s) can maintain a cache, as they receive invalidation events.\n * Unobserved observables are forced to recompute their value from scratch every time they are read.\n *\n * @param observable the observable to keep alive\n * @param forceRecompute if true, the observable will be eagerly recomputed after it changed.\n * Use this if recomputing the observables causes side-effects.\n*/\nexport function keepAlive(observable, forceRecompute) {\n    const o = new KeepAliveObserver(forceRecompute !== null && forceRecompute !== void 0 ? forceRecompute : false);\n    observable.addObserver(o);\n    if (forceRecompute) {\n        observable.reportChanges();\n    }\n    return toDisposable(() => {\n        observable.removeObserver(o);\n    });\n}\nclass KeepAliveObserver {\n    constructor(forceRecompute) {\n        this.forceRecompute = forceRecompute;\n        this.counter = 0;\n    }\n    beginUpdate(observable) {\n        this.counter++;\n    }\n    endUpdate(observable) {\n        this.counter--;\n        if (this.counter === 0 && this.forceRecompute) {\n            observable.reportChanges();\n        }\n    }\n    handlePossibleChange(observable) {\n        // NO OP\n    }\n    handleChange(observable, change) {\n        // NO OP\n    }\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAASA,YAAY,QAAQ,iBAAiB;AAC9C,SAASC,OAAO,QAAQ,cAAc;AACtC,SAASC,cAAc,EAAEC,oBAAoB,EAAEC,eAAe,EAAEC,WAAW,QAAQ,WAAW;AAC9F,SAASC,SAAS,QAAQ,cAAc;AACxC,OAAO,SAASC,eAAeA,CAACC,KAAK,EAAE;EACnC,OAAO,IAAIC,eAAe,CAACD,KAAK,CAAC;AACrC;AACA,MAAMC,eAAe,SAASN,oBAAoB,CAAC;EAC/CO,WAAWA,CAACF,KAAK,EAAE;IACf,KAAK,CAAC,CAAC;IACP,IAAI,CAACA,KAAK,GAAGA,KAAK;EACtB;EACA,IAAIG,SAASA,CAAA,EAAG;IACZ,OAAO,IAAI,CAACC,QAAQ,CAAC,CAAC;EAC1B;EACAC,GAAGA,CAAA,EAAG;IACF,OAAO,IAAI,CAACL,KAAK;EACrB;EACAM,WAAWA,CAACC,QAAQ,EAAE;IAClB;EAAA;EAEJC,cAAcA,CAACD,QAAQ,EAAE;IACrB;EAAA;EAEJH,QAAQA,CAAA,EAAG;IACP,OAAQ,UAAS,IAAI,CAACJ,KAAM,EAAC;EACjC;AACJ;AACA,OAAO,SAASS,YAAYA,CAACC,UAAU,EAAEC,SAAS,EAAE;EAChD,OAAO,IAAIC,OAAO,CAACC,OAAO,IAAI;IAC1B,IAAIC,MAAM,GAAG,KAAK;IAClB,IAAIC,aAAa,GAAG,KAAK;IACzB,MAAMC,CAAC,GAAGvB,OAAO,CAAC,cAAc,EAAEwB,MAAM,IAAI;MACxC,MAAMC,YAAY,GAAGR,UAAU,CAACS,IAAI,CAACF,MAAM,CAAC;MAC5C,IAAIN,SAAS,CAACO,YAAY,CAAC,EAAE;QACzB,IAAI,CAACJ,MAAM,EAAE;UACTC,aAAa,GAAG,IAAI;QACxB,CAAC,MACI;UACDC,CAAC,CAACI,OAAO,CAAC,CAAC;QACf;QACAP,OAAO,CAACK,YAAY,CAAC;MACzB;IACJ,CAAC,CAAC;IACFJ,MAAM,GAAG,IAAI;IACb,IAAIC,aAAa,EAAE;MACfC,CAAC,CAACI,OAAO,CAAC,CAAC;IACf;EACJ,CAAC,CAAC;AACN;AACA,OAAO,SAASC,mBAAmBA,CAACC,KAAK,EAAEC,QAAQ,EAAE;EACjD,OAAO,IAAIC,mBAAmB,CAACF,KAAK,EAAEC,QAAQ,CAAC;AACnD;AACA,OAAO,MAAMC,mBAAmB,SAAS9B,cAAc,CAAC;EACpDQ,WAAWA,CAACoB,KAAK,EAAEC,QAAQ,EAAE;IACzB,KAAK,CAAC,CAAC;IACP,IAAI,CAACD,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACC,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACE,QAAQ,GAAG,KAAK;IACrB,IAAI,CAACC,WAAW,GAAIC,IAAI,IAAK;MACzB,IAAIC,EAAE;MACN,MAAMC,QAAQ,GAAG,IAAI,CAACN,QAAQ,CAACI,IAAI,CAAC;MACpC,MAAMG,SAAS,GAAG,CAAC,IAAI,CAACL,QAAQ,IAAI,IAAI,CAACzB,KAAK,KAAK6B,QAAQ;MAC3D,CAACD,EAAE,GAAG9B,SAAS,CAAC,CAAC,MAAM,IAAI,IAAI8B,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACG,kCAAkC,CAAC,IAAI,EAAE;QAAEC,QAAQ,EAAE,IAAI,CAAChC,KAAK;QAAE6B,QAAQ;QAAEI,MAAM,EAAEC,SAAS;QAAEJ;MAAU,CAAC,CAAC;MACrK,IAAIA,SAAS,EAAE;QACX,IAAI,CAAC9B,KAAK,GAAG6B,QAAQ;QACrB,IAAI,IAAI,CAACJ,QAAQ,EAAE;UACf5B,WAAW,CAAEsC,EAAE,IAAK;YAChB,KAAK,MAAMC,CAAC,IAAI,IAAI,CAACC,SAAS,EAAE;cAC5BF,EAAE,CAACG,cAAc,CAACF,CAAC,EAAE,IAAI,CAAC;cAC1BA,CAAC,CAACG,YAAY,CAAC,IAAI,EAAEL,SAAS,CAAC;YACnC;UACJ,CAAC,EAAE,MAAM;YACL,MAAMM,IAAI,GAAG,IAAI,CAACC,YAAY,CAAC,CAAC;YAChC,OAAO,aAAa,IAAID,IAAI,GAAI,KAAIA,IAAK,EAAC,GAAG,EAAE,CAAC;UACpD,CAAC,CAAC;QACN;QACA,IAAI,CAACf,QAAQ,GAAG,IAAI;MACxB;IACJ,CAAC;EACL;EACAgB,YAAYA,CAAA,EAAG;IACX,OAAO7C,eAAe,CAAC,IAAI,CAAC2B,QAAQ,CAAC;EACzC;EACA,IAAIpB,SAASA,CAAA,EAAG;IACZ,MAAMqC,IAAI,GAAG,IAAI,CAACC,YAAY,CAAC,CAAC;IAChC,OAAO,YAAY,IAAID,IAAI,GAAI,KAAIA,IAAK,EAAC,GAAG,EAAE,CAAC;EACnD;EACAE,oBAAoBA,CAAA,EAAG;IACnB,IAAI,CAACC,YAAY,GAAG,IAAI,CAACrB,KAAK,CAAC,IAAI,CAACI,WAAW,CAAC;EACpD;EACAkB,qBAAqBA,CAAA,EAAG;IACpB,IAAI,CAACD,YAAY,CAACvB,OAAO,CAAC,CAAC;IAC3B,IAAI,CAACuB,YAAY,GAAGT,SAAS;IAC7B,IAAI,CAACT,QAAQ,GAAG,KAAK;IACrB,IAAI,CAACzB,KAAK,GAAGkC,SAAS;EAC1B;EACA7B,GAAGA,CAAA,EAAG;IACF,IAAI,IAAI,CAACsC,YAAY,EAAE;MACnB,IAAI,CAAC,IAAI,CAAClB,QAAQ,EAAE;QAChB,IAAI,CAACC,WAAW,CAACQ,SAAS,CAAC;MAC/B;MACA,OAAO,IAAI,CAAClC,KAAK;IACrB,CAAC,MACI;MACD;MACA,OAAO,IAAI,CAACuB,QAAQ,CAACW,SAAS,CAAC;IACnC;EACJ;AACJ;AACA,CAAC,UAAUb,mBAAmB,EAAE;EAC5BA,mBAAmB,CAACwB,QAAQ,GAAGrB,mBAAmB;AACtD,CAAC,EAAEH,mBAAmB,KAAKA,mBAAmB,GAAG,CAAC,CAAC,CAAC,CAAC;AACrD,OAAO,SAASyB,yBAAyBA,CAAC3C,SAAS,EAAEmB,KAAK,EAAE;EACxD,OAAO,IAAIyB,yBAAyB,CAAC5C,SAAS,EAAEmB,KAAK,CAAC;AAC1D;AACA,MAAMyB,yBAAyB,SAASrD,cAAc,CAAC;EACnDQ,WAAWA,CAACC,SAAS,EAAEmB,KAAK,EAAE;IAC1B,KAAK,CAAC,CAAC;IACP,IAAI,CAACnB,SAAS,GAAGA,SAAS;IAC1B,IAAI,CAACmB,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACI,WAAW,GAAG,MAAM;MACrB7B,WAAW,CAAEsC,EAAE,IAAK;QAChB,KAAK,MAAMC,CAAC,IAAI,IAAI,CAACC,SAAS,EAAE;UAC5BF,EAAE,CAACG,cAAc,CAACF,CAAC,EAAE,IAAI,CAAC;UAC1BA,CAAC,CAACG,YAAY,CAAC,IAAI,EAAEL,SAAS,CAAC;QACnC;MACJ,CAAC,EAAE,MAAM,IAAI,CAAC/B,SAAS,CAAC;IAC5B,CAAC;EACL;EACAuC,oBAAoBA,CAAA,EAAG;IACnB,IAAI,CAACC,YAAY,GAAG,IAAI,CAACrB,KAAK,CAAC,IAAI,CAACI,WAAW,CAAC;EACpD;EACAkB,qBAAqBA,CAAA,EAAG;IACpB,IAAI,CAACD,YAAY,CAACvB,OAAO,CAAC,CAAC;IAC3B,IAAI,CAACuB,YAAY,GAAGT,SAAS;EACjC;EACA7B,GAAGA,CAAA,EAAG;IACF;EAAA;AAER;AACA;AACA;AACA;AACA,OAAO,SAAS2C,gBAAgBA,CAAC7C,SAAS,EAAE;EACxC,OAAO,IAAI8C,gBAAgB,CAAC9C,SAAS,CAAC;AAC1C;AACA,MAAM8C,gBAAgB,SAASvD,cAAc,CAAC;EAC1CQ,WAAWA,CAACC,SAAS,EAAE;IACnB,KAAK,CAAC,CAAC;IACP,IAAI,CAACA,SAAS,GAAGA,SAAS;EAC9B;EACA+C,OAAOA,CAACf,EAAE,EAAEF,MAAM,EAAE;IAChB,IAAI,CAACE,EAAE,EAAE;MACLtC,WAAW,CAACsC,EAAE,IAAI;QACd,IAAI,CAACe,OAAO,CAACf,EAAE,EAAEF,MAAM,CAAC;MAC5B,CAAC,EAAE,MAAO,kBAAiB,IAAI,CAAC9B,SAAU,EAAC,CAAC;MAC5C;IACJ;IACA,KAAK,MAAMiC,CAAC,IAAI,IAAI,CAACC,SAAS,EAAE;MAC5BF,EAAE,CAACG,cAAc,CAACF,CAAC,EAAE,IAAI,CAAC;MAC1BA,CAAC,CAACG,YAAY,CAAC,IAAI,EAAEN,MAAM,CAAC;IAChC;EACJ;EACA5B,GAAGA,CAAA,EAAG;IACF;EAAA;AAER;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAAS8C,SAASA,CAACzC,UAAU,EAAE0C,cAAc,EAAE;EAClD,MAAMhB,CAAC,GAAG,IAAIiB,iBAAiB,CAACD,cAAc,KAAK,IAAI,IAAIA,cAAc,KAAK,KAAK,CAAC,GAAGA,cAAc,GAAG,KAAK,CAAC;EAC9G1C,UAAU,CAACJ,WAAW,CAAC8B,CAAC,CAAC;EACzB,IAAIgB,cAAc,EAAE;IAChB1C,UAAU,CAAC4C,aAAa,CAAC,CAAC;EAC9B;EACA,OAAO9D,YAAY,CAAC,MAAM;IACtBkB,UAAU,CAACF,cAAc,CAAC4B,CAAC,CAAC;EAChC,CAAC,CAAC;AACN;AACA,MAAMiB,iBAAiB,CAAC;EACpBnD,WAAWA,CAACkD,cAAc,EAAE;IACxB,IAAI,CAACA,cAAc,GAAGA,cAAc;IACpC,IAAI,CAACG,OAAO,GAAG,CAAC;EACpB;EACAC,WAAWA,CAAC9C,UAAU,EAAE;IACpB,IAAI,CAAC6C,OAAO,EAAE;EAClB;EACAE,SAASA,CAAC/C,UAAU,EAAE;IAClB,IAAI,CAAC6C,OAAO,EAAE;IACd,IAAI,IAAI,CAACA,OAAO,KAAK,CAAC,IAAI,IAAI,CAACH,cAAc,EAAE;MAC3C1C,UAAU,CAAC4C,aAAa,CAAC,CAAC;IAC9B;EACJ;EACAI,oBAAoBA,CAAChD,UAAU,EAAE;IAC7B;EAAA;EAEJ6B,YAAYA,CAAC7B,UAAU,EAAEuB,MAAM,EAAE;IAC7B;EAAA;AAER"},"metadata":{},"sourceType":"module","externalDependencies":[]}
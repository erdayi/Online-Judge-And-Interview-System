{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { assertFn, checkAdjacentItems } from '../../../base/common/assert.js';\nimport { LineRange } from '../core/lineRange.js';\nimport { OffsetRange } from '../core/offsetRange.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { DateTimeout, InfiniteTimeout, SequenceDiff } from './algorithms/diffAlgorithm.js';\nimport { DynamicProgrammingDiffing } from './algorithms/dynamicProgrammingDiffing.js';\nimport { optimizeSequenceDiffs, removeRandomMatches, smoothenSequenceDiffs } from './algorithms/joinSequenceDiffs.js';\nimport { MyersDiffAlgorithm } from './algorithms/myersDiffAlgorithm.js';\nimport { LineRangeMapping, LinesDiff, MovedText, RangeMapping, SimpleLineRangeMapping } from './linesDiffComputer.js';\nexport class StandardLinesDiffComputer {\n  constructor() {\n    this.dynamicProgrammingDiffing = new DynamicProgrammingDiffing();\n    this.myersDiffingAlgorithm = new MyersDiffAlgorithm();\n  }\n  computeDiff(originalLines, modifiedLines, options) {\n    if (originalLines.length === 1 && originalLines[0].length === 0 || modifiedLines.length === 1 && modifiedLines[0].length === 0) {\n      return {\n        changes: [new LineRangeMapping(new LineRange(1, originalLines.length + 1), new LineRange(1, modifiedLines.length + 1), [new RangeMapping(new Range(1, 1, originalLines.length, originalLines[0].length + 1), new Range(1, 1, modifiedLines.length, modifiedLines[0].length + 1))])],\n        hitTimeout: false,\n        moves: []\n      };\n    }\n    const timeout = options.maxComputationTimeMs === 0 ? InfiniteTimeout.instance : new DateTimeout(options.maxComputationTimeMs);\n    const considerWhitespaceChanges = !options.ignoreTrimWhitespace;\n    const perfectHashes = new Map();\n    function getOrCreateHash(text) {\n      let hash = perfectHashes.get(text);\n      if (hash === undefined) {\n        hash = perfectHashes.size;\n        perfectHashes.set(text, hash);\n      }\n      return hash;\n    }\n    const srcDocLines = originalLines.map(l => getOrCreateHash(l.trim()));\n    const tgtDocLines = modifiedLines.map(l => getOrCreateHash(l.trim()));\n    const sequence1 = new LineSequence(srcDocLines, originalLines);\n    const sequence2 = new LineSequence(tgtDocLines, modifiedLines);\n    const lineAlignmentResult = (() => {\n      if (sequence1.length + sequence2.length < 1500) {\n        // Use the improved algorithm for small files\n        return this.dynamicProgrammingDiffing.compute(sequence1, sequence2, timeout, (offset1, offset2) => originalLines[offset1] === modifiedLines[offset2] ? modifiedLines[offset2].length === 0 ? 0.1 : 1 + Math.log(1 + modifiedLines[offset2].length) : 0.99);\n      }\n      return this.myersDiffingAlgorithm.compute(sequence1, sequence2);\n    })();\n    let lineAlignments = lineAlignmentResult.diffs;\n    let hitTimeout = lineAlignmentResult.hitTimeout;\n    lineAlignments = optimizeSequenceDiffs(sequence1, sequence2, lineAlignments);\n    const alignments = [];\n    const scanForWhitespaceChanges = equalLinesCount => {\n      if (!considerWhitespaceChanges) {\n        return;\n      }\n      for (let i = 0; i < equalLinesCount; i++) {\n        const seq1Offset = seq1LastStart + i;\n        const seq2Offset = seq2LastStart + i;\n        if (originalLines[seq1Offset] !== modifiedLines[seq2Offset]) {\n          // This is because of whitespace changes, diff these lines\n          const characterDiffs = this.refineDiff(originalLines, modifiedLines, new SequenceDiff(new OffsetRange(seq1Offset, seq1Offset + 1), new OffsetRange(seq2Offset, seq2Offset + 1)), timeout, considerWhitespaceChanges);\n          for (const a of characterDiffs.mappings) {\n            alignments.push(a);\n          }\n          if (characterDiffs.hitTimeout) {\n            hitTimeout = true;\n          }\n        }\n      }\n    };\n    let seq1LastStart = 0;\n    let seq2LastStart = 0;\n    for (const diff of lineAlignments) {\n      assertFn(() => diff.seq1Range.start - seq1LastStart === diff.seq2Range.start - seq2LastStart);\n      const equalLinesCount = diff.seq1Range.start - seq1LastStart;\n      scanForWhitespaceChanges(equalLinesCount);\n      seq1LastStart = diff.seq1Range.endExclusive;\n      seq2LastStart = diff.seq2Range.endExclusive;\n      const characterDiffs = this.refineDiff(originalLines, modifiedLines, diff, timeout, considerWhitespaceChanges);\n      if (characterDiffs.hitTimeout) {\n        hitTimeout = true;\n      }\n      for (const a of characterDiffs.mappings) {\n        alignments.push(a);\n      }\n    }\n    scanForWhitespaceChanges(originalLines.length - seq1LastStart);\n    const changes = lineRangeMappingFromRangeMappings(alignments, originalLines, modifiedLines);\n    const moves = [];\n    if (options.computeMoves) {\n      const deletions = changes.filter(c => c.modifiedRange.isEmpty && c.originalRange.length >= 3).map(d => new LineRangeFragment(d.originalRange, originalLines));\n      const insertions = new Set(changes.filter(c => c.originalRange.isEmpty && c.modifiedRange.length >= 3).map(d => new LineRangeFragment(d.modifiedRange, modifiedLines)));\n      for (const deletion of deletions) {\n        let highestSimilarity = -1;\n        let best;\n        for (const insertion of insertions) {\n          const similarity = deletion.computeSimilarity(insertion);\n          if (similarity > highestSimilarity) {\n            highestSimilarity = similarity;\n            best = insertion;\n          }\n        }\n        if (highestSimilarity > 0.90 && best) {\n          const moveChanges = this.refineDiff(originalLines, modifiedLines, new SequenceDiff(new OffsetRange(deletion.range.startLineNumber - 1, deletion.range.endLineNumberExclusive - 1), new OffsetRange(best.range.startLineNumber - 1, best.range.endLineNumberExclusive - 1)), timeout, considerWhitespaceChanges);\n          const mappings = lineRangeMappingFromRangeMappings(moveChanges.mappings, originalLines, modifiedLines, true);\n          insertions.delete(best);\n          moves.push(new MovedText(new SimpleLineRangeMapping(deletion.range, best.range), mappings));\n        }\n      }\n    }\n    // Make sure all ranges are valid\n    assertFn(() => {\n      function validatePosition(pos, lines) {\n        if (pos.lineNumber < 1 || pos.lineNumber > lines.length) {\n          return false;\n        }\n        const line = lines[pos.lineNumber - 1];\n        if (pos.column < 1 || pos.column > line.length + 1) {\n          return false;\n        }\n        return true;\n      }\n      function validateRange(range, lines) {\n        if (range.startLineNumber < 1 || range.startLineNumber > lines.length + 1) {\n          return false;\n        }\n        if (range.endLineNumberExclusive < 1 || range.endLineNumberExclusive > lines.length + 1) {\n          return false;\n        }\n        return true;\n      }\n      for (const c of changes) {\n        if (!c.innerChanges) {\n          return false;\n        }\n        for (const ic of c.innerChanges) {\n          const valid = validatePosition(ic.modifiedRange.getStartPosition(), modifiedLines) && validatePosition(ic.modifiedRange.getEndPosition(), modifiedLines) && validatePosition(ic.originalRange.getStartPosition(), originalLines) && validatePosition(ic.originalRange.getEndPosition(), originalLines);\n          if (!valid) {\n            return false;\n          }\n        }\n        if (!validateRange(c.modifiedRange, modifiedLines) || !validateRange(c.originalRange, originalLines)) {\n          return false;\n        }\n      }\n      return true;\n    });\n    return new LinesDiff(changes, moves, hitTimeout);\n  }\n  refineDiff(originalLines, modifiedLines, diff, timeout, considerWhitespaceChanges) {\n    const slice1 = new LinesSliceCharSequence(originalLines, diff.seq1Range, considerWhitespaceChanges);\n    const slice2 = new LinesSliceCharSequence(modifiedLines, diff.seq2Range, considerWhitespaceChanges);\n    const diffResult = slice1.length + slice2.length < 500 ? this.dynamicProgrammingDiffing.compute(slice1, slice2, timeout) : this.myersDiffingAlgorithm.compute(slice1, slice2, timeout);\n    let diffs = diffResult.diffs;\n    diffs = optimizeSequenceDiffs(slice1, slice2, diffs);\n    diffs = coverFullWords(slice1, slice2, diffs);\n    diffs = smoothenSequenceDiffs(slice1, slice2, diffs);\n    diffs = removeRandomMatches(slice1, slice2, diffs);\n    const result = diffs.map(d => new RangeMapping(slice1.translateRange(d.seq1Range), slice2.translateRange(d.seq2Range)));\n    // Assert: result applied on original should be the same as diff applied to original\n    return {\n      mappings: result,\n      hitTimeout: diffResult.hitTimeout\n    };\n  }\n}\nfunction coverFullWords(sequence1, sequence2, sequenceDiffs) {\n  const additional = [];\n  let lastModifiedWord = undefined;\n  function maybePushWordToAdditional() {\n    if (!lastModifiedWord) {\n      return;\n    }\n    const originalLength1 = lastModifiedWord.s1Range.length - lastModifiedWord.deleted;\n    const originalLength2 = lastModifiedWord.s2Range.length - lastModifiedWord.added;\n    if (originalLength1 !== originalLength2) {\n      // TODO figure out why this happens\n    }\n    if (Math.max(lastModifiedWord.deleted, lastModifiedWord.added) + (lastModifiedWord.count - 1) > originalLength1) {\n      additional.push(new SequenceDiff(lastModifiedWord.s1Range, lastModifiedWord.s2Range));\n    }\n    lastModifiedWord = undefined;\n  }\n  for (const s of sequenceDiffs) {\n    function processWord(s1Range, s2Range) {\n      var _a, _b, _c, _d;\n      if (!lastModifiedWord || !lastModifiedWord.s1Range.containsRange(s1Range) || !lastModifiedWord.s2Range.containsRange(s2Range)) {\n        if (lastModifiedWord && !(lastModifiedWord.s1Range.endExclusive < s1Range.start && lastModifiedWord.s2Range.endExclusive < s2Range.start)) {\n          const s1Added = OffsetRange.tryCreate(lastModifiedWord.s1Range.endExclusive, s1Range.start);\n          const s2Added = OffsetRange.tryCreate(lastModifiedWord.s2Range.endExclusive, s2Range.start);\n          lastModifiedWord.deleted += (_a = s1Added === null || s1Added === void 0 ? void 0 : s1Added.length) !== null && _a !== void 0 ? _a : 0;\n          lastModifiedWord.added += (_b = s2Added === null || s2Added === void 0 ? void 0 : s2Added.length) !== null && _b !== void 0 ? _b : 0;\n          lastModifiedWord.s1Range = lastModifiedWord.s1Range.join(s1Range);\n          lastModifiedWord.s2Range = lastModifiedWord.s2Range.join(s2Range);\n        } else {\n          maybePushWordToAdditional();\n          lastModifiedWord = {\n            added: 0,\n            deleted: 0,\n            count: 0,\n            s1Range: s1Range,\n            s2Range: s2Range\n          };\n        }\n      }\n      const changedS1 = s1Range.intersect(s.seq1Range);\n      const changedS2 = s2Range.intersect(s.seq2Range);\n      lastModifiedWord.count++;\n      lastModifiedWord.deleted += (_c = changedS1 === null || changedS1 === void 0 ? void 0 : changedS1.length) !== null && _c !== void 0 ? _c : 0;\n      lastModifiedWord.added += (_d = changedS2 === null || changedS2 === void 0 ? void 0 : changedS2.length) !== null && _d !== void 0 ? _d : 0;\n    }\n    const w1Before = sequence1.findWordContaining(s.seq1Range.start - 1);\n    const w2Before = sequence2.findWordContaining(s.seq2Range.start - 1);\n    const w1After = sequence1.findWordContaining(s.seq1Range.endExclusive);\n    const w2After = sequence2.findWordContaining(s.seq2Range.endExclusive);\n    if (w1Before && w1After && w2Before && w2After && w1Before.equals(w1After) && w2Before.equals(w2After)) {\n      processWord(w1Before, w2Before);\n    } else {\n      if (w1Before && w2Before) {\n        processWord(w1Before, w2Before);\n      }\n      if (w1After && w2After) {\n        processWord(w1After, w2After);\n      }\n    }\n  }\n  maybePushWordToAdditional();\n  const merged = mergeSequenceDiffs(sequenceDiffs, additional);\n  return merged;\n}\nfunction mergeSequenceDiffs(sequenceDiffs1, sequenceDiffs2) {\n  const result = [];\n  while (sequenceDiffs1.length > 0 || sequenceDiffs2.length > 0) {\n    const sd1 = sequenceDiffs1[0];\n    const sd2 = sequenceDiffs2[0];\n    let next;\n    if (sd1 && (!sd2 || sd1.seq1Range.start < sd2.seq1Range.start)) {\n      next = sequenceDiffs1.shift();\n    } else {\n      next = sequenceDiffs2.shift();\n    }\n    if (result.length > 0 && result[result.length - 1].seq1Range.endExclusive >= next.seq1Range.start) {\n      result[result.length - 1] = result[result.length - 1].join(next);\n    } else {\n      result.push(next);\n    }\n  }\n  return result;\n}\nexport function lineRangeMappingFromRangeMappings(alignments, originalLines, modifiedLines, dontAssertStartLine = false) {\n  const changes = [];\n  for (const g of group(alignments.map(a => getLineRangeMapping(a, originalLines, modifiedLines)), (a1, a2) => a1.originalRange.overlapOrTouch(a2.originalRange) || a1.modifiedRange.overlapOrTouch(a2.modifiedRange))) {\n    const first = g[0];\n    const last = g[g.length - 1];\n    changes.push(new LineRangeMapping(first.originalRange.join(last.originalRange), first.modifiedRange.join(last.modifiedRange), g.map(a => a.innerChanges[0])));\n  }\n  assertFn(() => {\n    if (!dontAssertStartLine) {\n      if (changes.length > 0 && changes[0].originalRange.startLineNumber !== changes[0].modifiedRange.startLineNumber) {\n        return false;\n      }\n    }\n    return checkAdjacentItems(changes, (m1, m2) => m2.originalRange.startLineNumber - m1.originalRange.endLineNumberExclusive === m2.modifiedRange.startLineNumber - m1.modifiedRange.endLineNumberExclusive &&\n    // There has to be an unchanged line in between (otherwise both diffs should have been joined)\n    m1.originalRange.endLineNumberExclusive < m2.originalRange.startLineNumber && m1.modifiedRange.endLineNumberExclusive < m2.modifiedRange.startLineNumber);\n  });\n  return changes;\n}\nexport function getLineRangeMapping(rangeMapping, originalLines, modifiedLines) {\n  let lineStartDelta = 0;\n  let lineEndDelta = 0;\n  // rangeMapping describes the edit that replaces `rangeMapping.originalRange` with `newText := getText(modifiedLines, rangeMapping.modifiedRange)`.\n  // original: ]xxx \\n <- this line is not modified\n  // modified: ]xx  \\n\n  if (rangeMapping.modifiedRange.endColumn === 1 && rangeMapping.originalRange.endColumn === 1 && rangeMapping.originalRange.startLineNumber + lineStartDelta <= rangeMapping.originalRange.endLineNumber && rangeMapping.modifiedRange.startLineNumber + lineStartDelta <= rangeMapping.modifiedRange.endLineNumber) {\n    // We can only do this if the range is not empty yet\n    lineEndDelta = -1;\n  }\n  // original: xxx[ \\n <- this line is not modified\n  // modified: xxx[ \\n\n  if (rangeMapping.modifiedRange.startColumn - 1 >= modifiedLines[rangeMapping.modifiedRange.startLineNumber - 1].length && rangeMapping.originalRange.startColumn - 1 >= originalLines[rangeMapping.originalRange.startLineNumber - 1].length && rangeMapping.originalRange.startLineNumber <= rangeMapping.originalRange.endLineNumber + lineEndDelta && rangeMapping.modifiedRange.startLineNumber <= rangeMapping.modifiedRange.endLineNumber + lineEndDelta) {\n    // We can only do this if the range is not empty yet\n    lineStartDelta = 1;\n  }\n  const originalLineRange = new LineRange(rangeMapping.originalRange.startLineNumber + lineStartDelta, rangeMapping.originalRange.endLineNumber + 1 + lineEndDelta);\n  const modifiedLineRange = new LineRange(rangeMapping.modifiedRange.startLineNumber + lineStartDelta, rangeMapping.modifiedRange.endLineNumber + 1 + lineEndDelta);\n  return new LineRangeMapping(originalLineRange, modifiedLineRange, [rangeMapping]);\n}\nfunction* group(items, shouldBeGrouped) {\n  let currentGroup;\n  let last;\n  for (const item of items) {\n    if (last !== undefined && shouldBeGrouped(last, item)) {\n      currentGroup.push(item);\n    } else {\n      if (currentGroup) {\n        yield currentGroup;\n      }\n      currentGroup = [item];\n    }\n    last = item;\n  }\n  if (currentGroup) {\n    yield currentGroup;\n  }\n}\nexport class LineSequence {\n  constructor(trimmedHash, lines) {\n    this.trimmedHash = trimmedHash;\n    this.lines = lines;\n  }\n  getElement(offset) {\n    return this.trimmedHash[offset];\n  }\n  get length() {\n    return this.trimmedHash.length;\n  }\n  getBoundaryScore(length) {\n    const indentationBefore = length === 0 ? 0 : getIndentation(this.lines[length - 1]);\n    const indentationAfter = length === this.lines.length ? 0 : getIndentation(this.lines[length]);\n    return 1000 - (indentationBefore + indentationAfter);\n  }\n}\nfunction getIndentation(str) {\n  let i = 0;\n  while (i < str.length && (str.charCodeAt(i) === 32 /* CharCode.Space */ || str.charCodeAt(i) === 9 /* CharCode.Tab */)) {\n    i++;\n  }\n  return i;\n}\nexport class LinesSliceCharSequence {\n  constructor(lines, lineRange, considerWhitespaceChanges) {\n    // This slice has to have lineRange.length many \\n! (otherwise diffing against an empty slice will be problematic)\n    // (Unless it covers the entire document, in that case the other slice also has to cover the entire document ands it's okay)\n    this.lines = lines;\n    this.considerWhitespaceChanges = considerWhitespaceChanges;\n    this.elements = [];\n    this.firstCharOffsetByLineMinusOne = [];\n    // To account for trimming\n    this.offsetByLine = [];\n    // If the slice covers the end, but does not start at the beginning, we include just the \\n of the previous line.\n    let trimFirstLineFully = false;\n    if (lineRange.start > 0 && lineRange.endExclusive >= lines.length) {\n      lineRange = new OffsetRange(lineRange.start - 1, lineRange.endExclusive);\n      trimFirstLineFully = true;\n    }\n    this.lineRange = lineRange;\n    for (let i = this.lineRange.start; i < this.lineRange.endExclusive; i++) {\n      let line = lines[i];\n      let offset = 0;\n      if (trimFirstLineFully) {\n        offset = line.length;\n        line = '';\n        trimFirstLineFully = false;\n      } else if (!considerWhitespaceChanges) {\n        const trimmedStartLine = line.trimStart();\n        offset = line.length - trimmedStartLine.length;\n        line = trimmedStartLine.trimEnd();\n      }\n      this.offsetByLine.push(offset);\n      for (let i = 0; i < line.length; i++) {\n        this.elements.push(line.charCodeAt(i));\n      }\n      // Don't add an \\n that does not exist in the document.\n      if (i < lines.length - 1) {\n        this.elements.push('\\n'.charCodeAt(0));\n        this.firstCharOffsetByLineMinusOne[i - this.lineRange.start] = this.elements.length;\n      }\n    }\n    // To account for the last line\n    this.offsetByLine.push(0);\n  }\n  toString() {\n    return `Slice: \"${this.text}\"`;\n  }\n  get text() {\n    return this.getText(new OffsetRange(0, this.length));\n  }\n  getText(range) {\n    return this.elements.slice(range.start, range.endExclusive).map(e => String.fromCharCode(e)).join('');\n  }\n  getElement(offset) {\n    return this.elements[offset];\n  }\n  get length() {\n    return this.elements.length;\n  }\n  getBoundaryScore(length) {\n    //   a   b   c   ,           d   e   f\n    // 11  0   0   12  15  6   13  0   0   11\n    const prevCategory = getCategory(length > 0 ? this.elements[length - 1] : -1);\n    const nextCategory = getCategory(length < this.elements.length ? this.elements[length] : -1);\n    if (prevCategory === 6 /* CharBoundaryCategory.LineBreakCR */ && nextCategory === 7 /* CharBoundaryCategory.LineBreakLF */) {\n      // don't break between \\r and \\n\n      return 0;\n    }\n    let score = 0;\n    if (prevCategory !== nextCategory) {\n      score += 10;\n      if (nextCategory === 1 /* CharBoundaryCategory.WordUpper */) {\n        score += 1;\n      }\n    }\n    score += getCategoryBoundaryScore(prevCategory);\n    score += getCategoryBoundaryScore(nextCategory);\n    return score;\n  }\n  translateOffset(offset) {\n    // find smallest i, so that lineBreakOffsets[i] <= offset using binary search\n    if (this.lineRange.isEmpty) {\n      return new Position(this.lineRange.start + 1, 1);\n    }\n    let i = 0;\n    let j = this.firstCharOffsetByLineMinusOne.length;\n    while (i < j) {\n      const k = Math.floor((i + j) / 2);\n      if (this.firstCharOffsetByLineMinusOne[k] > offset) {\n        j = k;\n      } else {\n        i = k + 1;\n      }\n    }\n    const offsetOfFirstCharInLine = i === 0 ? 0 : this.firstCharOffsetByLineMinusOne[i - 1];\n    return new Position(this.lineRange.start + i + 1, offset - offsetOfFirstCharInLine + 1 + this.offsetByLine[i]);\n  }\n  translateRange(range) {\n    return Range.fromPositions(this.translateOffset(range.start), this.translateOffset(range.endExclusive));\n  }\n  /**\n   * Finds the word that contains the character at the given offset\n   */\n  findWordContaining(offset) {\n    if (offset < 0 || offset >= this.elements.length) {\n      return undefined;\n    }\n    if (!isWordChar(this.elements[offset])) {\n      return undefined;\n    }\n    // find start\n    let start = offset;\n    while (start > 0 && isWordChar(this.elements[start - 1])) {\n      start--;\n    }\n    // find end\n    let end = offset;\n    while (end < this.elements.length && isWordChar(this.elements[end])) {\n      end++;\n    }\n    return new OffsetRange(start, end);\n  }\n  countLinesIn(range) {\n    return this.translateOffset(range.endExclusive).lineNumber - this.translateOffset(range.start).lineNumber;\n  }\n}\nfunction isWordChar(charCode) {\n  return charCode >= 97 /* CharCode.a */ && charCode <= 122 /* CharCode.z */ || charCode >= 65 /* CharCode.A */ && charCode <= 90 /* CharCode.Z */ || charCode >= 48 /* CharCode.Digit0 */ && charCode <= 57 /* CharCode.Digit9 */;\n}\n\nconst score = {\n  [0 /* CharBoundaryCategory.WordLower */]: 0,\n  [1 /* CharBoundaryCategory.WordUpper */]: 0,\n  [2 /* CharBoundaryCategory.WordNumber */]: 0,\n  [3 /* CharBoundaryCategory.End */]: 10,\n  [4 /* CharBoundaryCategory.Other */]: 2,\n  [5 /* CharBoundaryCategory.Space */]: 3,\n  [6 /* CharBoundaryCategory.LineBreakCR */]: 10,\n  [7 /* CharBoundaryCategory.LineBreakLF */]: 10\n};\nfunction getCategoryBoundaryScore(category) {\n  return score[category];\n}\nfunction getCategory(charCode) {\n  if (charCode === 10 /* CharCode.LineFeed */) {\n    return 7 /* CharBoundaryCategory.LineBreakLF */;\n  } else if (charCode === 13 /* CharCode.CarriageReturn */) {\n    return 6 /* CharBoundaryCategory.LineBreakCR */;\n  } else if (isSpace(charCode)) {\n    return 5 /* CharBoundaryCategory.Space */;\n  } else if (charCode >= 97 /* CharCode.a */ && charCode <= 122 /* CharCode.z */) {\n    return 0 /* CharBoundaryCategory.WordLower */;\n  } else if (charCode >= 65 /* CharCode.A */ && charCode <= 90 /* CharCode.Z */) {\n    return 1 /* CharBoundaryCategory.WordUpper */;\n  } else if (charCode >= 48 /* CharCode.Digit0 */ && charCode <= 57 /* CharCode.Digit9 */) {\n    return 2 /* CharBoundaryCategory.WordNumber */;\n  } else if (charCode === -1) {\n    return 3 /* CharBoundaryCategory.End */;\n  } else {\n    return 4 /* CharBoundaryCategory.Other */;\n  }\n}\n\nfunction isSpace(charCode) {\n  return charCode === 32 /* CharCode.Space */ || charCode === 9 /* CharCode.Tab */;\n}\n\nconst chrKeys = new Map();\nfunction getKey(chr) {\n  let key = chrKeys.get(chr);\n  if (key === undefined) {\n    key = chrKeys.size;\n    chrKeys.set(chr, key);\n  }\n  return key;\n}\nclass LineRangeFragment {\n  constructor(range, lines) {\n    this.range = range;\n    this.lines = lines;\n    this.histogram = [];\n    let counter = 0;\n    for (let i = range.startLineNumber - 1; i < range.endLineNumberExclusive - 1; i++) {\n      const line = lines[i];\n      for (let j = 0; j < line.length; j++) {\n        counter++;\n        const chr = line[j];\n        const key = getKey(chr);\n        this.histogram[key] = (this.histogram[key] || 0) + 1;\n      }\n      counter++;\n      const key = getKey('\\n');\n      this.histogram[key] = (this.histogram[key] || 0) + 1;\n    }\n    this.totalCount = counter;\n  }\n  computeSimilarity(other) {\n    var _a, _b;\n    let sumDifferences = 0;\n    const maxLength = Math.max(this.histogram.length, other.histogram.length);\n    for (let i = 0; i < maxLength; i++) {\n      sumDifferences += Math.abs(((_a = this.histogram[i]) !== null && _a !== void 0 ? _a : 0) - ((_b = other.histogram[i]) !== null && _b !== void 0 ? _b : 0));\n    }\n    return 1 - sumDifferences / (this.totalCount + other.totalCount);\n  }\n}","map":{"version":3,"names":["assertFn","checkAdjacentItems","LineRange","OffsetRange","Position","Range","DateTimeout","InfiniteTimeout","SequenceDiff","DynamicProgrammingDiffing","optimizeSequenceDiffs","removeRandomMatches","smoothenSequenceDiffs","MyersDiffAlgorithm","LineRangeMapping","LinesDiff","MovedText","RangeMapping","SimpleLineRangeMapping","StandardLinesDiffComputer","constructor","dynamicProgrammingDiffing","myersDiffingAlgorithm","computeDiff","originalLines","modifiedLines","options","length","changes","hitTimeout","moves","timeout","maxComputationTimeMs","instance","considerWhitespaceChanges","ignoreTrimWhitespace","perfectHashes","Map","getOrCreateHash","text","hash","get","undefined","size","set","srcDocLines","map","l","trim","tgtDocLines","sequence1","LineSequence","sequence2","lineAlignmentResult","compute","offset1","offset2","Math","log","lineAlignments","diffs","alignments","scanForWhitespaceChanges","equalLinesCount","i","seq1Offset","seq1LastStart","seq2Offset","seq2LastStart","characterDiffs","refineDiff","a","mappings","push","diff","seq1Range","start","seq2Range","endExclusive","lineRangeMappingFromRangeMappings","computeMoves","deletions","filter","c","modifiedRange","isEmpty","originalRange","d","LineRangeFragment","insertions","Set","deletion","highestSimilarity","best","insertion","similarity","computeSimilarity","moveChanges","range","startLineNumber","endLineNumberExclusive","delete","validatePosition","pos","lines","lineNumber","line","column","validateRange","innerChanges","ic","valid","getStartPosition","getEndPosition","slice1","LinesSliceCharSequence","slice2","diffResult","coverFullWords","result","translateRange","sequenceDiffs","additional","lastModifiedWord","maybePushWordToAdditional","originalLength1","s1Range","deleted","originalLength2","s2Range","added","max","count","s","processWord","_a","_b","_c","_d","containsRange","s1Added","tryCreate","s2Added","join","changedS1","intersect","changedS2","w1Before","findWordContaining","w2Before","w1After","w2After","equals","merged","mergeSequenceDiffs","sequenceDiffs1","sequenceDiffs2","sd1","sd2","next","shift","dontAssertStartLine","g","group","getLineRangeMapping","a1","a2","overlapOrTouch","first","last","m1","m2","rangeMapping","lineStartDelta","lineEndDelta","endColumn","endLineNumber","startColumn","originalLineRange","modifiedLineRange","items","shouldBeGrouped","currentGroup","item","trimmedHash","getElement","offset","getBoundaryScore","indentationBefore","getIndentation","indentationAfter","str","charCodeAt","lineRange","elements","firstCharOffsetByLineMinusOne","offsetByLine","trimFirstLineFully","trimmedStartLine","trimStart","trimEnd","toString","getText","slice","e","String","fromCharCode","prevCategory","getCategory","nextCategory","score","getCategoryBoundaryScore","translateOffset","j","k","floor","offsetOfFirstCharInLine","fromPositions","isWordChar","end","countLinesIn","charCode","category","isSpace","chrKeys","getKey","chr","key","histogram","counter","totalCount","other","sumDifferences","maxLength","abs"],"sources":["D:/code/java/program/oj/code/yuoj-frontend-master/node_modules/monaco-editor/esm/vs/editor/common/diff/standardLinesDiffComputer.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { assertFn, checkAdjacentItems } from '../../../base/common/assert.js';\nimport { LineRange } from '../core/lineRange.js';\nimport { OffsetRange } from '../core/offsetRange.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { DateTimeout, InfiniteTimeout, SequenceDiff } from './algorithms/diffAlgorithm.js';\nimport { DynamicProgrammingDiffing } from './algorithms/dynamicProgrammingDiffing.js';\nimport { optimizeSequenceDiffs, removeRandomMatches, smoothenSequenceDiffs } from './algorithms/joinSequenceDiffs.js';\nimport { MyersDiffAlgorithm } from './algorithms/myersDiffAlgorithm.js';\nimport { LineRangeMapping, LinesDiff, MovedText, RangeMapping, SimpleLineRangeMapping } from './linesDiffComputer.js';\nexport class StandardLinesDiffComputer {\n    constructor() {\n        this.dynamicProgrammingDiffing = new DynamicProgrammingDiffing();\n        this.myersDiffingAlgorithm = new MyersDiffAlgorithm();\n    }\n    computeDiff(originalLines, modifiedLines, options) {\n        if (originalLines.length === 1 && originalLines[0].length === 0 || modifiedLines.length === 1 && modifiedLines[0].length === 0) {\n            return {\n                changes: [\n                    new LineRangeMapping(new LineRange(1, originalLines.length + 1), new LineRange(1, modifiedLines.length + 1), [\n                        new RangeMapping(new Range(1, 1, originalLines.length, originalLines[0].length + 1), new Range(1, 1, modifiedLines.length, modifiedLines[0].length + 1))\n                    ])\n                ],\n                hitTimeout: false,\n                moves: [],\n            };\n        }\n        const timeout = options.maxComputationTimeMs === 0 ? InfiniteTimeout.instance : new DateTimeout(options.maxComputationTimeMs);\n        const considerWhitespaceChanges = !options.ignoreTrimWhitespace;\n        const perfectHashes = new Map();\n        function getOrCreateHash(text) {\n            let hash = perfectHashes.get(text);\n            if (hash === undefined) {\n                hash = perfectHashes.size;\n                perfectHashes.set(text, hash);\n            }\n            return hash;\n        }\n        const srcDocLines = originalLines.map((l) => getOrCreateHash(l.trim()));\n        const tgtDocLines = modifiedLines.map((l) => getOrCreateHash(l.trim()));\n        const sequence1 = new LineSequence(srcDocLines, originalLines);\n        const sequence2 = new LineSequence(tgtDocLines, modifiedLines);\n        const lineAlignmentResult = (() => {\n            if (sequence1.length + sequence2.length < 1500) {\n                // Use the improved algorithm for small files\n                return this.dynamicProgrammingDiffing.compute(sequence1, sequence2, timeout, (offset1, offset2) => originalLines[offset1] === modifiedLines[offset2]\n                    ? modifiedLines[offset2].length === 0\n                        ? 0.1\n                        : 1 + Math.log(1 + modifiedLines[offset2].length)\n                    : 0.99);\n            }\n            return this.myersDiffingAlgorithm.compute(sequence1, sequence2);\n        })();\n        let lineAlignments = lineAlignmentResult.diffs;\n        let hitTimeout = lineAlignmentResult.hitTimeout;\n        lineAlignments = optimizeSequenceDiffs(sequence1, sequence2, lineAlignments);\n        const alignments = [];\n        const scanForWhitespaceChanges = (equalLinesCount) => {\n            if (!considerWhitespaceChanges) {\n                return;\n            }\n            for (let i = 0; i < equalLinesCount; i++) {\n                const seq1Offset = seq1LastStart + i;\n                const seq2Offset = seq2LastStart + i;\n                if (originalLines[seq1Offset] !== modifiedLines[seq2Offset]) {\n                    // This is because of whitespace changes, diff these lines\n                    const characterDiffs = this.refineDiff(originalLines, modifiedLines, new SequenceDiff(new OffsetRange(seq1Offset, seq1Offset + 1), new OffsetRange(seq2Offset, seq2Offset + 1)), timeout, considerWhitespaceChanges);\n                    for (const a of characterDiffs.mappings) {\n                        alignments.push(a);\n                    }\n                    if (characterDiffs.hitTimeout) {\n                        hitTimeout = true;\n                    }\n                }\n            }\n        };\n        let seq1LastStart = 0;\n        let seq2LastStart = 0;\n        for (const diff of lineAlignments) {\n            assertFn(() => diff.seq1Range.start - seq1LastStart === diff.seq2Range.start - seq2LastStart);\n            const equalLinesCount = diff.seq1Range.start - seq1LastStart;\n            scanForWhitespaceChanges(equalLinesCount);\n            seq1LastStart = diff.seq1Range.endExclusive;\n            seq2LastStart = diff.seq2Range.endExclusive;\n            const characterDiffs = this.refineDiff(originalLines, modifiedLines, diff, timeout, considerWhitespaceChanges);\n            if (characterDiffs.hitTimeout) {\n                hitTimeout = true;\n            }\n            for (const a of characterDiffs.mappings) {\n                alignments.push(a);\n            }\n        }\n        scanForWhitespaceChanges(originalLines.length - seq1LastStart);\n        const changes = lineRangeMappingFromRangeMappings(alignments, originalLines, modifiedLines);\n        const moves = [];\n        if (options.computeMoves) {\n            const deletions = changes\n                .filter(c => c.modifiedRange.isEmpty && c.originalRange.length >= 3)\n                .map(d => new LineRangeFragment(d.originalRange, originalLines));\n            const insertions = new Set(changes\n                .filter(c => c.originalRange.isEmpty && c.modifiedRange.length >= 3)\n                .map(d => new LineRangeFragment(d.modifiedRange, modifiedLines)));\n            for (const deletion of deletions) {\n                let highestSimilarity = -1;\n                let best;\n                for (const insertion of insertions) {\n                    const similarity = deletion.computeSimilarity(insertion);\n                    if (similarity > highestSimilarity) {\n                        highestSimilarity = similarity;\n                        best = insertion;\n                    }\n                }\n                if (highestSimilarity > 0.90 && best) {\n                    const moveChanges = this.refineDiff(originalLines, modifiedLines, new SequenceDiff(new OffsetRange(deletion.range.startLineNumber - 1, deletion.range.endLineNumberExclusive - 1), new OffsetRange(best.range.startLineNumber - 1, best.range.endLineNumberExclusive - 1)), timeout, considerWhitespaceChanges);\n                    const mappings = lineRangeMappingFromRangeMappings(moveChanges.mappings, originalLines, modifiedLines, true);\n                    insertions.delete(best);\n                    moves.push(new MovedText(new SimpleLineRangeMapping(deletion.range, best.range), mappings));\n                }\n            }\n        }\n        // Make sure all ranges are valid\n        assertFn(() => {\n            function validatePosition(pos, lines) {\n                if (pos.lineNumber < 1 || pos.lineNumber > lines.length) {\n                    return false;\n                }\n                const line = lines[pos.lineNumber - 1];\n                if (pos.column < 1 || pos.column > line.length + 1) {\n                    return false;\n                }\n                return true;\n            }\n            function validateRange(range, lines) {\n                if (range.startLineNumber < 1 || range.startLineNumber > lines.length + 1) {\n                    return false;\n                }\n                if (range.endLineNumberExclusive < 1 || range.endLineNumberExclusive > lines.length + 1) {\n                    return false;\n                }\n                return true;\n            }\n            for (const c of changes) {\n                if (!c.innerChanges) {\n                    return false;\n                }\n                for (const ic of c.innerChanges) {\n                    const valid = validatePosition(ic.modifiedRange.getStartPosition(), modifiedLines) && validatePosition(ic.modifiedRange.getEndPosition(), modifiedLines) &&\n                        validatePosition(ic.originalRange.getStartPosition(), originalLines) && validatePosition(ic.originalRange.getEndPosition(), originalLines);\n                    if (!valid) {\n                        return false;\n                    }\n                }\n                if (!validateRange(c.modifiedRange, modifiedLines) || !validateRange(c.originalRange, originalLines)) {\n                    return false;\n                }\n            }\n            return true;\n        });\n        return new LinesDiff(changes, moves, hitTimeout);\n    }\n    refineDiff(originalLines, modifiedLines, diff, timeout, considerWhitespaceChanges) {\n        const slice1 = new LinesSliceCharSequence(originalLines, diff.seq1Range, considerWhitespaceChanges);\n        const slice2 = new LinesSliceCharSequence(modifiedLines, diff.seq2Range, considerWhitespaceChanges);\n        const diffResult = slice1.length + slice2.length < 500\n            ? this.dynamicProgrammingDiffing.compute(slice1, slice2, timeout)\n            : this.myersDiffingAlgorithm.compute(slice1, slice2, timeout);\n        let diffs = diffResult.diffs;\n        diffs = optimizeSequenceDiffs(slice1, slice2, diffs);\n        diffs = coverFullWords(slice1, slice2, diffs);\n        diffs = smoothenSequenceDiffs(slice1, slice2, diffs);\n        diffs = removeRandomMatches(slice1, slice2, diffs);\n        const result = diffs.map((d) => new RangeMapping(slice1.translateRange(d.seq1Range), slice2.translateRange(d.seq2Range)));\n        // Assert: result applied on original should be the same as diff applied to original\n        return {\n            mappings: result,\n            hitTimeout: diffResult.hitTimeout,\n        };\n    }\n}\nfunction coverFullWords(sequence1, sequence2, sequenceDiffs) {\n    const additional = [];\n    let lastModifiedWord = undefined;\n    function maybePushWordToAdditional() {\n        if (!lastModifiedWord) {\n            return;\n        }\n        const originalLength1 = lastModifiedWord.s1Range.length - lastModifiedWord.deleted;\n        const originalLength2 = lastModifiedWord.s2Range.length - lastModifiedWord.added;\n        if (originalLength1 !== originalLength2) {\n            // TODO figure out why this happens\n        }\n        if (Math.max(lastModifiedWord.deleted, lastModifiedWord.added) + (lastModifiedWord.count - 1) > originalLength1) {\n            additional.push(new SequenceDiff(lastModifiedWord.s1Range, lastModifiedWord.s2Range));\n        }\n        lastModifiedWord = undefined;\n    }\n    for (const s of sequenceDiffs) {\n        function processWord(s1Range, s2Range) {\n            var _a, _b, _c, _d;\n            if (!lastModifiedWord || !lastModifiedWord.s1Range.containsRange(s1Range) || !lastModifiedWord.s2Range.containsRange(s2Range)) {\n                if (lastModifiedWord && !(lastModifiedWord.s1Range.endExclusive < s1Range.start && lastModifiedWord.s2Range.endExclusive < s2Range.start)) {\n                    const s1Added = OffsetRange.tryCreate(lastModifiedWord.s1Range.endExclusive, s1Range.start);\n                    const s2Added = OffsetRange.tryCreate(lastModifiedWord.s2Range.endExclusive, s2Range.start);\n                    lastModifiedWord.deleted += (_a = s1Added === null || s1Added === void 0 ? void 0 : s1Added.length) !== null && _a !== void 0 ? _a : 0;\n                    lastModifiedWord.added += (_b = s2Added === null || s2Added === void 0 ? void 0 : s2Added.length) !== null && _b !== void 0 ? _b : 0;\n                    lastModifiedWord.s1Range = lastModifiedWord.s1Range.join(s1Range);\n                    lastModifiedWord.s2Range = lastModifiedWord.s2Range.join(s2Range);\n                }\n                else {\n                    maybePushWordToAdditional();\n                    lastModifiedWord = { added: 0, deleted: 0, count: 0, s1Range: s1Range, s2Range: s2Range };\n                }\n            }\n            const changedS1 = s1Range.intersect(s.seq1Range);\n            const changedS2 = s2Range.intersect(s.seq2Range);\n            lastModifiedWord.count++;\n            lastModifiedWord.deleted += (_c = changedS1 === null || changedS1 === void 0 ? void 0 : changedS1.length) !== null && _c !== void 0 ? _c : 0;\n            lastModifiedWord.added += (_d = changedS2 === null || changedS2 === void 0 ? void 0 : changedS2.length) !== null && _d !== void 0 ? _d : 0;\n        }\n        const w1Before = sequence1.findWordContaining(s.seq1Range.start - 1);\n        const w2Before = sequence2.findWordContaining(s.seq2Range.start - 1);\n        const w1After = sequence1.findWordContaining(s.seq1Range.endExclusive);\n        const w2After = sequence2.findWordContaining(s.seq2Range.endExclusive);\n        if (w1Before && w1After && w2Before && w2After && w1Before.equals(w1After) && w2Before.equals(w2After)) {\n            processWord(w1Before, w2Before);\n        }\n        else {\n            if (w1Before && w2Before) {\n                processWord(w1Before, w2Before);\n            }\n            if (w1After && w2After) {\n                processWord(w1After, w2After);\n            }\n        }\n    }\n    maybePushWordToAdditional();\n    const merged = mergeSequenceDiffs(sequenceDiffs, additional);\n    return merged;\n}\nfunction mergeSequenceDiffs(sequenceDiffs1, sequenceDiffs2) {\n    const result = [];\n    while (sequenceDiffs1.length > 0 || sequenceDiffs2.length > 0) {\n        const sd1 = sequenceDiffs1[0];\n        const sd2 = sequenceDiffs2[0];\n        let next;\n        if (sd1 && (!sd2 || sd1.seq1Range.start < sd2.seq1Range.start)) {\n            next = sequenceDiffs1.shift();\n        }\n        else {\n            next = sequenceDiffs2.shift();\n        }\n        if (result.length > 0 && result[result.length - 1].seq1Range.endExclusive >= next.seq1Range.start) {\n            result[result.length - 1] = result[result.length - 1].join(next);\n        }\n        else {\n            result.push(next);\n        }\n    }\n    return result;\n}\nexport function lineRangeMappingFromRangeMappings(alignments, originalLines, modifiedLines, dontAssertStartLine = false) {\n    const changes = [];\n    for (const g of group(alignments.map(a => getLineRangeMapping(a, originalLines, modifiedLines)), (a1, a2) => a1.originalRange.overlapOrTouch(a2.originalRange)\n        || a1.modifiedRange.overlapOrTouch(a2.modifiedRange))) {\n        const first = g[0];\n        const last = g[g.length - 1];\n        changes.push(new LineRangeMapping(first.originalRange.join(last.originalRange), first.modifiedRange.join(last.modifiedRange), g.map(a => a.innerChanges[0])));\n    }\n    assertFn(() => {\n        if (!dontAssertStartLine) {\n            if (changes.length > 0 && changes[0].originalRange.startLineNumber !== changes[0].modifiedRange.startLineNumber) {\n                return false;\n            }\n        }\n        return checkAdjacentItems(changes, (m1, m2) => m2.originalRange.startLineNumber - m1.originalRange.endLineNumberExclusive === m2.modifiedRange.startLineNumber - m1.modifiedRange.endLineNumberExclusive &&\n            // There has to be an unchanged line in between (otherwise both diffs should have been joined)\n            m1.originalRange.endLineNumberExclusive < m2.originalRange.startLineNumber &&\n            m1.modifiedRange.endLineNumberExclusive < m2.modifiedRange.startLineNumber);\n    });\n    return changes;\n}\nexport function getLineRangeMapping(rangeMapping, originalLines, modifiedLines) {\n    let lineStartDelta = 0;\n    let lineEndDelta = 0;\n    // rangeMapping describes the edit that replaces `rangeMapping.originalRange` with `newText := getText(modifiedLines, rangeMapping.modifiedRange)`.\n    // original: ]xxx \\n <- this line is not modified\n    // modified: ]xx  \\n\n    if (rangeMapping.modifiedRange.endColumn === 1 && rangeMapping.originalRange.endColumn === 1\n        && rangeMapping.originalRange.startLineNumber + lineStartDelta <= rangeMapping.originalRange.endLineNumber\n        && rangeMapping.modifiedRange.startLineNumber + lineStartDelta <= rangeMapping.modifiedRange.endLineNumber) {\n        // We can only do this if the range is not empty yet\n        lineEndDelta = -1;\n    }\n    // original: xxx[ \\n <- this line is not modified\n    // modified: xxx[ \\n\n    if (rangeMapping.modifiedRange.startColumn - 1 >= modifiedLines[rangeMapping.modifiedRange.startLineNumber - 1].length\n        && rangeMapping.originalRange.startColumn - 1 >= originalLines[rangeMapping.originalRange.startLineNumber - 1].length\n        && rangeMapping.originalRange.startLineNumber <= rangeMapping.originalRange.endLineNumber + lineEndDelta\n        && rangeMapping.modifiedRange.startLineNumber <= rangeMapping.modifiedRange.endLineNumber + lineEndDelta) {\n        // We can only do this if the range is not empty yet\n        lineStartDelta = 1;\n    }\n    const originalLineRange = new LineRange(rangeMapping.originalRange.startLineNumber + lineStartDelta, rangeMapping.originalRange.endLineNumber + 1 + lineEndDelta);\n    const modifiedLineRange = new LineRange(rangeMapping.modifiedRange.startLineNumber + lineStartDelta, rangeMapping.modifiedRange.endLineNumber + 1 + lineEndDelta);\n    return new LineRangeMapping(originalLineRange, modifiedLineRange, [rangeMapping]);\n}\nfunction* group(items, shouldBeGrouped) {\n    let currentGroup;\n    let last;\n    for (const item of items) {\n        if (last !== undefined && shouldBeGrouped(last, item)) {\n            currentGroup.push(item);\n        }\n        else {\n            if (currentGroup) {\n                yield currentGroup;\n            }\n            currentGroup = [item];\n        }\n        last = item;\n    }\n    if (currentGroup) {\n        yield currentGroup;\n    }\n}\nexport class LineSequence {\n    constructor(trimmedHash, lines) {\n        this.trimmedHash = trimmedHash;\n        this.lines = lines;\n    }\n    getElement(offset) {\n        return this.trimmedHash[offset];\n    }\n    get length() {\n        return this.trimmedHash.length;\n    }\n    getBoundaryScore(length) {\n        const indentationBefore = length === 0 ? 0 : getIndentation(this.lines[length - 1]);\n        const indentationAfter = length === this.lines.length ? 0 : getIndentation(this.lines[length]);\n        return 1000 - (indentationBefore + indentationAfter);\n    }\n}\nfunction getIndentation(str) {\n    let i = 0;\n    while (i < str.length && (str.charCodeAt(i) === 32 /* CharCode.Space */ || str.charCodeAt(i) === 9 /* CharCode.Tab */)) {\n        i++;\n    }\n    return i;\n}\nexport class LinesSliceCharSequence {\n    constructor(lines, lineRange, considerWhitespaceChanges) {\n        // This slice has to have lineRange.length many \\n! (otherwise diffing against an empty slice will be problematic)\n        // (Unless it covers the entire document, in that case the other slice also has to cover the entire document ands it's okay)\n        this.lines = lines;\n        this.considerWhitespaceChanges = considerWhitespaceChanges;\n        this.elements = [];\n        this.firstCharOffsetByLineMinusOne = [];\n        // To account for trimming\n        this.offsetByLine = [];\n        // If the slice covers the end, but does not start at the beginning, we include just the \\n of the previous line.\n        let trimFirstLineFully = false;\n        if (lineRange.start > 0 && lineRange.endExclusive >= lines.length) {\n            lineRange = new OffsetRange(lineRange.start - 1, lineRange.endExclusive);\n            trimFirstLineFully = true;\n        }\n        this.lineRange = lineRange;\n        for (let i = this.lineRange.start; i < this.lineRange.endExclusive; i++) {\n            let line = lines[i];\n            let offset = 0;\n            if (trimFirstLineFully) {\n                offset = line.length;\n                line = '';\n                trimFirstLineFully = false;\n            }\n            else if (!considerWhitespaceChanges) {\n                const trimmedStartLine = line.trimStart();\n                offset = line.length - trimmedStartLine.length;\n                line = trimmedStartLine.trimEnd();\n            }\n            this.offsetByLine.push(offset);\n            for (let i = 0; i < line.length; i++) {\n                this.elements.push(line.charCodeAt(i));\n            }\n            // Don't add an \\n that does not exist in the document.\n            if (i < lines.length - 1) {\n                this.elements.push('\\n'.charCodeAt(0));\n                this.firstCharOffsetByLineMinusOne[i - this.lineRange.start] = this.elements.length;\n            }\n        }\n        // To account for the last line\n        this.offsetByLine.push(0);\n    }\n    toString() {\n        return `Slice: \"${this.text}\"`;\n    }\n    get text() {\n        return this.getText(new OffsetRange(0, this.length));\n    }\n    getText(range) {\n        return this.elements.slice(range.start, range.endExclusive).map(e => String.fromCharCode(e)).join('');\n    }\n    getElement(offset) {\n        return this.elements[offset];\n    }\n    get length() {\n        return this.elements.length;\n    }\n    getBoundaryScore(length) {\n        //   a   b   c   ,           d   e   f\n        // 11  0   0   12  15  6   13  0   0   11\n        const prevCategory = getCategory(length > 0 ? this.elements[length - 1] : -1);\n        const nextCategory = getCategory(length < this.elements.length ? this.elements[length] : -1);\n        if (prevCategory === 6 /* CharBoundaryCategory.LineBreakCR */ && nextCategory === 7 /* CharBoundaryCategory.LineBreakLF */) {\n            // don't break between \\r and \\n\n            return 0;\n        }\n        let score = 0;\n        if (prevCategory !== nextCategory) {\n            score += 10;\n            if (nextCategory === 1 /* CharBoundaryCategory.WordUpper */) {\n                score += 1;\n            }\n        }\n        score += getCategoryBoundaryScore(prevCategory);\n        score += getCategoryBoundaryScore(nextCategory);\n        return score;\n    }\n    translateOffset(offset) {\n        // find smallest i, so that lineBreakOffsets[i] <= offset using binary search\n        if (this.lineRange.isEmpty) {\n            return new Position(this.lineRange.start + 1, 1);\n        }\n        let i = 0;\n        let j = this.firstCharOffsetByLineMinusOne.length;\n        while (i < j) {\n            const k = Math.floor((i + j) / 2);\n            if (this.firstCharOffsetByLineMinusOne[k] > offset) {\n                j = k;\n            }\n            else {\n                i = k + 1;\n            }\n        }\n        const offsetOfFirstCharInLine = i === 0 ? 0 : this.firstCharOffsetByLineMinusOne[i - 1];\n        return new Position(this.lineRange.start + i + 1, offset - offsetOfFirstCharInLine + 1 + this.offsetByLine[i]);\n    }\n    translateRange(range) {\n        return Range.fromPositions(this.translateOffset(range.start), this.translateOffset(range.endExclusive));\n    }\n    /**\n     * Finds the word that contains the character at the given offset\n     */\n    findWordContaining(offset) {\n        if (offset < 0 || offset >= this.elements.length) {\n            return undefined;\n        }\n        if (!isWordChar(this.elements[offset])) {\n            return undefined;\n        }\n        // find start\n        let start = offset;\n        while (start > 0 && isWordChar(this.elements[start - 1])) {\n            start--;\n        }\n        // find end\n        let end = offset;\n        while (end < this.elements.length && isWordChar(this.elements[end])) {\n            end++;\n        }\n        return new OffsetRange(start, end);\n    }\n    countLinesIn(range) {\n        return this.translateOffset(range.endExclusive).lineNumber - this.translateOffset(range.start).lineNumber;\n    }\n}\nfunction isWordChar(charCode) {\n    return charCode >= 97 /* CharCode.a */ && charCode <= 122 /* CharCode.z */\n        || charCode >= 65 /* CharCode.A */ && charCode <= 90 /* CharCode.Z */\n        || charCode >= 48 /* CharCode.Digit0 */ && charCode <= 57 /* CharCode.Digit9 */;\n}\nconst score = {\n    [0 /* CharBoundaryCategory.WordLower */]: 0,\n    [1 /* CharBoundaryCategory.WordUpper */]: 0,\n    [2 /* CharBoundaryCategory.WordNumber */]: 0,\n    [3 /* CharBoundaryCategory.End */]: 10,\n    [4 /* CharBoundaryCategory.Other */]: 2,\n    [5 /* CharBoundaryCategory.Space */]: 3,\n    [6 /* CharBoundaryCategory.LineBreakCR */]: 10,\n    [7 /* CharBoundaryCategory.LineBreakLF */]: 10,\n};\nfunction getCategoryBoundaryScore(category) {\n    return score[category];\n}\nfunction getCategory(charCode) {\n    if (charCode === 10 /* CharCode.LineFeed */) {\n        return 7 /* CharBoundaryCategory.LineBreakLF */;\n    }\n    else if (charCode === 13 /* CharCode.CarriageReturn */) {\n        return 6 /* CharBoundaryCategory.LineBreakCR */;\n    }\n    else if (isSpace(charCode)) {\n        return 5 /* CharBoundaryCategory.Space */;\n    }\n    else if (charCode >= 97 /* CharCode.a */ && charCode <= 122 /* CharCode.z */) {\n        return 0 /* CharBoundaryCategory.WordLower */;\n    }\n    else if (charCode >= 65 /* CharCode.A */ && charCode <= 90 /* CharCode.Z */) {\n        return 1 /* CharBoundaryCategory.WordUpper */;\n    }\n    else if (charCode >= 48 /* CharCode.Digit0 */ && charCode <= 57 /* CharCode.Digit9 */) {\n        return 2 /* CharBoundaryCategory.WordNumber */;\n    }\n    else if (charCode === -1) {\n        return 3 /* CharBoundaryCategory.End */;\n    }\n    else {\n        return 4 /* CharBoundaryCategory.Other */;\n    }\n}\nfunction isSpace(charCode) {\n    return charCode === 32 /* CharCode.Space */ || charCode === 9 /* CharCode.Tab */;\n}\nconst chrKeys = new Map();\nfunction getKey(chr) {\n    let key = chrKeys.get(chr);\n    if (key === undefined) {\n        key = chrKeys.size;\n        chrKeys.set(chr, key);\n    }\n    return key;\n}\nclass LineRangeFragment {\n    constructor(range, lines) {\n        this.range = range;\n        this.lines = lines;\n        this.histogram = [];\n        let counter = 0;\n        for (let i = range.startLineNumber - 1; i < range.endLineNumberExclusive - 1; i++) {\n            const line = lines[i];\n            for (let j = 0; j < line.length; j++) {\n                counter++;\n                const chr = line[j];\n                const key = getKey(chr);\n                this.histogram[key] = (this.histogram[key] || 0) + 1;\n            }\n            counter++;\n            const key = getKey('\\n');\n            this.histogram[key] = (this.histogram[key] || 0) + 1;\n        }\n        this.totalCount = counter;\n    }\n    computeSimilarity(other) {\n        var _a, _b;\n        let sumDifferences = 0;\n        const maxLength = Math.max(this.histogram.length, other.histogram.length);\n        for (let i = 0; i < maxLength; i++) {\n            sumDifferences += Math.abs(((_a = this.histogram[i]) !== null && _a !== void 0 ? _a : 0) - ((_b = other.histogram[i]) !== null && _b !== void 0 ? _b : 0));\n        }\n        return 1 - (sumDifferences / (this.totalCount + other.totalCount));\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport * as zrUtil from 'zrender/lib/core/util.js';\nimport * as textContain from 'zrender/lib/contain/text.js';\nimport { makeInner } from '../util/model.js';\nimport { makeLabelFormatter, getOptionCategoryInterval, shouldShowAllLabels } from './axisHelper.js';\nvar modelInner = makeInner();\nvar axisInner = makeInner();\nexport var AxisTickLabelComputingKind = {\n  estimate: 1,\n  determine: 2\n};\nexport function createAxisLabelsComputingContext(kind) {\n  return {\n    out: {\n      noPxChangeTryDetermine: []\n    },\n    kind: kind\n  };\n}\nfunction tickValuesToNumbers(axis, values) {\n  var nums = zrUtil.map(values, function (val) {\n    return axis.scale.parse(val);\n  });\n  if (axis.type === 'time' && nums.length > 0) {\n    // Time axis needs duplicate first/last tick (see TimeScale.getTicks())\n    // The first and last tick/label don't get drawn\n    nums.sort();\n    nums.unshift(nums[0]);\n    nums.push(nums[nums.length - 1]);\n  }\n  return nums;\n}\nexport function createAxisLabels(axis, ctx) {\n  var custom = axis.getLabelModel().get('customValues');\n  if (custom) {\n    var labelFormatter_1 = makeLabelFormatter(axis);\n    var extent_1 = axis.scale.getExtent();\n    var tickNumbers = tickValuesToNumbers(axis, custom);\n    var ticks = zrUtil.filter(tickNumbers, function (val) {\n      return val >= extent_1[0] && val <= extent_1[1];\n    });\n    return {\n      labels: zrUtil.map(ticks, function (numval) {\n        var tick = {\n          value: numval\n        };\n        return {\n          formattedLabel: labelFormatter_1(tick),\n          rawLabel: axis.scale.getLabel(tick),\n          tickValue: numval,\n          time: undefined,\n          \"break\": undefined\n        };\n      })\n    };\n  }\n  // Only ordinal scale support tick interval\n  return axis.type === 'category' ? makeCategoryLabels(axis, ctx) : makeRealNumberLabels(axis);\n}\n/**\n * @param tickModel For example, can be axisTick, splitLine, splitArea.\n */\nexport function createAxisTicks(axis, tickModel, opt) {\n  var custom = axis.getTickModel().get('customValues');\n  if (custom) {\n    var extent_2 = axis.scale.getExtent();\n    var tickNumbers = tickValuesToNumbers(axis, custom);\n    return {\n      ticks: zrUtil.filter(tickNumbers, function (val) {\n        return val >= extent_2[0] && val <= extent_2[1];\n      })\n    };\n  }\n  // Only ordinal scale support tick interval\n  return axis.type === 'category' ? makeCategoryTicks(axis, tickModel) : {\n    ticks: zrUtil.map(axis.scale.getTicks(opt), function (tick) {\n      return tick.value;\n    })\n  };\n}\nfunction makeCategoryLabels(axis, ctx) {\n  var labelModel = axis.getLabelModel();\n  var result = makeCategoryLabelsActually(axis, labelModel, ctx);\n  return !labelModel.get('show') || axis.scale.isBlank() ? {\n    labels: []\n  } : result;\n}\nfunction makeCategoryLabelsActually(axis, labelModel, ctx) {\n  var labelsCache = ensureCategoryLabelCache(axis);\n  var optionLabelInterval = getOptionCategoryInterval(labelModel);\n  var isEstimate = ctx.kind === AxisTickLabelComputingKind.estimate;\n  // In AxisTickLabelComputingKind.estimate, the result likely varies during a single\n  // pass of ec main process,due to the change of axisExtent, and will not be shared with\n  // splitLine. Therefore no cache is used.\n  if (!isEstimate) {\n    // PENDING: check necessary?\n    var result_1 = axisCacheGet(labelsCache, optionLabelInterval);\n    if (result_1) {\n      return result_1;\n    }\n  }\n  var labels;\n  var numericLabelInterval;\n  if (zrUtil.isFunction(optionLabelInterval)) {\n    labels = makeLabelsByCustomizedCategoryInterval(axis, optionLabelInterval);\n  } else {\n    numericLabelInterval = optionLabelInterval === 'auto' ? makeAutoCategoryInterval(axis, ctx) : optionLabelInterval;\n    labels = makeLabelsByNumericCategoryInterval(axis, numericLabelInterval);\n  }\n  var result = {\n    labels: labels,\n    labelCategoryInterval: numericLabelInterval\n  };\n  if (!isEstimate) {\n    axisCacheSet(labelsCache, optionLabelInterval, result);\n  } else {\n    ctx.out.noPxChangeTryDetermine.push(function () {\n      axisCacheSet(labelsCache, optionLabelInterval, result);\n      return true;\n    });\n  }\n  return result;\n}\nfunction makeCategoryTicks(axis, tickModel) {\n  var ticksCache = ensureCategoryTickCache(axis);\n  var optionTickInterval = getOptionCategoryInterval(tickModel);\n  var result = axisCacheGet(ticksCache, optionTickInterval);\n  if (result) {\n    return result;\n  }\n  var ticks;\n  var tickCategoryInterval;\n  // Optimize for the case that large category data and no label displayed,\n  // we should not return all ticks.\n  if (!tickModel.get('show') || axis.scale.isBlank()) {\n    ticks = [];\n  }\n  if (zrUtil.isFunction(optionTickInterval)) {\n    ticks = makeLabelsByCustomizedCategoryInterval(axis, optionTickInterval, true);\n  }\n  // Always use label interval by default despite label show. Consider this\n  // scenario, Use multiple grid with the xAxis sync, and only one xAxis shows\n  // labels. `splitLine` and `axisTick` should be consistent in this case.\n  else if (optionTickInterval === 'auto') {\n    var labelsResult = makeCategoryLabelsActually(axis, axis.getLabelModel(), createAxisLabelsComputingContext(AxisTickLabelComputingKind.determine));\n    tickCategoryInterval = labelsResult.labelCategoryInterval;\n    ticks = zrUtil.map(labelsResult.labels, function (labelItem) {\n      return labelItem.tickValue;\n    });\n  } else {\n    tickCategoryInterval = optionTickInterval;\n    ticks = makeLabelsByNumericCategoryInterval(axis, tickCategoryInterval, true);\n  }\n  // Cache to avoid calling interval function repeatedly.\n  return axisCacheSet(ticksCache, optionTickInterval, {\n    ticks: ticks,\n    tickCategoryInterval: tickCategoryInterval\n  });\n}\nfunction makeRealNumberLabels(axis) {\n  var ticks = axis.scale.getTicks();\n  var labelFormatter = makeLabelFormatter(axis);\n  return {\n    labels: zrUtil.map(ticks, function (tick, idx) {\n      return {\n        formattedLabel: labelFormatter(tick, idx),\n        rawLabel: axis.scale.getLabel(tick),\n        tickValue: tick.value,\n        time: tick.time,\n        \"break\": tick[\"break\"]\n      };\n    })\n  };\n}\n// Large category data calculation is performance sensitive, and ticks and label probably will\n// be fetched multiple times (e.g. shared by splitLine and axisTick). So we cache the result.\n// axis is created each time during a ec process, so we do not need to clear cache.\nvar ensureCategoryTickCache = initAxisCacheMethod('axisTick');\nvar ensureCategoryLabelCache = initAxisCacheMethod('axisLabel');\n/**\n * PENDING: refactor to JS Map? Because key can be a function or more complicated object, and\n * cache size always is small, and currently no JS Map object key polyfill, we use a simple\n * array cache instead of plain object hash.\n */\nfunction initAxisCacheMethod(prop) {\n  return function ensureCache(axis) {\n    return axisInner(axis)[prop] || (axisInner(axis)[prop] = {\n      list: []\n    });\n  };\n}\nfunction axisCacheGet(cache, key) {\n  for (var i = 0; i < cache.list.length; i++) {\n    if (cache.list[i].key === key) {\n      return cache.list[i].value;\n    }\n  }\n}\nfunction axisCacheSet(cache, key, value) {\n  cache.list.push({\n    key: key,\n    value: value\n  });\n  return value;\n}\nfunction makeAutoCategoryInterval(axis, ctx) {\n  if (ctx.kind === AxisTickLabelComputingKind.estimate) {\n    // Currently axisTick is not involved in estimate kind, and the result likely varies during a\n    // single pass of ec main process, due to the change of axisExtent. Therefore no cache is used.\n    var result_2 = axis.calculateCategoryInterval(ctx);\n    ctx.out.noPxChangeTryDetermine.push(function () {\n      axisInner(axis).autoInterval = result_2;\n      return true;\n    });\n    return result_2;\n  }\n  // Both tick and label uses this result, cacah it to avoid recompute.\n  var result = axisInner(axis).autoInterval;\n  return result != null ? result : axisInner(axis).autoInterval = axis.calculateCategoryInterval(ctx);\n}\n/**\n * Calculate interval for category axis ticks and labels.\n * Use a stretegy to try to avoid overlapping.\n * To get precise result, at least one of `getRotate` and `isHorizontal`\n * should be implemented in axis.\n */\nexport function calculateCategoryInterval(axis, ctx) {\n  var kind = ctx.kind;\n  var params = fetchAutoCategoryIntervalCalculationParams(axis);\n  var labelFormatter = makeLabelFormatter(axis);\n  var rotation = (params.axisRotate - params.labelRotate) / 180 * Math.PI;\n  var ordinalScale = axis.scale;\n  var ordinalExtent = ordinalScale.getExtent();\n  // Providing this method is for optimization:\n  // avoid generating a long array by `getTicks`\n  // in large category data case.\n  var tickCount = ordinalScale.count();\n  if (ordinalExtent[1] - ordinalExtent[0] < 1) {\n    return 0;\n  }\n  var step = 1;\n  // Simple optimization. Arbitrary value.\n  var maxCount = 40;\n  if (tickCount > maxCount) {\n    step = Math.max(1, Math.floor(tickCount / maxCount));\n  }\n  var tickValue = ordinalExtent[0];\n  var unitSpan = axis.dataToCoord(tickValue + 1) - axis.dataToCoord(tickValue);\n  var unitW = Math.abs(unitSpan * Math.cos(rotation));\n  var unitH = Math.abs(unitSpan * Math.sin(rotation));\n  var maxW = 0;\n  var maxH = 0;\n  // Caution: Performance sensitive for large category data.\n  // Consider dataZoom, we should make appropriate step to avoid O(n) loop.\n  for (; tickValue <= ordinalExtent[1]; tickValue += step) {\n    var width = 0;\n    var height = 0;\n    // Not precise, do not consider align and vertical align\n    // and each distance from axis line yet.\n    var rect = textContain.getBoundingRect(labelFormatter({\n      value: tickValue\n    }), params.font, 'center', 'top');\n    // Magic number\n    width = rect.width * 1.3;\n    height = rect.height * 1.3;\n    // Min size, void long loop.\n    maxW = Math.max(maxW, width, 7);\n    maxH = Math.max(maxH, height, 7);\n  }\n  var dw = maxW / unitW;\n  var dh = maxH / unitH;\n  // 0/0 is NaN, 1/0 is Infinity.\n  isNaN(dw) && (dw = Infinity);\n  isNaN(dh) && (dh = Infinity);\n  var interval = Math.max(0, Math.floor(Math.min(dw, dh)));\n  if (kind === AxisTickLabelComputingKind.estimate) {\n    // In estimate kind, the inteval likely varies, thus do not erase the cache.\n    ctx.out.noPxChangeTryDetermine.push(zrUtil.bind(calculateCategoryIntervalTryDetermine, null, axis, interval, tickCount));\n    return interval;\n  }\n  var lastInterval = calculateCategoryIntervalDealCache(axis, interval, tickCount);\n  return lastInterval != null ? lastInterval : interval;\n}\nfunction calculateCategoryIntervalTryDetermine(axis, interval, tickCount) {\n  return calculateCategoryIntervalDealCache(axis, interval, tickCount) == null;\n}\n// Return the lastInterval if need to use it, otherwise return NullUndefined and save cache.\nfunction calculateCategoryIntervalDealCache(axis, interval, tickCount) {\n  var cache = modelInner(axis.model);\n  var axisExtent = axis.getExtent();\n  var lastAutoInterval = cache.lastAutoInterval;\n  var lastTickCount = cache.lastTickCount;\n  // Use cache to keep interval stable while moving zoom window,\n  // otherwise the calculated interval might jitter when the zoom\n  // window size is close to the interval-changing size.\n  // For example, if all of the axis labels are `a, b, c, d, e, f, g`.\n  // The jitter will cause that sometimes the displayed labels are\n  // `a, d, g` (interval: 2) sometimes `a, c, e`(interval: 1).\n  if (lastAutoInterval != null && lastTickCount != null && Math.abs(lastAutoInterval - interval) <= 1 && Math.abs(lastTickCount - tickCount) <= 1\n  // Always choose the bigger one, otherwise the critical\n  // point is not the same when zooming in or zooming out.\n  && lastAutoInterval > interval\n  // If the axis change is caused by chart resize, the cache should not\n  // be used. Otherwise some hidden labels might not be shown again.\n  && cache.axisExtent0 === axisExtent[0] && cache.axisExtent1 === axisExtent[1]) {\n    return lastAutoInterval;\n  }\n  // Only update cache if cache not used, otherwise the\n  // changing of interval is too insensitive.\n  else {\n    cache.lastTickCount = tickCount;\n    cache.lastAutoInterval = interval;\n    cache.axisExtent0 = axisExtent[0];\n    cache.axisExtent1 = axisExtent[1];\n  }\n}\nfunction fetchAutoCategoryIntervalCalculationParams(axis) {\n  var labelModel = axis.getLabelModel();\n  return {\n    axisRotate: axis.getRotate ? axis.getRotate() : axis.isHorizontal && !axis.isHorizontal() ? 90 : 0,\n    labelRotate: labelModel.get('rotate') || 0,\n    font: labelModel.getFont()\n  };\n}\nfunction makeLabelsByNumericCategoryInterval(axis, categoryInterval, onlyTick) {\n  var labelFormatter = makeLabelFormatter(axis);\n  var ordinalScale = axis.scale;\n  var ordinalExtent = ordinalScale.getExtent();\n  var labelModel = axis.getLabelModel();\n  var result = [];\n  // TODO: axisType: ordinalTime, pick the tick from each month/day/year/...\n  var step = Math.max((categoryInterval || 0) + 1, 1);\n  var startTick = ordinalExtent[0];\n  var tickCount = ordinalScale.count();\n  // Calculate start tick based on zero if possible to keep label consistent\n  // while zooming and moving while interval > 0. Otherwise the selection\n  // of displayable ticks and symbols probably keep changing.\n  // 3 is empirical value.\n  if (startTick !== 0 && step > 1 && tickCount / step > 2) {\n    startTick = Math.round(Math.ceil(startTick / step) * step);\n  }\n  // (1) Only add min max label here but leave overlap checking\n  // to render stage, which also ensure the returned list\n  // suitable for splitLine and splitArea rendering.\n  // (2) Scales except category always contain min max label so\n  // do not need to perform this process.\n  var showAllLabel = shouldShowAllLabels(axis);\n  var includeMinLabel = labelModel.get('showMinLabel') || showAllLabel;\n  var includeMaxLabel = labelModel.get('showMaxLabel') || showAllLabel;\n  if (includeMinLabel && startTick !== ordinalExtent[0]) {\n    addItem(ordinalExtent[0]);\n  }\n  // Optimize: avoid generating large array by `ordinalScale.getTicks()`.\n  var tickValue = startTick;\n  for (; tickValue <= ordinalExtent[1]; tickValue += step) {\n    addItem(tickValue);\n  }\n  if (includeMaxLabel && tickValue - step !== ordinalExtent[1]) {\n    addItem(ordinalExtent[1]);\n  }\n  function addItem(tickValue) {\n    var tickObj = {\n      value: tickValue\n    };\n    result.push(onlyTick ? tickValue : {\n      formattedLabel: labelFormatter(tickObj),\n      rawLabel: ordinalScale.getLabel(tickObj),\n      tickValue: tickValue,\n      time: undefined,\n      \"break\": undefined\n    });\n  }\n  return result;\n}\nfunction makeLabelsByCustomizedCategoryInterval(axis, categoryInterval, onlyTick) {\n  var ordinalScale = axis.scale;\n  var labelFormatter = makeLabelFormatter(axis);\n  var result = [];\n  zrUtil.each(ordinalScale.getTicks(), function (tick) {\n    var rawLabel = ordinalScale.getLabel(tick);\n    var tickValue = tick.value;\n    if (categoryInterval(tick.value, rawLabel)) {\n      result.push(onlyTick ? tickValue : {\n        formattedLabel: labelFormatter(tick),\n        rawLabel: rawLabel,\n        tickValue: tickValue,\n        time: undefined,\n        \"break\": undefined\n      });\n    }\n  });\n  return result;\n}","map":{"version":3,"names":["zrUtil","textContain","makeInner","makeLabelFormatter","getOptionCategoryInterval","shouldShowAllLabels","modelInner","axisInner","AxisTickLabelComputingKind","estimate","determine","createAxisLabelsComputingContext","kind","out","noPxChangeTryDetermine","tickValuesToNumbers","axis","values","nums","map","val","scale","parse","type","length","sort","unshift","push","createAxisLabels","ctx","custom","getLabelModel","get","labelFormatter_1","extent_1","getExtent","tickNumbers","ticks","filter","labels","numval","tick","value","formattedLabel","rawLabel","getLabel","tickValue","time","undefined","makeCategoryLabels","makeRealNumberLabels","createAxisTicks","tickModel","opt","getTickModel","extent_2","makeCategoryTicks","getTicks","labelModel","result","makeCategoryLabelsActually","isBlank","labelsCache","ensureCategoryLabelCache","optionLabelInterval","isEstimate","result_1","axisCacheGet","numericLabelInterval","isFunction","makeLabelsByCustomizedCategoryInterval","makeAutoCategoryInterval","makeLabelsByNumericCategoryInterval","labelCategoryInterval","axisCacheSet","ticksCache","ensureCategoryTickCache","optionTickInterval","tickCategoryInterval","labelsResult","labelItem","labelFormatter","idx","initAxisCacheMethod","prop","ensureCache","list","cache","key","i","result_2","calculateCategoryInterval","autoInterval","params","fetchAutoCategoryIntervalCalculationParams","rotation","axisRotate","labelRotate","Math","PI","ordinalScale","ordinalExtent","tickCount","count","step","maxCount","max","floor","unitSpan","dataToCoord","unitW","abs","cos","unitH","sin","maxW","maxH","width","height","rect","getBoundingRect","font","dw","dh","isNaN","Infinity","interval","min","bind","calculateCategoryIntervalTryDetermine","lastInterval","calculateCategoryIntervalDealCache","model","axisExtent","lastAutoInterval","lastTickCount","axisExtent0","axisExtent1","getRotate","isHorizontal","getFont","categoryInterval","onlyTick","startTick","round","ceil","showAllLabel","includeMinLabel","includeMaxLabel","addItem","tickObj","each"],"sources":["D:/code/java/program/oj/code/yuoj-frontend-master/node_modules/echarts/lib/coord/axisTickLabelBuilder.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport * as zrUtil from 'zrender/lib/core/util.js';\nimport * as textContain from 'zrender/lib/contain/text.js';\nimport { makeInner } from '../util/model.js';\nimport { makeLabelFormatter, getOptionCategoryInterval, shouldShowAllLabels } from './axisHelper.js';\nvar modelInner = makeInner();\nvar axisInner = makeInner();\nexport var AxisTickLabelComputingKind = {\n  estimate: 1,\n  determine: 2\n};\nexport function createAxisLabelsComputingContext(kind) {\n  return {\n    out: {\n      noPxChangeTryDetermine: []\n    },\n    kind: kind\n  };\n}\nfunction tickValuesToNumbers(axis, values) {\n  var nums = zrUtil.map(values, function (val) {\n    return axis.scale.parse(val);\n  });\n  if (axis.type === 'time' && nums.length > 0) {\n    // Time axis needs duplicate first/last tick (see TimeScale.getTicks())\n    // The first and last tick/label don't get drawn\n    nums.sort();\n    nums.unshift(nums[0]);\n    nums.push(nums[nums.length - 1]);\n  }\n  return nums;\n}\nexport function createAxisLabels(axis, ctx) {\n  var custom = axis.getLabelModel().get('customValues');\n  if (custom) {\n    var labelFormatter_1 = makeLabelFormatter(axis);\n    var extent_1 = axis.scale.getExtent();\n    var tickNumbers = tickValuesToNumbers(axis, custom);\n    var ticks = zrUtil.filter(tickNumbers, function (val) {\n      return val >= extent_1[0] && val <= extent_1[1];\n    });\n    return {\n      labels: zrUtil.map(ticks, function (numval) {\n        var tick = {\n          value: numval\n        };\n        return {\n          formattedLabel: labelFormatter_1(tick),\n          rawLabel: axis.scale.getLabel(tick),\n          tickValue: numval,\n          time: undefined,\n          \"break\": undefined\n        };\n      })\n    };\n  }\n  // Only ordinal scale support tick interval\n  return axis.type === 'category' ? makeCategoryLabels(axis, ctx) : makeRealNumberLabels(axis);\n}\n/**\n * @param tickModel For example, can be axisTick, splitLine, splitArea.\n */\nexport function createAxisTicks(axis, tickModel, opt) {\n  var custom = axis.getTickModel().get('customValues');\n  if (custom) {\n    var extent_2 = axis.scale.getExtent();\n    var tickNumbers = tickValuesToNumbers(axis, custom);\n    return {\n      ticks: zrUtil.filter(tickNumbers, function (val) {\n        return val >= extent_2[0] && val <= extent_2[1];\n      })\n    };\n  }\n  // Only ordinal scale support tick interval\n  return axis.type === 'category' ? makeCategoryTicks(axis, tickModel) : {\n    ticks: zrUtil.map(axis.scale.getTicks(opt), function (tick) {\n      return tick.value;\n    })\n  };\n}\nfunction makeCategoryLabels(axis, ctx) {\n  var labelModel = axis.getLabelModel();\n  var result = makeCategoryLabelsActually(axis, labelModel, ctx);\n  return !labelModel.get('show') || axis.scale.isBlank() ? {\n    labels: []\n  } : result;\n}\nfunction makeCategoryLabelsActually(axis, labelModel, ctx) {\n  var labelsCache = ensureCategoryLabelCache(axis);\n  var optionLabelInterval = getOptionCategoryInterval(labelModel);\n  var isEstimate = ctx.kind === AxisTickLabelComputingKind.estimate;\n  // In AxisTickLabelComputingKind.estimate, the result likely varies during a single\n  // pass of ec main process,due to the change of axisExtent, and will not be shared with\n  // splitLine. Therefore no cache is used.\n  if (!isEstimate) {\n    // PENDING: check necessary?\n    var result_1 = axisCacheGet(labelsCache, optionLabelInterval);\n    if (result_1) {\n      return result_1;\n    }\n  }\n  var labels;\n  var numericLabelInterval;\n  if (zrUtil.isFunction(optionLabelInterval)) {\n    labels = makeLabelsByCustomizedCategoryInterval(axis, optionLabelInterval);\n  } else {\n    numericLabelInterval = optionLabelInterval === 'auto' ? makeAutoCategoryInterval(axis, ctx) : optionLabelInterval;\n    labels = makeLabelsByNumericCategoryInterval(axis, numericLabelInterval);\n  }\n  var result = {\n    labels: labels,\n    labelCategoryInterval: numericLabelInterval\n  };\n  if (!isEstimate) {\n    axisCacheSet(labelsCache, optionLabelInterval, result);\n  } else {\n    ctx.out.noPxChangeTryDetermine.push(function () {\n      axisCacheSet(labelsCache, optionLabelInterval, result);\n      return true;\n    });\n  }\n  return result;\n}\nfunction makeCategoryTicks(axis, tickModel) {\n  var ticksCache = ensureCategoryTickCache(axis);\n  var optionTickInterval = getOptionCategoryInterval(tickModel);\n  var result = axisCacheGet(ticksCache, optionTickInterval);\n  if (result) {\n    return result;\n  }\n  var ticks;\n  var tickCategoryInterval;\n  // Optimize for the case that large category data and no label displayed,\n  // we should not return all ticks.\n  if (!tickModel.get('show') || axis.scale.isBlank()) {\n    ticks = [];\n  }\n  if (zrUtil.isFunction(optionTickInterval)) {\n    ticks = makeLabelsByCustomizedCategoryInterval(axis, optionTickInterval, true);\n  }\n  // Always use label interval by default despite label show. Consider this\n  // scenario, Use multiple grid with the xAxis sync, and only one xAxis shows\n  // labels. `splitLine` and `axisTick` should be consistent in this case.\n  else if (optionTickInterval === 'auto') {\n    var labelsResult = makeCategoryLabelsActually(axis, axis.getLabelModel(), createAxisLabelsComputingContext(AxisTickLabelComputingKind.determine));\n    tickCategoryInterval = labelsResult.labelCategoryInterval;\n    ticks = zrUtil.map(labelsResult.labels, function (labelItem) {\n      return labelItem.tickValue;\n    });\n  } else {\n    tickCategoryInterval = optionTickInterval;\n    ticks = makeLabelsByNumericCategoryInterval(axis, tickCategoryInterval, true);\n  }\n  // Cache to avoid calling interval function repeatedly.\n  return axisCacheSet(ticksCache, optionTickInterval, {\n    ticks: ticks,\n    tickCategoryInterval: tickCategoryInterval\n  });\n}\nfunction makeRealNumberLabels(axis) {\n  var ticks = axis.scale.getTicks();\n  var labelFormatter = makeLabelFormatter(axis);\n  return {\n    labels: zrUtil.map(ticks, function (tick, idx) {\n      return {\n        formattedLabel: labelFormatter(tick, idx),\n        rawLabel: axis.scale.getLabel(tick),\n        tickValue: tick.value,\n        time: tick.time,\n        \"break\": tick[\"break\"]\n      };\n    })\n  };\n}\n// Large category data calculation is performance sensitive, and ticks and label probably will\n// be fetched multiple times (e.g. shared by splitLine and axisTick). So we cache the result.\n// axis is created each time during a ec process, so we do not need to clear cache.\nvar ensureCategoryTickCache = initAxisCacheMethod('axisTick');\nvar ensureCategoryLabelCache = initAxisCacheMethod('axisLabel');\n/**\n * PENDING: refactor to JS Map? Because key can be a function or more complicated object, and\n * cache size always is small, and currently no JS Map object key polyfill, we use a simple\n * array cache instead of plain object hash.\n */\nfunction initAxisCacheMethod(prop) {\n  return function ensureCache(axis) {\n    return axisInner(axis)[prop] || (axisInner(axis)[prop] = {\n      list: []\n    });\n  };\n}\nfunction axisCacheGet(cache, key) {\n  for (var i = 0; i < cache.list.length; i++) {\n    if (cache.list[i].key === key) {\n      return cache.list[i].value;\n    }\n  }\n}\nfunction axisCacheSet(cache, key, value) {\n  cache.list.push({\n    key: key,\n    value: value\n  });\n  return value;\n}\nfunction makeAutoCategoryInterval(axis, ctx) {\n  if (ctx.kind === AxisTickLabelComputingKind.estimate) {\n    // Currently axisTick is not involved in estimate kind, and the result likely varies during a\n    // single pass of ec main process, due to the change of axisExtent. Therefore no cache is used.\n    var result_2 = axis.calculateCategoryInterval(ctx);\n    ctx.out.noPxChangeTryDetermine.push(function () {\n      axisInner(axis).autoInterval = result_2;\n      return true;\n    });\n    return result_2;\n  }\n  // Both tick and label uses this result, cacah it to avoid recompute.\n  var result = axisInner(axis).autoInterval;\n  return result != null ? result : axisInner(axis).autoInterval = axis.calculateCategoryInterval(ctx);\n}\n/**\n * Calculate interval for category axis ticks and labels.\n * Use a stretegy to try to avoid overlapping.\n * To get precise result, at least one of `getRotate` and `isHorizontal`\n * should be implemented in axis.\n */\nexport function calculateCategoryInterval(axis, ctx) {\n  var kind = ctx.kind;\n  var params = fetchAutoCategoryIntervalCalculationParams(axis);\n  var labelFormatter = makeLabelFormatter(axis);\n  var rotation = (params.axisRotate - params.labelRotate) / 180 * Math.PI;\n  var ordinalScale = axis.scale;\n  var ordinalExtent = ordinalScale.getExtent();\n  // Providing this method is for optimization:\n  // avoid generating a long array by `getTicks`\n  // in large category data case.\n  var tickCount = ordinalScale.count();\n  if (ordinalExtent[1] - ordinalExtent[0] < 1) {\n    return 0;\n  }\n  var step = 1;\n  // Simple optimization. Arbitrary value.\n  var maxCount = 40;\n  if (tickCount > maxCount) {\n    step = Math.max(1, Math.floor(tickCount / maxCount));\n  }\n  var tickValue = ordinalExtent[0];\n  var unitSpan = axis.dataToCoord(tickValue + 1) - axis.dataToCoord(tickValue);\n  var unitW = Math.abs(unitSpan * Math.cos(rotation));\n  var unitH = Math.abs(unitSpan * Math.sin(rotation));\n  var maxW = 0;\n  var maxH = 0;\n  // Caution: Performance sensitive for large category data.\n  // Consider dataZoom, we should make appropriate step to avoid O(n) loop.\n  for (; tickValue <= ordinalExtent[1]; tickValue += step) {\n    var width = 0;\n    var height = 0;\n    // Not precise, do not consider align and vertical align\n    // and each distance from axis line yet.\n    var rect = textContain.getBoundingRect(labelFormatter({\n      value: tickValue\n    }), params.font, 'center', 'top');\n    // Magic number\n    width = rect.width * 1.3;\n    height = rect.height * 1.3;\n    // Min size, void long loop.\n    maxW = Math.max(maxW, width, 7);\n    maxH = Math.max(maxH, height, 7);\n  }\n  var dw = maxW / unitW;\n  var dh = maxH / unitH;\n  // 0/0 is NaN, 1/0 is Infinity.\n  isNaN(dw) && (dw = Infinity);\n  isNaN(dh) && (dh = Infinity);\n  var interval = Math.max(0, Math.floor(Math.min(dw, dh)));\n  if (kind === AxisTickLabelComputingKind.estimate) {\n    // In estimate kind, the inteval likely varies, thus do not erase the cache.\n    ctx.out.noPxChangeTryDetermine.push(zrUtil.bind(calculateCategoryIntervalTryDetermine, null, axis, interval, tickCount));\n    return interval;\n  }\n  var lastInterval = calculateCategoryIntervalDealCache(axis, interval, tickCount);\n  return lastInterval != null ? lastInterval : interval;\n}\nfunction calculateCategoryIntervalTryDetermine(axis, interval, tickCount) {\n  return calculateCategoryIntervalDealCache(axis, interval, tickCount) == null;\n}\n// Return the lastInterval if need to use it, otherwise return NullUndefined and save cache.\nfunction calculateCategoryIntervalDealCache(axis, interval, tickCount) {\n  var cache = modelInner(axis.model);\n  var axisExtent = axis.getExtent();\n  var lastAutoInterval = cache.lastAutoInterval;\n  var lastTickCount = cache.lastTickCount;\n  // Use cache to keep interval stable while moving zoom window,\n  // otherwise the calculated interval might jitter when the zoom\n  // window size is close to the interval-changing size.\n  // For example, if all of the axis labels are `a, b, c, d, e, f, g`.\n  // The jitter will cause that sometimes the displayed labels are\n  // `a, d, g` (interval: 2) sometimes `a, c, e`(interval: 1).\n  if (lastAutoInterval != null && lastTickCount != null && Math.abs(lastAutoInterval - interval) <= 1 && Math.abs(lastTickCount - tickCount) <= 1\n  // Always choose the bigger one, otherwise the critical\n  // point is not the same when zooming in or zooming out.\n  && lastAutoInterval > interval\n  // If the axis change is caused by chart resize, the cache should not\n  // be used. Otherwise some hidden labels might not be shown again.\n  && cache.axisExtent0 === axisExtent[0] && cache.axisExtent1 === axisExtent[1]) {\n    return lastAutoInterval;\n  }\n  // Only update cache if cache not used, otherwise the\n  // changing of interval is too insensitive.\n  else {\n    cache.lastTickCount = tickCount;\n    cache.lastAutoInterval = interval;\n    cache.axisExtent0 = axisExtent[0];\n    cache.axisExtent1 = axisExtent[1];\n  }\n}\nfunction fetchAutoCategoryIntervalCalculationParams(axis) {\n  var labelModel = axis.getLabelModel();\n  return {\n    axisRotate: axis.getRotate ? axis.getRotate() : axis.isHorizontal && !axis.isHorizontal() ? 90 : 0,\n    labelRotate: labelModel.get('rotate') || 0,\n    font: labelModel.getFont()\n  };\n}\nfunction makeLabelsByNumericCategoryInterval(axis, categoryInterval, onlyTick) {\n  var labelFormatter = makeLabelFormatter(axis);\n  var ordinalScale = axis.scale;\n  var ordinalExtent = ordinalScale.getExtent();\n  var labelModel = axis.getLabelModel();\n  var result = [];\n  // TODO: axisType: ordinalTime, pick the tick from each month/day/year/...\n  var step = Math.max((categoryInterval || 0) + 1, 1);\n  var startTick = ordinalExtent[0];\n  var tickCount = ordinalScale.count();\n  // Calculate start tick based on zero if possible to keep label consistent\n  // while zooming and moving while interval > 0. Otherwise the selection\n  // of displayable ticks and symbols probably keep changing.\n  // 3 is empirical value.\n  if (startTick !== 0 && step > 1 && tickCount / step > 2) {\n    startTick = Math.round(Math.ceil(startTick / step) * step);\n  }\n  // (1) Only add min max label here but leave overlap checking\n  // to render stage, which also ensure the returned list\n  // suitable for splitLine and splitArea rendering.\n  // (2) Scales except category always contain min max label so\n  // do not need to perform this process.\n  var showAllLabel = shouldShowAllLabels(axis);\n  var includeMinLabel = labelModel.get('showMinLabel') || showAllLabel;\n  var includeMaxLabel = labelModel.get('showMaxLabel') || showAllLabel;\n  if (includeMinLabel && startTick !== ordinalExtent[0]) {\n    addItem(ordinalExtent[0]);\n  }\n  // Optimize: avoid generating large array by `ordinalScale.getTicks()`.\n  var tickValue = startTick;\n  for (; tickValue <= ordinalExtent[1]; tickValue += step) {\n    addItem(tickValue);\n  }\n  if (includeMaxLabel && tickValue - step !== ordinalExtent[1]) {\n    addItem(ordinalExtent[1]);\n  }\n  function addItem(tickValue) {\n    var tickObj = {\n      value: tickValue\n    };\n    result.push(onlyTick ? tickValue : {\n      formattedLabel: labelFormatter(tickObj),\n      rawLabel: ordinalScale.getLabel(tickObj),\n      tickValue: tickValue,\n      time: undefined,\n      \"break\": undefined\n    });\n  }\n  return result;\n}\nfunction makeLabelsByCustomizedCategoryInterval(axis, categoryInterval, onlyTick) {\n  var ordinalScale = axis.scale;\n  var labelFormatter = makeLabelFormatter(axis);\n  var result = [];\n  zrUtil.each(ordinalScale.getTicks(), function (tick) {\n    var rawLabel = ordinalScale.getLabel(tick);\n    var tickValue = tick.value;\n    if (categoryInterval(tick.value, rawLabel)) {\n      result.push(onlyTick ? tickValue : {\n        formattedLabel: labelFormatter(tick),\n        rawLabel: rawLabel,\n        tickValue: tickValue,\n        time: undefined,\n        \"break\": undefined\n      });\n    }\n  });\n  return result;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
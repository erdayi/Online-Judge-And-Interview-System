{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { OffsetRange } from '../../core/offsetRange.js';\nimport { DiffAlgorithmResult, InfiniteTimeout, SequenceDiff } from './diffAlgorithm.js';\n/**\n * An O(ND) diff algorithm that has a quadratic space worst-case complexity.\n*/\nexport class MyersDiffAlgorithm {\n  compute(seq1, seq2, timeout = InfiniteTimeout.instance) {\n    // These are common special cases.\n    // The early return improves performance dramatically.\n    if (seq1.length === 0 || seq2.length === 0) {\n      return DiffAlgorithmResult.trivial(seq1, seq2);\n    }\n    function getXAfterSnake(x, y) {\n      while (x < seq1.length && y < seq2.length && seq1.getElement(x) === seq2.getElement(y)) {\n        x++;\n        y++;\n      }\n      return x;\n    }\n    let d = 0;\n    // V[k]: X value of longest d-line that ends in diagonal k.\n    // d-line: path from (0,0) to (x,y) that uses exactly d non-diagonals.\n    // diagonal k: Set of points (x,y) with x-y = k.\n    const V = new FastInt32Array();\n    V.set(0, getXAfterSnake(0, 0));\n    const paths = new FastArrayNegativeIndices();\n    paths.set(0, V.get(0) === 0 ? null : new SnakePath(null, 0, 0, V.get(0)));\n    let k = 0;\n    loop: while (true) {\n      d++;\n      if (!timeout.isValid()) {\n        return DiffAlgorithmResult.trivialTimedOut(seq1, seq2);\n      }\n      // The paper has `for (k = -d; k <= d; k += 2)`, but we can ignore diagonals that cannot influence the result.\n      const lowerBound = -Math.min(d, seq2.length + d % 2);\n      const upperBound = Math.min(d, seq1.length + d % 2);\n      for (k = lowerBound; k <= upperBound; k += 2) {\n        // We can use the X values of (d-1)-lines to compute X value of the longest d-lines.\n        const maxXofDLineTop = k === upperBound ? -1 : V.get(k + 1); // We take a vertical non-diagonal (add a symbol in seq1)\n        const maxXofDLineLeft = k === lowerBound ? -1 : V.get(k - 1) + 1; // We take a horizontal non-diagonal (+1 x) (delete a symbol in seq1)\n        const x = Math.min(Math.max(maxXofDLineTop, maxXofDLineLeft), seq1.length);\n        const y = x - k;\n        if (x > seq1.length || y > seq2.length) {\n          // This diagonal is irrelevant for the result.\n          // TODO: Don't pay the cost for this in the next iteration.\n          continue;\n        }\n        const newMaxX = getXAfterSnake(x, y);\n        V.set(k, newMaxX);\n        const lastPath = x === maxXofDLineTop ? paths.get(k + 1) : paths.get(k - 1);\n        paths.set(k, newMaxX !== x ? new SnakePath(lastPath, x, y, newMaxX - x) : lastPath);\n        if (V.get(k) === seq1.length && V.get(k) - k === seq2.length) {\n          break loop;\n        }\n      }\n    }\n    let path = paths.get(k);\n    const result = [];\n    let lastAligningPosS1 = seq1.length;\n    let lastAligningPosS2 = seq2.length;\n    while (true) {\n      const endX = path ? path.x + path.length : 0;\n      const endY = path ? path.y + path.length : 0;\n      if (endX !== lastAligningPosS1 || endY !== lastAligningPosS2) {\n        result.push(new SequenceDiff(new OffsetRange(endX, lastAligningPosS1), new OffsetRange(endY, lastAligningPosS2)));\n      }\n      if (!path) {\n        break;\n      }\n      lastAligningPosS1 = path.x;\n      lastAligningPosS2 = path.y;\n      path = path.prev;\n    }\n    result.reverse();\n    return new DiffAlgorithmResult(result, false);\n  }\n}\nclass SnakePath {\n  constructor(prev, x, y, length) {\n    this.prev = prev;\n    this.x = x;\n    this.y = y;\n    this.length = length;\n  }\n}\n/**\n * An array that supports fast negative indices.\n*/\nclass FastInt32Array {\n  constructor() {\n    this.positiveArr = new Int32Array(10);\n    this.negativeArr = new Int32Array(10);\n  }\n  get(idx) {\n    if (idx < 0) {\n      idx = -idx - 1;\n      return this.negativeArr[idx];\n    } else {\n      return this.positiveArr[idx];\n    }\n  }\n  set(idx, value) {\n    if (idx < 0) {\n      idx = -idx - 1;\n      if (idx >= this.negativeArr.length) {\n        const arr = this.negativeArr;\n        this.negativeArr = new Int32Array(arr.length * 2);\n        this.negativeArr.set(arr);\n      }\n      this.negativeArr[idx] = value;\n    } else {\n      if (idx >= this.positiveArr.length) {\n        const arr = this.positiveArr;\n        this.positiveArr = new Int32Array(arr.length * 2);\n        this.positiveArr.set(arr);\n      }\n      this.positiveArr[idx] = value;\n    }\n  }\n}\n/**\n * An array that supports fast negative indices.\n*/\nclass FastArrayNegativeIndices {\n  constructor() {\n    this.positiveArr = [];\n    this.negativeArr = [];\n  }\n  get(idx) {\n    if (idx < 0) {\n      idx = -idx - 1;\n      return this.negativeArr[idx];\n    } else {\n      return this.positiveArr[idx];\n    }\n  }\n  set(idx, value) {\n    if (idx < 0) {\n      idx = -idx - 1;\n      this.negativeArr[idx] = value;\n    } else {\n      this.positiveArr[idx] = value;\n    }\n  }\n}","map":{"version":3,"names":["OffsetRange","DiffAlgorithmResult","InfiniteTimeout","SequenceDiff","MyersDiffAlgorithm","compute","seq1","seq2","timeout","instance","length","trivial","getXAfterSnake","x","y","getElement","d","V","FastInt32Array","set","paths","FastArrayNegativeIndices","get","SnakePath","k","loop","isValid","trivialTimedOut","lowerBound","Math","min","upperBound","maxXofDLineTop","maxXofDLineLeft","max","newMaxX","lastPath","path","result","lastAligningPosS1","lastAligningPosS2","endX","endY","push","prev","reverse","constructor","positiveArr","Int32Array","negativeArr","idx","value","arr"],"sources":["D:/code/java/program/oj/code/yuoj-frontend-master/node_modules/monaco-editor/esm/vs/editor/common/diff/algorithms/myersDiffAlgorithm.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { OffsetRange } from '../../core/offsetRange.js';\nimport { DiffAlgorithmResult, InfiniteTimeout, SequenceDiff } from './diffAlgorithm.js';\n/**\n * An O(ND) diff algorithm that has a quadratic space worst-case complexity.\n*/\nexport class MyersDiffAlgorithm {\n    compute(seq1, seq2, timeout = InfiniteTimeout.instance) {\n        // These are common special cases.\n        // The early return improves performance dramatically.\n        if (seq1.length === 0 || seq2.length === 0) {\n            return DiffAlgorithmResult.trivial(seq1, seq2);\n        }\n        function getXAfterSnake(x, y) {\n            while (x < seq1.length && y < seq2.length && seq1.getElement(x) === seq2.getElement(y)) {\n                x++;\n                y++;\n            }\n            return x;\n        }\n        let d = 0;\n        // V[k]: X value of longest d-line that ends in diagonal k.\n        // d-line: path from (0,0) to (x,y) that uses exactly d non-diagonals.\n        // diagonal k: Set of points (x,y) with x-y = k.\n        const V = new FastInt32Array();\n        V.set(0, getXAfterSnake(0, 0));\n        const paths = new FastArrayNegativeIndices();\n        paths.set(0, V.get(0) === 0 ? null : new SnakePath(null, 0, 0, V.get(0)));\n        let k = 0;\n        loop: while (true) {\n            d++;\n            if (!timeout.isValid()) {\n                return DiffAlgorithmResult.trivialTimedOut(seq1, seq2);\n            }\n            // The paper has `for (k = -d; k <= d; k += 2)`, but we can ignore diagonals that cannot influence the result.\n            const lowerBound = -Math.min(d, seq2.length + (d % 2));\n            const upperBound = Math.min(d, seq1.length + (d % 2));\n            for (k = lowerBound; k <= upperBound; k += 2) {\n                // We can use the X values of (d-1)-lines to compute X value of the longest d-lines.\n                const maxXofDLineTop = k === upperBound ? -1 : V.get(k + 1); // We take a vertical non-diagonal (add a symbol in seq1)\n                const maxXofDLineLeft = k === lowerBound ? -1 : V.get(k - 1) + 1; // We take a horizontal non-diagonal (+1 x) (delete a symbol in seq1)\n                const x = Math.min(Math.max(maxXofDLineTop, maxXofDLineLeft), seq1.length);\n                const y = x - k;\n                if (x > seq1.length || y > seq2.length) {\n                    // This diagonal is irrelevant for the result.\n                    // TODO: Don't pay the cost for this in the next iteration.\n                    continue;\n                }\n                const newMaxX = getXAfterSnake(x, y);\n                V.set(k, newMaxX);\n                const lastPath = x === maxXofDLineTop ? paths.get(k + 1) : paths.get(k - 1);\n                paths.set(k, newMaxX !== x ? new SnakePath(lastPath, x, y, newMaxX - x) : lastPath);\n                if (V.get(k) === seq1.length && V.get(k) - k === seq2.length) {\n                    break loop;\n                }\n            }\n        }\n        let path = paths.get(k);\n        const result = [];\n        let lastAligningPosS1 = seq1.length;\n        let lastAligningPosS2 = seq2.length;\n        while (true) {\n            const endX = path ? path.x + path.length : 0;\n            const endY = path ? path.y + path.length : 0;\n            if (endX !== lastAligningPosS1 || endY !== lastAligningPosS2) {\n                result.push(new SequenceDiff(new OffsetRange(endX, lastAligningPosS1), new OffsetRange(endY, lastAligningPosS2)));\n            }\n            if (!path) {\n                break;\n            }\n            lastAligningPosS1 = path.x;\n            lastAligningPosS2 = path.y;\n            path = path.prev;\n        }\n        result.reverse();\n        return new DiffAlgorithmResult(result, false);\n    }\n}\nclass SnakePath {\n    constructor(prev, x, y, length) {\n        this.prev = prev;\n        this.x = x;\n        this.y = y;\n        this.length = length;\n    }\n}\n/**\n * An array that supports fast negative indices.\n*/\nclass FastInt32Array {\n    constructor() {\n        this.positiveArr = new Int32Array(10);\n        this.negativeArr = new Int32Array(10);\n    }\n    get(idx) {\n        if (idx < 0) {\n            idx = -idx - 1;\n            return this.negativeArr[idx];\n        }\n        else {\n            return this.positiveArr[idx];\n        }\n    }\n    set(idx, value) {\n        if (idx < 0) {\n            idx = -idx - 1;\n            if (idx >= this.negativeArr.length) {\n                const arr = this.negativeArr;\n                this.negativeArr = new Int32Array(arr.length * 2);\n                this.negativeArr.set(arr);\n            }\n            this.negativeArr[idx] = value;\n        }\n        else {\n            if (idx >= this.positiveArr.length) {\n                const arr = this.positiveArr;\n                this.positiveArr = new Int32Array(arr.length * 2);\n                this.positiveArr.set(arr);\n            }\n            this.positiveArr[idx] = value;\n        }\n    }\n}\n/**\n * An array that supports fast negative indices.\n*/\nclass FastArrayNegativeIndices {\n    constructor() {\n        this.positiveArr = [];\n        this.negativeArr = [];\n    }\n    get(idx) {\n        if (idx < 0) {\n            idx = -idx - 1;\n            return this.negativeArr[idx];\n        }\n        else {\n            return this.positiveArr[idx];\n        }\n    }\n    set(idx, value) {\n        if (idx < 0) {\n            idx = -idx - 1;\n            this.negativeArr[idx] = value;\n        }\n        else {\n            this.positiveArr[idx] = value;\n        }\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
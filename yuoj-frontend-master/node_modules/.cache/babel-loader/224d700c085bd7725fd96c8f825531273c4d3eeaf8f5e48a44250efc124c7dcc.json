{"ast":null,"code":"import * as matrix from './matrix.js';\nimport Point from './Point.js';\nvar mathMin = Math.min;\nvar mathMax = Math.max;\nvar mathAbs = Math.abs;\nvar XY = ['x', 'y'];\nvar WH = ['width', 'height'];\nvar lt = new Point();\nvar rb = new Point();\nvar lb = new Point();\nvar rt = new Point();\nvar _intersectCtx = createIntersectContext();\nvar _minTv = _intersectCtx.minTv;\nvar _maxTv = _intersectCtx.maxTv;\nvar _lenMinMax = [0, 0];\nvar BoundingRect = function () {\n  function BoundingRect(x, y, width, height) {\n    BoundingRect.set(this, x, y, width, height);\n  }\n  BoundingRect.set = function (target, x, y, width, height) {\n    if (width < 0) {\n      x = x + width;\n      width = -width;\n    }\n    if (height < 0) {\n      y = y + height;\n      height = -height;\n    }\n    target.x = x;\n    target.y = y;\n    target.width = width;\n    target.height = height;\n    return target;\n  };\n  BoundingRect.prototype.union = function (other) {\n    var x = mathMin(other.x, this.x);\n    var y = mathMin(other.y, this.y);\n    if (isFinite(this.x) && isFinite(this.width)) {\n      this.width = mathMax(other.x + other.width, this.x + this.width) - x;\n    } else {\n      this.width = other.width;\n    }\n    if (isFinite(this.y) && isFinite(this.height)) {\n      this.height = mathMax(other.y + other.height, this.y + this.height) - y;\n    } else {\n      this.height = other.height;\n    }\n    this.x = x;\n    this.y = y;\n  };\n  BoundingRect.prototype.applyTransform = function (m) {\n    BoundingRect.applyTransform(this, this, m);\n  };\n  BoundingRect.prototype.calculateTransform = function (b) {\n    var a = this;\n    var sx = b.width / a.width;\n    var sy = b.height / a.height;\n    var m = matrix.create();\n    matrix.translate(m, m, [-a.x, -a.y]);\n    matrix.scale(m, m, [sx, sy]);\n    matrix.translate(m, m, [b.x, b.y]);\n    return m;\n  };\n  BoundingRect.prototype.intersect = function (b, mtv, opt) {\n    return BoundingRect.intersect(this, b, mtv, opt);\n  };\n  BoundingRect.intersect = function (a, b, mtv, opt) {\n    if (mtv) {\n      Point.set(mtv, 0, 0);\n    }\n    var outIntersectRect = opt && opt.outIntersectRect || null;\n    var clamp = opt && opt.clamp;\n    if (outIntersectRect) {\n      outIntersectRect.x = outIntersectRect.y = outIntersectRect.width = outIntersectRect.height = NaN;\n    }\n    if (!a || !b) {\n      return false;\n    }\n    if (!(a instanceof BoundingRect)) {\n      a = BoundingRect.set(_tmpIntersectA, a.x, a.y, a.width, a.height);\n    }\n    if (!(b instanceof BoundingRect)) {\n      b = BoundingRect.set(_tmpIntersectB, b.x, b.y, b.width, b.height);\n    }\n    var useMTV = !!mtv;\n    _intersectCtx.reset(opt, useMTV);\n    var touchThreshold = _intersectCtx.touchThreshold;\n    var ax0 = a.x + touchThreshold;\n    var ax1 = a.x + a.width - touchThreshold;\n    var ay0 = a.y + touchThreshold;\n    var ay1 = a.y + a.height - touchThreshold;\n    var bx0 = b.x + touchThreshold;\n    var bx1 = b.x + b.width - touchThreshold;\n    var by0 = b.y + touchThreshold;\n    var by1 = b.y + b.height - touchThreshold;\n    if (ax0 > ax1 || ay0 > ay1 || bx0 > bx1 || by0 > by1) {\n      return false;\n    }\n    var overlap = !(ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);\n    if (useMTV || outIntersectRect) {\n      _lenMinMax[0] = Infinity;\n      _lenMinMax[1] = 0;\n      intersectOneDim(ax0, ax1, bx0, bx1, 0, useMTV, outIntersectRect, clamp);\n      intersectOneDim(ay0, ay1, by0, by1, 1, useMTV, outIntersectRect, clamp);\n      if (useMTV) {\n        Point.copy(mtv, overlap ? _intersectCtx.useDir ? _intersectCtx.dirMinTv : _minTv : _maxTv);\n      }\n    }\n    return overlap;\n  };\n  BoundingRect.contain = function (rect, x, y) {\n    return x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height;\n  };\n  BoundingRect.prototype.contain = function (x, y) {\n    return BoundingRect.contain(this, x, y);\n  };\n  BoundingRect.prototype.clone = function () {\n    return new BoundingRect(this.x, this.y, this.width, this.height);\n  };\n  BoundingRect.prototype.copy = function (other) {\n    BoundingRect.copy(this, other);\n  };\n  BoundingRect.prototype.plain = function () {\n    return {\n      x: this.x,\n      y: this.y,\n      width: this.width,\n      height: this.height\n    };\n  };\n  BoundingRect.prototype.isFinite = function () {\n    return isFinite(this.x) && isFinite(this.y) && isFinite(this.width) && isFinite(this.height);\n  };\n  BoundingRect.prototype.isZero = function () {\n    return this.width === 0 || this.height === 0;\n  };\n  BoundingRect.create = function (rect) {\n    return new BoundingRect(rect.x, rect.y, rect.width, rect.height);\n  };\n  BoundingRect.copy = function (target, source) {\n    target.x = source.x;\n    target.y = source.y;\n    target.width = source.width;\n    target.height = source.height;\n    return target;\n  };\n  BoundingRect.applyTransform = function (target, source, m) {\n    if (!m) {\n      if (target !== source) {\n        BoundingRect.copy(target, source);\n      }\n      return;\n    }\n    if (m[1] < 1e-5 && m[1] > -1e-5 && m[2] < 1e-5 && m[2] > -1e-5) {\n      var sx = m[0];\n      var sy = m[3];\n      var tx = m[4];\n      var ty = m[5];\n      target.x = source.x * sx + tx;\n      target.y = source.y * sy + ty;\n      target.width = source.width * sx;\n      target.height = source.height * sy;\n      if (target.width < 0) {\n        target.x += target.width;\n        target.width = -target.width;\n      }\n      if (target.height < 0) {\n        target.y += target.height;\n        target.height = -target.height;\n      }\n      return;\n    }\n    lt.x = lb.x = source.x;\n    lt.y = rt.y = source.y;\n    rb.x = rt.x = source.x + source.width;\n    rb.y = lb.y = source.y + source.height;\n    lt.transform(m);\n    rt.transform(m);\n    rb.transform(m);\n    lb.transform(m);\n    target.x = mathMin(lt.x, rb.x, lb.x, rt.x);\n    target.y = mathMin(lt.y, rb.y, lb.y, rt.y);\n    var maxX = mathMax(lt.x, rb.x, lb.x, rt.x);\n    var maxY = mathMax(lt.y, rb.y, lb.y, rt.y);\n    target.width = maxX - target.x;\n    target.height = maxY - target.y;\n  };\n  return BoundingRect;\n}();\nvar _tmpIntersectA = new BoundingRect(0, 0, 0, 0);\nvar _tmpIntersectB = new BoundingRect(0, 0, 0, 0);\nfunction intersectOneDim(a0, a1, b0, b1, updateDimIdx, useMTV, outIntersectRect, clamp) {\n  var d0 = mathAbs(a1 - b0);\n  var d1 = mathAbs(b1 - a0);\n  var d01min = mathMin(d0, d1);\n  var updateDim = XY[updateDimIdx];\n  var zeroDim = XY[1 - updateDimIdx];\n  var wh = WH[updateDimIdx];\n  if (a1 < b0 || b1 < a0) {\n    if (d0 < d1) {\n      if (useMTV) {\n        _maxTv[updateDim] = -d0;\n      }\n      if (clamp) {\n        outIntersectRect[updateDim] = a1;\n        outIntersectRect[wh] = 0;\n      }\n    } else {\n      if (useMTV) {\n        _maxTv[updateDim] = d1;\n      }\n      if (clamp) {\n        outIntersectRect[updateDim] = a0;\n        outIntersectRect[wh] = 0;\n      }\n    }\n  } else {\n    if (outIntersectRect) {\n      outIntersectRect[updateDim] = mathMax(a0, b0);\n      outIntersectRect[wh] = mathMin(a1, b1) - outIntersectRect[updateDim];\n    }\n    if (useMTV) {\n      if (d01min < _lenMinMax[0] || _intersectCtx.useDir) {\n        _lenMinMax[0] = mathMin(d01min, _lenMinMax[0]);\n        if (d0 < d1 || !_intersectCtx.bidirectional) {\n          _minTv[updateDim] = d0;\n          _minTv[zeroDim] = 0;\n          if (_intersectCtx.useDir) {\n            _intersectCtx.calcDirMTV();\n          }\n        }\n        if (d0 >= d1 || !_intersectCtx.bidirectional) {\n          _minTv[updateDim] = -d1;\n          _minTv[zeroDim] = 0;\n          if (_intersectCtx.useDir) {\n            _intersectCtx.calcDirMTV();\n          }\n        }\n      }\n    }\n  }\n}\nexport function createIntersectContext() {\n  var _direction = 0;\n  var _dirCheckVec = new Point();\n  var _dirTmp = new Point();\n  var _ctx = {\n    minTv: new Point(),\n    maxTv: new Point(),\n    useDir: false,\n    dirMinTv: new Point(),\n    touchThreshold: 0,\n    bidirectional: true,\n    negativeSize: false,\n    reset: function (opt, useMTV) {\n      _ctx.touchThreshold = 0;\n      if (opt && opt.touchThreshold != null) {\n        _ctx.touchThreshold = mathMax(0, opt.touchThreshold);\n      }\n      _ctx.negativeSize = false;\n      if (!useMTV) {\n        return;\n      }\n      _ctx.minTv.set(Infinity, Infinity);\n      _ctx.maxTv.set(0, 0);\n      _ctx.useDir = false;\n      if (opt && opt.direction != null) {\n        _ctx.useDir = true;\n        _ctx.dirMinTv.copy(_ctx.minTv);\n        _dirTmp.copy(_ctx.minTv);\n        _direction = opt.direction;\n        _ctx.bidirectional = opt.bidirectional == null || !!opt.bidirectional;\n        if (!_ctx.bidirectional) {\n          _dirCheckVec.set(Math.cos(_direction), Math.sin(_direction));\n        }\n      }\n    },\n    calcDirMTV: function () {\n      var minTv = _ctx.minTv;\n      var dirMinTv = _ctx.dirMinTv;\n      var squareMag = minTv.y * minTv.y + minTv.x * minTv.x;\n      var dirSin = Math.sin(_direction);\n      var dirCos = Math.cos(_direction);\n      var dotProd = dirSin * minTv.y + dirCos * minTv.x;\n      if (nearZero(dotProd)) {\n        if (nearZero(minTv.x) && nearZero(minTv.y)) {\n          dirMinTv.set(0, 0);\n        }\n        return;\n      }\n      _dirTmp.x = squareMag * dirCos / dotProd;\n      _dirTmp.y = squareMag * dirSin / dotProd;\n      if (nearZero(_dirTmp.x) && nearZero(_dirTmp.y)) {\n        dirMinTv.set(0, 0);\n        return;\n      }\n      if ((_ctx.bidirectional || _dirCheckVec.dot(_dirTmp) > 0) && _dirTmp.len() < dirMinTv.len()) {\n        dirMinTv.copy(_dirTmp);\n      }\n    }\n  };\n  function nearZero(val) {\n    return mathAbs(val) < 1e-10;\n  }\n  return _ctx;\n}\nexport default BoundingRect;","map":{"version":3,"names":["matrix","Point","mathMin","Math","min","mathMax","max","mathAbs","abs","XY","WH","lt","rb","lb","rt","_intersectCtx","createIntersectContext","_minTv","minTv","_maxTv","maxTv","_lenMinMax","BoundingRect","x","y","width","height","set","target","prototype","union","other","isFinite","applyTransform","m","calculateTransform","b","a","sx","sy","create","translate","scale","intersect","mtv","opt","outIntersectRect","clamp","NaN","_tmpIntersectA","_tmpIntersectB","useMTV","reset","touchThreshold","ax0","ax1","ay0","ay1","bx0","bx1","by0","by1","overlap","Infinity","intersectOneDim","copy","useDir","dirMinTv","contain","rect","clone","plain","isZero","source","tx","ty","transform","maxX","maxY","a0","a1","b0","b1","updateDimIdx","d0","d1","d01min","updateDim","zeroDim","wh","bidirectional","calcDirMTV","_direction","_dirCheckVec","_dirTmp","_ctx","negativeSize","direction","cos","sin","squareMag","dirSin","dirCos","dotProd","nearZero","dot","len","val"],"sources":["D:/code/java/program/oj/code/yuoj-frontend-master/node_modules/zrender/lib/core/BoundingRect.js"],"sourcesContent":["import * as matrix from './matrix.js';\nimport Point from './Point.js';\nvar mathMin = Math.min;\nvar mathMax = Math.max;\nvar mathAbs = Math.abs;\nvar XY = ['x', 'y'];\nvar WH = ['width', 'height'];\nvar lt = new Point();\nvar rb = new Point();\nvar lb = new Point();\nvar rt = new Point();\nvar _intersectCtx = createIntersectContext();\nvar _minTv = _intersectCtx.minTv;\nvar _maxTv = _intersectCtx.maxTv;\nvar _lenMinMax = [0, 0];\nvar BoundingRect = (function () {\n    function BoundingRect(x, y, width, height) {\n        BoundingRect.set(this, x, y, width, height);\n    }\n    BoundingRect.set = function (target, x, y, width, height) {\n        if (width < 0) {\n            x = x + width;\n            width = -width;\n        }\n        if (height < 0) {\n            y = y + height;\n            height = -height;\n        }\n        target.x = x;\n        target.y = y;\n        target.width = width;\n        target.height = height;\n        return target;\n    };\n    BoundingRect.prototype.union = function (other) {\n        var x = mathMin(other.x, this.x);\n        var y = mathMin(other.y, this.y);\n        if (isFinite(this.x) && isFinite(this.width)) {\n            this.width = mathMax(other.x + other.width, this.x + this.width) - x;\n        }\n        else {\n            this.width = other.width;\n        }\n        if (isFinite(this.y) && isFinite(this.height)) {\n            this.height = mathMax(other.y + other.height, this.y + this.height) - y;\n        }\n        else {\n            this.height = other.height;\n        }\n        this.x = x;\n        this.y = y;\n    };\n    BoundingRect.prototype.applyTransform = function (m) {\n        BoundingRect.applyTransform(this, this, m);\n    };\n    BoundingRect.prototype.calculateTransform = function (b) {\n        var a = this;\n        var sx = b.width / a.width;\n        var sy = b.height / a.height;\n        var m = matrix.create();\n        matrix.translate(m, m, [-a.x, -a.y]);\n        matrix.scale(m, m, [sx, sy]);\n        matrix.translate(m, m, [b.x, b.y]);\n        return m;\n    };\n    BoundingRect.prototype.intersect = function (b, mtv, opt) {\n        return BoundingRect.intersect(this, b, mtv, opt);\n    };\n    BoundingRect.intersect = function (a, b, mtv, opt) {\n        if (mtv) {\n            Point.set(mtv, 0, 0);\n        }\n        var outIntersectRect = opt && opt.outIntersectRect || null;\n        var clamp = opt && opt.clamp;\n        if (outIntersectRect) {\n            outIntersectRect.x = outIntersectRect.y = outIntersectRect.width = outIntersectRect.height = NaN;\n        }\n        if (!a || !b) {\n            return false;\n        }\n        if (!(a instanceof BoundingRect)) {\n            a = BoundingRect.set(_tmpIntersectA, a.x, a.y, a.width, a.height);\n        }\n        if (!(b instanceof BoundingRect)) {\n            b = BoundingRect.set(_tmpIntersectB, b.x, b.y, b.width, b.height);\n        }\n        var useMTV = !!mtv;\n        _intersectCtx.reset(opt, useMTV);\n        var touchThreshold = _intersectCtx.touchThreshold;\n        var ax0 = a.x + touchThreshold;\n        var ax1 = a.x + a.width - touchThreshold;\n        var ay0 = a.y + touchThreshold;\n        var ay1 = a.y + a.height - touchThreshold;\n        var bx0 = b.x + touchThreshold;\n        var bx1 = b.x + b.width - touchThreshold;\n        var by0 = b.y + touchThreshold;\n        var by1 = b.y + b.height - touchThreshold;\n        if (ax0 > ax1 || ay0 > ay1 || bx0 > bx1 || by0 > by1) {\n            return false;\n        }\n        var overlap = !(ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);\n        if (useMTV || outIntersectRect) {\n            _lenMinMax[0] = Infinity;\n            _lenMinMax[1] = 0;\n            intersectOneDim(ax0, ax1, bx0, bx1, 0, useMTV, outIntersectRect, clamp);\n            intersectOneDim(ay0, ay1, by0, by1, 1, useMTV, outIntersectRect, clamp);\n            if (useMTV) {\n                Point.copy(mtv, overlap\n                    ? (_intersectCtx.useDir ? _intersectCtx.dirMinTv : _minTv)\n                    : _maxTv);\n            }\n        }\n        return overlap;\n    };\n    BoundingRect.contain = function (rect, x, y) {\n        return x >= rect.x\n            && x <= (rect.x + rect.width)\n            && y >= rect.y\n            && y <= (rect.y + rect.height);\n    };\n    BoundingRect.prototype.contain = function (x, y) {\n        return BoundingRect.contain(this, x, y);\n    };\n    BoundingRect.prototype.clone = function () {\n        return new BoundingRect(this.x, this.y, this.width, this.height);\n    };\n    BoundingRect.prototype.copy = function (other) {\n        BoundingRect.copy(this, other);\n    };\n    BoundingRect.prototype.plain = function () {\n        return {\n            x: this.x,\n            y: this.y,\n            width: this.width,\n            height: this.height\n        };\n    };\n    BoundingRect.prototype.isFinite = function () {\n        return isFinite(this.x)\n            && isFinite(this.y)\n            && isFinite(this.width)\n            && isFinite(this.height);\n    };\n    BoundingRect.prototype.isZero = function () {\n        return this.width === 0 || this.height === 0;\n    };\n    BoundingRect.create = function (rect) {\n        return new BoundingRect(rect.x, rect.y, rect.width, rect.height);\n    };\n    BoundingRect.copy = function (target, source) {\n        target.x = source.x;\n        target.y = source.y;\n        target.width = source.width;\n        target.height = source.height;\n        return target;\n    };\n    BoundingRect.applyTransform = function (target, source, m) {\n        if (!m) {\n            if (target !== source) {\n                BoundingRect.copy(target, source);\n            }\n            return;\n        }\n        if (m[1] < 1e-5 && m[1] > -1e-5 && m[2] < 1e-5 && m[2] > -1e-5) {\n            var sx = m[0];\n            var sy = m[3];\n            var tx = m[4];\n            var ty = m[5];\n            target.x = source.x * sx + tx;\n            target.y = source.y * sy + ty;\n            target.width = source.width * sx;\n            target.height = source.height * sy;\n            if (target.width < 0) {\n                target.x += target.width;\n                target.width = -target.width;\n            }\n            if (target.height < 0) {\n                target.y += target.height;\n                target.height = -target.height;\n            }\n            return;\n        }\n        lt.x = lb.x = source.x;\n        lt.y = rt.y = source.y;\n        rb.x = rt.x = source.x + source.width;\n        rb.y = lb.y = source.y + source.height;\n        lt.transform(m);\n        rt.transform(m);\n        rb.transform(m);\n        lb.transform(m);\n        target.x = mathMin(lt.x, rb.x, lb.x, rt.x);\n        target.y = mathMin(lt.y, rb.y, lb.y, rt.y);\n        var maxX = mathMax(lt.x, rb.x, lb.x, rt.x);\n        var maxY = mathMax(lt.y, rb.y, lb.y, rt.y);\n        target.width = maxX - target.x;\n        target.height = maxY - target.y;\n    };\n    return BoundingRect;\n}());\nvar _tmpIntersectA = new BoundingRect(0, 0, 0, 0);\nvar _tmpIntersectB = new BoundingRect(0, 0, 0, 0);\nfunction intersectOneDim(a0, a1, b0, b1, updateDimIdx, useMTV, outIntersectRect, clamp) {\n    var d0 = mathAbs(a1 - b0);\n    var d1 = mathAbs(b1 - a0);\n    var d01min = mathMin(d0, d1);\n    var updateDim = XY[updateDimIdx];\n    var zeroDim = XY[1 - updateDimIdx];\n    var wh = WH[updateDimIdx];\n    if (a1 < b0 || b1 < a0) {\n        if (d0 < d1) {\n            if (useMTV) {\n                _maxTv[updateDim] = -d0;\n            }\n            if (clamp) {\n                outIntersectRect[updateDim] = a1;\n                outIntersectRect[wh] = 0;\n            }\n        }\n        else {\n            if (useMTV) {\n                _maxTv[updateDim] = d1;\n            }\n            if (clamp) {\n                outIntersectRect[updateDim] = a0;\n                outIntersectRect[wh] = 0;\n            }\n        }\n    }\n    else {\n        if (outIntersectRect) {\n            outIntersectRect[updateDim] = mathMax(a0, b0);\n            outIntersectRect[wh] = mathMin(a1, b1) - outIntersectRect[updateDim];\n        }\n        if (useMTV) {\n            if (d01min < _lenMinMax[0] || _intersectCtx.useDir) {\n                _lenMinMax[0] = mathMin(d01min, _lenMinMax[0]);\n                if (d0 < d1 || !_intersectCtx.bidirectional) {\n                    _minTv[updateDim] = d0;\n                    _minTv[zeroDim] = 0;\n                    if (_intersectCtx.useDir) {\n                        _intersectCtx.calcDirMTV();\n                    }\n                }\n                if (d0 >= d1 || !_intersectCtx.bidirectional) {\n                    _minTv[updateDim] = -d1;\n                    _minTv[zeroDim] = 0;\n                    if (_intersectCtx.useDir) {\n                        _intersectCtx.calcDirMTV();\n                    }\n                }\n            }\n        }\n    }\n}\nexport function createIntersectContext() {\n    var _direction = 0;\n    var _dirCheckVec = new Point();\n    var _dirTmp = new Point();\n    var _ctx = {\n        minTv: new Point(),\n        maxTv: new Point(),\n        useDir: false,\n        dirMinTv: new Point(),\n        touchThreshold: 0,\n        bidirectional: true,\n        negativeSize: false,\n        reset: function (opt, useMTV) {\n            _ctx.touchThreshold = 0;\n            if (opt && opt.touchThreshold != null) {\n                _ctx.touchThreshold = mathMax(0, opt.touchThreshold);\n            }\n            _ctx.negativeSize = false;\n            if (!useMTV) {\n                return;\n            }\n            _ctx.minTv.set(Infinity, Infinity);\n            _ctx.maxTv.set(0, 0);\n            _ctx.useDir = false;\n            if (opt && opt.direction != null) {\n                _ctx.useDir = true;\n                _ctx.dirMinTv.copy(_ctx.minTv);\n                _dirTmp.copy(_ctx.minTv);\n                _direction = opt.direction;\n                _ctx.bidirectional = opt.bidirectional == null || !!opt.bidirectional;\n                if (!_ctx.bidirectional) {\n                    _dirCheckVec.set(Math.cos(_direction), Math.sin(_direction));\n                }\n            }\n        },\n        calcDirMTV: function () {\n            var minTv = _ctx.minTv;\n            var dirMinTv = _ctx.dirMinTv;\n            var squareMag = minTv.y * minTv.y + minTv.x * minTv.x;\n            var dirSin = Math.sin(_direction);\n            var dirCos = Math.cos(_direction);\n            var dotProd = dirSin * minTv.y + dirCos * minTv.x;\n            if (nearZero(dotProd)) {\n                if (nearZero(minTv.x) && nearZero(minTv.y)) {\n                    dirMinTv.set(0, 0);\n                }\n                return;\n            }\n            _dirTmp.x = squareMag * dirCos / dotProd;\n            _dirTmp.y = squareMag * dirSin / dotProd;\n            if (nearZero(_dirTmp.x) && nearZero(_dirTmp.y)) {\n                dirMinTv.set(0, 0);\n                return;\n            }\n            if ((_ctx.bidirectional\n                || _dirCheckVec.dot(_dirTmp) > 0)\n                && _dirTmp.len() < dirMinTv.len()) {\n                dirMinTv.copy(_dirTmp);\n            }\n        }\n    };\n    function nearZero(val) {\n        return mathAbs(val) < 1e-10;\n    }\n    return _ctx;\n}\nexport default BoundingRect;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}